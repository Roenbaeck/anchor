<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Anchor Modeler</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <style type="text/css">
    body {
        font:               8pt "Open Sans", "Helvetica Neue", sans-serif;
        line-height:        1.88889;
        color:              #000000;
        background:         #f9f8f7;
        overflow:           hidden;
        margin:             0;
        padding:            0;
    }

    * {
        target-new:         tab ! important
    }
    
    a:link, a:active, a:visited {
        color:              #b55;
        text-decoration:    none;
    }
    a:hover {
        color:              #633;
        text-decoration:    underline;
    }

    .unselectable {
        user-select:        none;
        -moz-user-select:   none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:    none;
    }

    .invisible {
        opacity:            0;
        filter:             alpha(opacity=0);
        z-index:            1000;
        position:           absolute;
        left:               0;
    }

    .editable:invalid {
        background-color:   #fbb;
    }

    .closebutton {
        display:            none;
        background-image:   url(deleteButton.png);
        position:           absolute;
        left:               -15px;
        top:                -15px;
        height:             30px;
        width:              30px;
        z-index:            14;
    }
    .closebutton:active {
        background-image:   url(deleteButtonPressed.png);
    }

    /* visible canvas - at the bottom of the visible layers */
    #canvas {
        visibility:         hidden;
        position:           absolute;
        top:                0px;
        left:               0px;
        z-index:            1;
    }

    #graph {
        position:           absolute;
        top:                0px;
        left:               0px;
        width:              100%;
        height:             100%;
        z-index:            1;
    }

    /* invisible canvas - at the very z-bottom */
    #shadow {
        position:           absolute;
        top:                0px;
        left:               0px;
        display:            none;
        z-index:            0;
    }

    /* minature canvas - positioned in the southeast corner */
    #miniature {
        position:           absolute;
        bottom:             40px;
        right:              42px;
        background-color:   #fff;
        z-index:            2;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    #minigraph {
        display:            block;
    }

    #search {
        position:           absolute;
        top:                42px;
        left:               50%;
        margin-left:        -150px; /* half of the actual width */
        display:            block;
        z-index:            9;
    }
    #search input {
        width:              150px;
        text-align:         left;
        background-color:   rgba(255, 255, 255, 0.9);
    }
    #search select {
        width:              150px;
        text-align:         left;
        background-color:   rgba(255, 255, 255, 0.9);
    }

    /* shows login status to the cloud (google app engine) */
    #cloud {
        font:               8pt sans-serif;
        position:           absolute;
        color:              black;
        text-align:         left;
        bottom:             12px;
        left:               12px;
        cursor:             pointer;
        display:            block;
        z-index:            10;
    }

    /* shows model name if cloud based or local */
    #model {
        font:               8pt sans-serif;
        position:           absolute;
        color:              black;
        text-align:         left;
        bottom:             26px;
        left:               12px;
        display:            block;
        z-index:            10;
    }

    /* context menu that pops up when editing */
    #contextMenu {
        position:           absolute;
        top:                0;
        left:               0;
        display:            block;
        background-color:   rgba(212, 212, 212, 0.8);
        color:              black;
        padding:            0;
        margin:             0;
        text-align:         left;
        border:             2px solid #fff;
        z-index:            11;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    #contextMenu .items {
        margin:             10px 10px 5px 10px;
    }
    #contextMenu .topper {
        font:               10px sans-serif;
        cursor:             move;
        color:              #333;
        height:             15px;
        padding-top:        2px;
        padding-left:       24px;
        border-bottom:      1px solid #888;
        background-color:   rgba(255, 255, 255, 0.8);
    }

    .toggler {
        position:           absolute;
        color:              #555;
        margin:             0;
        padding:            0;
        border:             1px solid #555;
        width:              16px;
        height:             16px;
        z-index:            12;
    }
    .expanded {
        cursor:             nw-resize;
        background-color:   #f55;
    }
    .collapsed {
        cursor:             se-resize;
        left:               -3px;
        top:                -3px;
        background-color:   #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    .collapsed:hover {
        background-color:   #fa5;
    }

    .operators {
        position:           relative;
        margin:             0px 5px 5px 5px;
        top:                0;
        left:               0;
    }

    .operator {
        margin:             0;
        line-height:        25px;
        text-align:         left;
        cursor:             pointer;
        white-space:        nowrap;
        padding-right:      10px;
        padding-left:       10px;
        z-index:            8;
    }

    .operator:hover {
        color:              white;
        background-color:   rgba(128, 128, 128, 0.8);
        text-decoration:    none;
        text-shadow:        0px 0px 6px #555;
    }


    /* is used in the code popover */
    #modalBackground {
        position:           absolute;
        top:                0;
        left:               0;
        background-color:   rgba(142, 128, 128, 0.5);
        margin:             0;
        padding-top:        25%;
        overflow:           hidden;
        z-index:            10;
        text-align:         center;
        color:              white;
        font-family:        sans-serif;
        font-size:          25pt;
        font-weight:        bold;
        text-shadow:        0px 3px 5px rgba(0, 0, 0, 0.5);
    }

    #urlPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #urlPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #urlPopover #content {
        margin-top:         -30px;
        padding:            0;
    }


    #cloudBrowserPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #cloudBrowserPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #cloudBrowserPopover #content {
        margin:             -10px 10px 20px 10px;
        padding:            0;
    }
    .modelContainer {
        text-align:         left;
        color:              black;
        border-width:       medium;
        border-style:       inset;
        margin:             0px 5px 10px 5px;
        padding:            8px;
        cursor:             pointer;
        height:             140px;
    }
    .modelIcon {
        background:         #fff;
        border:             1px solid black;
        width:              140px;
        max-height:         140px;
        clip:               rect(0px,140px,140px,0px);
        float:              left;
        clear:              both;
        margin-right:       10px;
        box-shadow:         0px 3px 5px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 3px 5px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 3px 5px rgba(0, 0, 0, 0.5);
    }
    .externalLink {
        margin-left:        0.5em;
    }
    .modelName {
        font:               100% georgia, sans-serif;
    }
    .modelKeywords {
        font:               italic 75% georgia, sans-serif;
    }
    .modelDescription {
        margin-top:         8pt;
        font:               90% georgia, sans-serif;
    }
    .twitter {
        margin-top:         8pt;
        font:               italic 90% georgia, sans-serif;
    }
    #keywordFilter {
        position:           relative;
        text-align:         center;
        top:                -20px;
        font:               10pt georgia, sans-serif;
    }
    .modelDeleteButton  {
        border-style: hidden;
        display: block;
        margin: -8px -2px -20px;
        padding: 0;
        background-image:   url(deleteButton.png);
        position:           relative;
        left:               -15px;
        top:                -15px;
        height:             30px;
        width:              30px;
        z-index:            14;
    }

    #cloudSaverPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #cloudSaverPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #cloudSaverPopover #content {
        margin:             -10px 10px 10px 10px;
        padding:            0;
        text-align:         center;
    }
    #cloudSaverPopover #content table {
        margin-top:         20px;
        margin-bottom:      20px;
    }
    #cloudSaverPopover #content td {
        font:               84% georgia, sans-serif;
        color:              black;
        padding-top:        5px;
        text-align:         left;
    }
    #cloudSaverPopover #content img {
        background:         #fff;
        border:             1px solid black;
        box-shadow:         0px 3px 5px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 3px 5px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 3px 5px rgba(0, 0, 0, 0.5);
    }


    /* these classes style the xml representation */
    #codePopover {
        position:           relative;
        border:             2px solid black;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(8, 0, 0, 0.8);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #codePopover .closebutton {
        display:            inherit;
        position:           relative;
    }

    #content {
        position:           relative;
        margin-top:         -30px;
        text-align:         left;
        font:               125% Andale Mono, monospace;
        color:              white;
        padding:            15px 20px;
        overflow:           auto;
        background-color:   transparent;
        z-index:            12;
    }
    #content .tabs {
        visibility:         hidden;
    }
    #content .texts {
        color:              #f55;
        font-weight:        bold;
    }
    #content .brackets {
        color:              white;
    }
    #content .elements {
        color:              #ffffc0;
    }
    #content .attributes {
        color:              #c0c0c0;
        font-weight:        bold;
    }
    #content .values {
        color:              #ffc0c0;
        font-style:         italic;
    }
    .preformatted {
        white-space:        pre;
    }


    /* Menus and control buttons */
    ul, li, table, tr, td {
		list-style-type:    none;
		margin:             0;
        padding:            0;
        border:             0;
        border-collapse:    collapse;
	}

    td {
        padding:            0px 5px 2px 5px;
    }

    legend {
        padding:            0.2em 0.5em;
        color:              #555;
        font-size:          90%;
        text-align:         left;
    }

    #header {
        font:               10pt "Open Sans", "Helvetica Neue", sans-serif;
        position:           relative;
        margin:             0;
        padding:            0;
        top:                0;
        left:               0;
        height:             32px;
        display:            block;
        background-color:   rgba(236, 234, 234, 0.9);
        color:              black;
        border-bottom:      2px solid #fff;
        box-shadow:         0px 0px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 0px 10px rgba(0, 0, 0, 0.5);
        z-index:            7;
    }

    /* http://www.ie7nomore.com/fun/menu2/ */
    /* TODO: position using relative instead */
    #actions, #settings, #file, #generate, #about, #defaults {
        position:           absolute;
        display:            block;
        top:                0px;
        z-index:            42;
    }
    #file {
        left:               8px;
        text-align:         left;
        z-index:            43;
    }
    #actions {
        left:               50px;
        text-align:         left;
        z-index:            44;
    }
    #generate {
        left:               110px;
        text-align:         left;
        z-index:            45;
    }
    #defaults {
        right:              130px;
        text-align:         right;
        z-index:            45;
    }
    #settings {
        right:              60px;
        text-align:         right;
        z-index:            44;
    }
    #about {
        right:              8px;
        text-align:         right;
        z-index:            43;
    }
    #file .fileSelect {
        width:              200px;
    }
    .menu {
        margin:             0;
        cursor:             pointer;
        list-style:         none;
        padding-left:       8px;
        padding-right:      8px;
        line-height:        32px;
        display:            inline-block;
    }
    .menu:hover {
        font-style:         italic;
    }
    .submenu {
        display:            none;
        position:           relative;
        background-color:   rgba(236, 234, 234, 0.9);
        white-space:        nowrap;
        border:             2px solid #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
        z-index:            9;
    }
    .menu:hover > .submenu {
        display:            block;
    }
    .submenu li {
        height:             25px;
        line-height:        25px;
        list-style-type:    none;
        margin:             0;
        padding-right:      8px;
        padding-left:       8px;
        color:              black;
        font-style:         normal;
        text-decoration:    none !important;
        text-shadow:        none;
        text-align:         left;
    }
    .submenu li:hover {
        color:              white;
        background-color:   rgba(128, 128, 128, 0.8);
        text-decoration:    none;
        text-shadow:        0px 0px 6px #555;
    }
    .submenu select {
        width:              108px;
    }
    .submenu input {
        width:              45px;
    }
    .submenu .inputDefaults {
        width:              104px;
    }

    #controls {
        position:           absolute;
        top:                0px;
        left:               50%;
        margin-left:        -200px; /* half of the actual width */
        height:             32px;
        display:            block;
        z-index:            555;
    }
    #controls .playing {
        background-color:   #fa5;
    }
    #controls .pausing {
        /* just go back to normal */
    }
    #controls div {
        cursor:             pointer;
        position:           relative;
        top:                0;
        display:            inline-block;
        width:              100px;
        height:             16px;
        padding:            8px 0 8px 20px;
        margin:             0;
        border:             0;
        background:         #b55;
        color:              #fff;
        text-decoration:    none;
        text-shadow:        0px 0px 6px #777;
        -moz-border-radius: 10px 0 / 40px 0;
        -webkit-border-radius: 10px 0 / 40px 0;
        border-radius:      10px 0 / 40px 0;
        -webkit-transition: .5s;
        -moz-transition:    .5s;
        transition:         .5s;
    }
    #controls div:hover {
        background:         #f77;
    }
    #controls div + div {
        margin-left:        -50px;
    }

    </style>

    <!-- run some checks first -->
    <script type="text/javascript">
        <!--
        var testingCanvas = document.createElement('canvas');
        if (!testingCanvas || !testingCanvas.getContext)
            unsupported();

        var testingContext = testingCanvas.getContext('2d');
        if (!testingContext)
            unsupported();

        function unsupported() {
            // disable handlers and leave
            window.init = null;
            window.onbeforeunload = null;
            window.onunload = null;
            window.location = "unsupported.html";
        }
        // -->
    </script>

    <script type="text/javascript">
        <!--
        var VERSION = 0.96;

        // set to true to show debugging information
        var DEBUG = false;

        // used when creating svg elements
        var SVGNS = "http://www.w3.org/2000/svg";
        var XLINKNS = "http://www.w3.org/1999/xlink";
        // the svg root and graph elements
        var SVG;
        // the navigation miniature
        var NAV;

        // global variables for the cloud stuff
        var ASKBEFOREUNLOAD = true;
        var LOGGED_IN = false;
        var PARAMETERS = {};
        var USER_ID = "";

        // latin-1 encoding
        var LOWER = '[a-z0-9\u00E0-\u00F6\u00F8-\u00FF]';
        var UPPER = '[A-Z\u00C0-\u00D6\u00D8-\u00DF]';


        var Defaults = {
            changingRange: 'datetime',
            encapsulation: 'dbo',
            identity: 'int',
            metadataPrefix: 'Metadata',
            metadataType: 'int',
            metadataUsage: 'true',
            changingSuffix: 'ChangedAt',
            identitySuffix: 'ID',
            recordingRange: 'datetime',
            recordingSuffix: 'RecordedAt',
            erasingSuffix: 'ErasedAt',
            partitioning: 'false',
            entityIntegrity: 'true',
            restatability: 'true',
            idempotency: 'false',
            naming: 'improved'
        };

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 30,
            // 4 percent damping (simulated friction)
            damping: 0.96,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // minimum starting velocity is a whole pixel
            minimumStartingVelocity: 1,
            // maximum starting velocity is higher (to remove "twitching" when few nodes are moving)
            maximumStartingVelocity: 5,
            // maximum - minimum starting velocity
            startingVelocityDelta: 4,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.00003703703704,
            // size of partitions in number of normal distances
            partitionFactor: 8,
            // the stiffness of the edges
            stiffness: 6,
            // when the layout has reached equilibrium
            equilibrium: true,
            // which layout function to use
            layout: null,
            // holds space partitions
            partitions: null,
            // size of partitions
            partitionSize: 120,
            // the effect of the long range force
            longRangeEffect: 0.25,
            // fuzziness of the partition size
            fuzziness: 0.1,
            fuzz: 24,
            fuzzing: 0,
            init: function() {
                this.layout = this.simpleLayout;
                this.attractionConstant = 1/this.normalDistance/this.normalDistance/this.normalDistance;
                this.partitionSize = this.partitionFactor * this.normalDistance;
                this.startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;
                this.fuzz = this.normalDistance * this.partitionFactor * this.fuzziness;
            },
            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },
            // measures distance between two nodes
            manhattanDistance: function(node, otherNode) {
                var d = Math.abs(otherNode.xPosition - node.xPosition) +
                        Math.abs(otherNode.yPosition - node.yPosition);
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            euclideanDistance: function(node, otherNode) {
                var d = Math.sqrt(this.square(otherNode.xPosition - node.xPosition) +
                        this.square(otherNode.yPosition - node.yPosition));
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            // x component of the repelling force formula
            xSimpleRepelling: function(node, otherNode) {
                return (node.xPosition - otherNode.xPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            ySimpleRepelling: function(node, otherNode) {
                return (node.yPosition - otherNode.yPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xSimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPosition - node.xPosition) *
                        this.manhattanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            ySimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPosition - node.yPosition) *
                        this.manhattanDistance(node, otherNode);
            },
            // x component of the repelling force formula
            xComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.xPosition - otherNode.xPosition) /
                        this.square(this.euclideanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            yComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.yPosition - otherNode.yPosition) /
                        this.square(this.euclideanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant *
                        (otherNode.xPosition - node.xPosition) * this.euclideanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            yComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant *
                        (otherNode.yPosition - node.yPosition) * this.euclideanDistance(node, otherNode);
            },
            // create the square of influence
            createSquare: function(node, offset) {
                return {
                    xMin: node.xPosition - offset,
                    xMax: node.xPosition + offset,
                    yMin: node.yPosition - offset,
                    yMax: node.yPosition + offset
                };
            },
            // check if a node falls within the square of influence
            withinSquare: function(otherNode, square) {
                return  otherNode.xPosition >= square.xMin &&
                        otherNode.xPosition <= square.xMax &&
                        otherNode.yPosition >= square.yMin &&
                        otherNode.yPosition <= square.yMax;
            },

            // calculate all forces and change the velocity and position of the node
            simpleLayout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, curvature, square;
                var numberOfNodes = model.visibleNodes.length;
                var numberOfStoppedNodes = 0;

                // set up partitions
                this.partitions = {};
                this.fuzzing = (this.fuzzing + 1) % 3;
                var key, otherKey, partition, otherPartition, xPosition, yPosition, size;
                size = this.partitionSize - this.fuzz + this.fuzzing * this.fuzz;
                for(i = 0; node = model.visibleNodes[i]; i++) {
                    // count the number of stopped nodes
                    if(!node.moving || node.getFixed())
                        numberOfStoppedNodes++;
                    xPosition = Math.floor(node.xPosition / size);
                    yPosition = Math.floor(node.yPosition / size);
                    key = xPosition.toString() + '|' + yPosition.toString();
                    if(!this.partitions[key]) {
                         partition = {
                            nodes: [node],
                            xPosition: node.xPosition,
                            yPosition: node.yPosition,
                            xVelocity: 0,
                            yVelocity: 0,
                            xMin: node.xPosition,
                            yMin: node.yPosition,
                            xMax: node.xPosition,
                            yMax: node.yPosition
                        };
                        this.partitions[key] = partition;
                    }
                    else {
                        partition = this.partitions[key];
                        // find the center of mass in the partition
                        partition.xPosition =
                                (partition.xPosition * partition.nodes.length + node.xPosition) /
                                (partition.nodes.length + 1);
                        partition.yPosition =
                                (partition.yPosition * partition.nodes.length + node.yPosition) /
                                (partition.nodes.length + 1);
                        if(node.xPosition < partition.xMin)
                            partition.xMin = node.xPosition;
                        else if(node.xPosition > partition.xMax)
                            partition.xMax = node.xPosition;
                        if(node.yPosition < partition.yMin)
                            partition.yMin = node.yPosition;
                        else if(node.yPosition > partition.yMax)
                            partition.yMax = node.yPosition;
                        partition.nodes.push(node);
                    }
                }
                // calculate the velocity of the partitions
                for(key in this.partitions) {
                    partition = this.partitions[key];
                    for(otherKey in this.partitions) {
                        if(key != otherKey) {
                            otherPartition = this.partitions[otherKey];
                            partition.xVelocity +=
                                    otherPartition.nodes.length *
                                            this.xSimpleRepelling(partition, otherPartition);
                            partition.yVelocity +=
                                    otherPartition.nodes.length *
                                            this.ySimpleRepelling(partition, otherPartition);
                        }
                    }
                }
                for(key in this.partitions) {
                    partition = this.partitions[key];
                    for(i = 0; node = partition.nodes[i]; i++) {
                        // add the long range effect from other partitions, somewhat weakened
                        node.xVelocity += this.longRangeEffect * partition.xVelocity;
                        node.yVelocity += this.longRangeEffect * partition.yVelocity;
                        for(j = 0; otherNode = partition.nodes[j]; j++) {
                            if(i != j) {
                                // for nodes in the same partition add the repelling velocity
                                node.xVelocity += this.xSimpleRepelling(node, otherNode);
                                node.yVelocity += this.ySimpleRepelling(node, otherNode);
                            }
                        }
                        // bending force (straightens out edges)
                        if(node instanceof Edge && node.otherNode.visible && node.node.visible) {
                            // update the control and center points
                            node.controlPoint.xPosition = 2 * node.xPosition -
                                    node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                            node.controlPoint.yPosition = 2 * node.yPosition -
                                    node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                            node.centerPoint.xPosition = node.node.xPosition +
                                    (node.otherNode.xPosition - node.node.xPosition) / 2;
                            node.centerPoint.yPosition = node.node.yPosition +
                                    (node.otherNode.yPosition - node.node.yPosition) / 2;
                            // stiffness controls the attraction between the node and center point
                            node.xVelocity += this.xSimpleAttracting(node, node.centerPoint) * this.stiffness;
                            node.yVelocity += this.ySimpleAttracting(node, node.centerPoint) * this.stiffness;
                        }
                        // for all edges, add the attracting velocity
                        for(j = 0; edge = node.edges[j]; j++) {
                            if(edge.visible) {
                                node.xVelocity += this.xSimpleAttracting(node, edge) / node.edges.length;
                                node.yVelocity += this.ySimpleAttracting(node, edge) / node.edges.length;
                            }
                        }
                        // apply damping
                        node.xVelocity *= this.damping;
                        node.yVelocity *= this.damping;
                        node.velocity = Math.abs(node.xVelocity) + Math.abs(node.yVelocity);
                        // check to see if the node has stopped moving
                        if(node.velocity <= this.stoppingVelocity)
                            node.stop();
                        // the more nodes that have stopped, the larger the starting velocity must be
                        if(node.velocity >= this.minimumStartingVelocity +
                                this.startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                            node.start();
                        // if the node is moving and not fixed then calculate the new position
                        if(node.moving && !node.getFixed()) {
                            this.equilibrium = false;
                            node.xPosition += node.xVelocity;
                            node.yPosition += node.yVelocity;
                        }
                    }
                }
            },
            // calculate all forces and change the velocity and position of the node
            complexLayout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, curvature, square;
                var numberOfNodes = model.visibleNodes.length;
                var numberOfStoppedNodes = 0;

                // set up partitions
                this.partitions = {};
                this.fuzzing = (this.fuzzing + 1) % 3;
                var key, otherKey, partition, otherPartition, xPosition, yPosition, size;
                size = this.partitionSize - this.fuzz + this.fuzzing * this.fuzz;
                for(i = 0; node = model.visibleNodes[i]; i++) {
                    // count the number of stopped nodes
                    if(!node.moving || node.getFixed())
                        numberOfStoppedNodes++;
                    xPosition = Math.floor(node.xPosition / size);
                    yPosition = Math.floor(node.yPosition / size);
                    key = xPosition.toString() + '|' + yPosition.toString();
                    if(!this.partitions[key]) {
                        partition = {
                            nodes: [node],
                            xPosition: node.xPosition,
                            yPosition: node.yPosition,
                            mass: node.getMass(),
                            charge: node.getCharge(),
                            xVelocity: 0,
                            yVelocity: 0,
                            xMin: node.xPosition,
                            yMin: node.yPosition,
                            xMax: node.xPosition,
                            yMax: node.yPosition,
                            getMass: function() {
                                return this.mass;
                            },
                            getCharge: function() {
                                return this.charge;
                            }
                        };
                        this.partitions[key] = partition;
                    }
                    else {
                        partition = this.partitions[key];
                        // find the center of mass in the partition
                        partition.xPosition =
                                (partition.xPosition * partition.mass + node.xPosition * node.getMass()) /
                                        (partition.mass + node.getMass());
                        partition.yPosition =
                                (partition.yPosition * partition.mass + node.yPosition * node.getMass()) /
                                        (partition.mass + node.getMass());
                        partition.mass += node.getMass();
                        partition.charge += node.getCharge();
                        if(node.xPosition < partition.xMin)
                            partition.xMin = node.xPosition;
                        else if(node.xPosition > partition.xMax)
                            partition.xMax = node.xPosition;
                        if(node.yPosition < partition.yMin)
                            partition.yMin = node.yPosition;
                        else if(node.yPosition > partition.yMax)
                            partition.yMax = node.yPosition;
                        partition.nodes.push(node);
                    }
                }
                // calculate the velocity of the partitions
                for(key in this.partitions) {
                    partition = this.partitions[key];
                    for(otherKey in this.partitions) {
                        if(key != otherKey) {
                            otherPartition = this.partitions[otherKey];
                            partition.xVelocity +=
                                    otherPartition.nodes.length *
                                            this.xComplexRepelling(partition, otherPartition);
                            partition.yVelocity +=
                                    otherPartition.nodes.length *
                                            this.yComplexRepelling(partition, otherPartition);
                        }
                    }
                }
                for(key in this.partitions) {
                    partition = this.partitions[key];
                    for(i = 0; node = partition.nodes[i]; i++) {
                        // add the long range effect from other partitions, somewhat weakened
                        node.xVelocity += this.longRangeEffect * partition.xVelocity;
                        node.yVelocity += this.longRangeEffect * partition.yVelocity;
                        for(j = 0; otherNode = partition.nodes[j]; j++) {
                            if(i != j) {
                                // for nodes in the same partition add the repelling velocity
                                node.xVelocity += this.xComplexRepelling(node, otherNode);
                                node.yVelocity += this.yComplexRepelling(node, otherNode);
                            }
                        }
                        // bending force (straightens out edges)
                        if(node instanceof Edge && node.otherNode.visible && node.node.visible) {
                            // update the control and center points
                            node.controlPoint.xPosition = 2 * node.xPosition -
                                    node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                            node.controlPoint.yPosition = 2 * node.yPosition -
                                    node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                            node.centerPoint.xPosition = node.node.xPosition +
                                    (node.otherNode.xPosition - node.node.xPosition) / 2;
                            node.centerPoint.yPosition = node.node.yPosition +
                                    (node.otherNode.yPosition - node.node.yPosition) / 2;
                            // stiffness controls the attraction between the node and center point
                            node.xVelocity += this.xComplexAttracting(node, node.centerPoint) * this.stiffness;
                            node.yVelocity += this.yComplexAttracting(node, node.centerPoint) * this.stiffness;
                        }
                        // for all edges, add the attracting velocity
                        for(j = 0; edge = node.edges[j]; j++) {
                            if(edge.visible) {
                                node.xVelocity += this.xComplexAttracting(node, edge) / node.edges.length;
                                node.yVelocity += this.yComplexAttracting(node, edge) / node.edges.length;
                            }
                        }
                        // apply damping
                        node.xVelocity *= this.damping;
                        node.yVelocity *= this.damping;
                        node.velocity = Math.abs(node.xVelocity) + Math.abs(node.yVelocity);
                        // check to see if the node has stopped moving
                        if(node.velocity <= this.stoppingVelocity)
                            node.stop();
                        // the more nodes that have stopped, the larger the starting velocity must be
                        if(node.velocity >= this.minimumStartingVelocity +
                                this.startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                            node.start();
                        // if the node is moving and not fixed then calculate the new position
                        if(node.moving && !node.getFixed()) {
                            this.equilibrium = false;
                            node.xPosition += node.xVelocity;
                            node.yPosition += node.yVelocity;
                        }
                    }
                }
            }
        };

        var Color = {
            normal: {
                canvasBackground: '#f9f8f7',
                shadowBackground: '#000',
                svgBackground: '#fff',
                viewport: '#b55',
                outerHovered: '#ede5e5',
                innerHovered: '#fff',
                outerSelected: '#ede5e5',
                innerSelected: '#b88',
                defaultShadowColor: '#fff',
                textIncomplete: '#e00',
                textComplete: '#000',
                forceVector: '#080',
                forceEndpoint: '#fff',
                partitionOutline: '#e9e8e7',
                partitionForceVector: '#888',
                partitionForceEndpoint: '#ccc',
                attributeFill: '#fff',
                attributeOutline: '#f88',
                anchorFill: '#b55',
                knotFill: '#fff',
                knotOutline: '#f88',
                tieFill: '#a8a8a8',
                tieOutline: '#fff',
                edge: '#544',
                cardinality: '#544',
                identifierOutline: '#544',
                identifierSelectedFill: '#766',
                identifierUnselectedFill: '#fff',
                fixed: '#000'
            },
            imploded: {
                anchorFill: '#633',
/*                tieFill: '#e8e5e5',
                tieOutline: '#fff',*/
                fixed: '#fff'
            },
            schemes: ['imploded'],
            scheme: null,
            useScheme: function(scheme) {
                this.scheme = scheme;
            },
            init: function() {
                this.useScheme(this.normal);
                var scheme;
                for(var i = 0; scheme = this.schemes[i]; i++) {
                    for(var color in this.normal) {
                        if(!this[scheme][color])
                            this[scheme][color] = this.normal[color];
                    }
                }
            }
        };

        Color.init();

        var UniqueColor = {
            // note that #000000 is reserved for the background and never assigned
            takenColors: {},
            formatColor: function(red, green, blue) {
                return '#' +
                        ('0' + red.toString(16)).slice(-2) +
                        ('0' + green.toString(16)).slice(-2) +
                        ('0' + blue.toString(16)).slice(-2);
            },
            reserveUniqueColor: function() {
                var r = Math.ceil(Math.random() * 255);
                var g = Math.ceil(Math.random() * 255);
                var b = Math.ceil(Math.random() * 255);
                var color = this.formatColor(r, g, b);
                if(this.takenColors[color] || (r + g + b) == 0)
                    return this.reserveUniqueColor();
                this.takenColors[color] = true;
                return color;
            },
            releaseUniqueColor: function(color) {
                delete this.takenColors[color];
            }
        };

        var Model = {
            // these are used in the cloud
            name: null,
            scope: 'private',
            keywords: null,
            id: null,
            description:null,
            // other members
            nodes: [],
            visibleNodes: [],
            shadowToNode: {},
            version: -1,
            versions: [],
            uncloud: function() {
                this.name = null;
                this.scope = 'private';
                this.keywords = null;
                this.id = null;
            },
            isEmpty: function() {
                return this.nodes.length == 0;
            },
            empty: function() {
                this.nodes = [];
                this.shadowToNode = {};
            },
            refresh: function() {
                // copy visible nodes
                this.visibleNodes.length = 0;
                var node;
                for(var i = 0; node = this.nodes[i]; i++) {
                    if(node.visible)
                        this.visibleNodes.push(node);
                }
            },
            // TODO: We probably should have a maximum number of versions
            recordState: function() {
                this.refresh();
                // only record if there is something to record
                if(this.nodes.length) {
                    this.version++;
                    this.versions[this.version] = this.toXML(false);
                    this.versions.length = this.version + 1;
                    ControlButtons.setUndoLevels(this.version);
                    ControlButtons.setRedoLevels(0);
                }
            },
            clearStates: function() {
                this.version = -1;
                this.versions = [];
                ControlButtons.setUndoLevels(0);
                ControlButtons.setRedoLevels(0);
            },
            undoState: function() {
                this.version -= (this.version == 0 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            redoState: function() {
                this.version += (this.version == this.versions.length - 1 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            setupMinimal: function(ask) {
                var go = ask ? confirm("Are you sure you want to clear the current model?\n" +
                                       "Any unsaved changes will be lost!") : true;
                if(go) {
                    this.uncloud();
                    this.empty();
                    this.addNode(new Anchor(DrawingEngine.canvas.width/2, DrawingEngine.canvas.height/2));
                    this.refresh();
                    CanvasEventHandler.clearSelection();
                    Actions.setModelStatus();
                    DrawingEngine.reset();
                    Actions.resetZoom();
                    Actions.centerModel();
                    DrawingEngine.start(false);
                }
            },
            isConforming: function() {
                var i, node;
                for(i = 0; node = Model.nodes[i]; i++)
                    if(!node.isConforming())
                        return false;
                return true;
            },
            sort: function() {
                this.nodes.sort(function(a, b) {
                    if (a instanceof Edge)
                        return -1;
                    if (a instanceof Knot && !(b instanceof Edge))
                        return -1;
                    if (a instanceof Anchor && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    if (a instanceof Attribute && !(b instanceof Anchor) && !(b instanceof Edge) &&
                            !(b instanceof Knot))
                        return -1;
                    return 1;
                });
            },
            addNode: function(node) {
                // add node at the end of the array
                if(node) {
                    this.nodes[this.nodes.length] = node;
                    this.sort();
                    this.shadowToNode[node.shadowColor] = node;
                    this.invalidateNode(node);
                }
            },
            removeNode: function(node) {
                if(node instanceof Knot) {
                    var edge = node.edges[0];
                    var otherNode = edge.node == this ? edge.otherNode : edge.node;
                    if(otherNode instanceof Attribute)
                        otherNode.setKnotted(false);
                }
                UniqueColor.releaseUniqueColor(node.shadowColor);
                delete this.shadowToNode[node.shadowColor];
                this.deleteElementFromArray(this.nodes, node);
            },
            addEdge: function(edge) {
                // the edge is also a node
                if(edge)
                    this.addNode(edge);
            },
            removeEdge: function(edge) {
                this.deleteElementFromArray(edge.node.edges, edge);
                this.deleteElementFromArray(edge.otherNode.edges, edge);
                this.removeNode(edge);
            },
            getNodeFromShadow: function(shadow) {
                return this.shadowToNode[shadow];
            },
            deleteElementFromArray: function(array, element) {
                array.splice(array.indexOf(element), 1);
            },
            invalidateNode: function(node) {
                var square = LayoutEngine.createSquare(node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.nodes.length; i++)
                    if(LayoutEngine.withinSquare(this.nodes[i], square))
                        this.nodes[i].start();
            },
            toXML: function(serialize) {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                var metadata = schema.createElement('metadata');
                metadata.setAttribute('format', VERSION);
                metadata.setAttribute('temporalization', Settings.temporalization);
                schema.documentElement.appendChild(metadata);
                for(var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i].toXML(schema);
                    if(node != null)
                        schema.documentElement.appendChild(node);
                }
                if(serialize) {
                    var serialization = schema.createElement('serialization');
                    serialization.textContent = new XMLSerializer().serializeToString(schema);
                    schema.documentElement.appendChild(serialization);
                }
                return schema;
            },
            toSVG: function() {
                var type = document.implementation.createDocumentType(
                        "svg",
                        "-//W3C//DTD SVG 1.0//EN",
                        "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"
                );
                var svg = document.implementation.createDocument(SVGNS, "svg", type);
                var g = svg.createElementNS(SVGNS, 'g');
                for(var i = 0; i < this.visibleNodes.length; i++)
                    this.visibleNodes[i].toSVG(svg, g);
                var node;
                if(DrawingEngine.showNames) {
                    for(i = 0; node = this.nodes[i]; i++)
                        if(node.toString())
                            node.toSVGName(svg, g);
                }
                svg.documentElement.appendChild(g);
                return svg;
            },
            toSVGURL: function() {
                return 'data:image/svg+xml;base64,' + btoa(new XMLSerializer().serializeToString(this.toSVG()));
            },
            fromXML: function(xml) {
                if(xml) {
                    this.empty();
                    var metadata, nodes, temporalization = 'mono';
                    nodes = xml.getElementsByTagName('metadata');
                    if(nodes)
                        for(i = 0; i < nodes.length; i++) {
                            if(nodes[i].getAttribute('temporalization')) {
                                temporalization = nodes[i].getAttribute('temporalization')
                                break;
                            }
                        }
                    Settings.setTemporalization(temporalization);
                    var selector = document.getElementById('temporalization');
                    if(selector.value != temporalization)
                        selector.value = temporalization;
                    var i;
                    // the order in which we add these are important (attributes create edges to anchors)
                    var knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addNode(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addNode(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addNode(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addNode(Tie.prototype.fromXML(ties[i]));
                    // implode nodes
                    var node, allNodes = [];
                    for(i = 0; node = this.nodes[i]; i++) {
                        if(node.imploded) {
                            node.imploded = false;
                            allNodes.push(node);
                        }
                    }
                    this.explode(allNodes, false);
                    this.refresh();
                }
            },
            erase: function(nodes) {
                var i, j, node, edge, affectedNodes = [], affectedEdges = [];
                for(i = 0; node = nodes[i]; i++) {
                    if(node instanceof Edge && affectedEdges.indexOf(node) < 0)
                        affectedEdges.push(node);
                    else if (node instanceof Anchor && affectedNodes.indexOf(node) < 0) {
                        affectedNodes.push(node);
                        for(j = 0; edge = node.edges[j]; j++) {
                            if(affectedEdges.indexOf(edge) < 0)
                                affectedEdges.push(edge);
                            var otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                            if(otherNode instanceof Attribute && affectedNodes.indexOf(otherNode) < 0)
                                affectedNodes.push(otherNode);
                        }
                    }
                    else if ((node instanceof Tie || node instanceof Attribute || node instanceof Knot) &&
                            affectedNodes.indexOf(node) < 0) {
                        affectedNodes.push(node);
                        for(j = 0; edge = node.edges[j]; j++) {
                            if(affectedEdges.indexOf(edge) < 0)
                                affectedEdges.push(edge);
                        }
                    }
                }
                // check for ties in violation
                var otherNode;
                for(i = 0; node = this.nodes[i]; i++) {
                    if(node instanceof Tie) {
                        var anchors = 0;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                            if(affectedNodes.indexOf(otherNode) < 0 && affectedEdges.indexOf(edge) < 0)
                                if(otherNode instanceof Anchor)
                                    anchors++;
                        }
                        if(anchors < 2 && affectedNodes.indexOf(node) < 0) {
                            affectedNodes.push(node);
                            for(j = 0; edge = node.edges[j]; j++) {
                                if(affectedEdges.indexOf(edge) < 0)
                                    affectedEdges.push(edge);
                            }
                        }
                    }
                }
                // check for dangling knots
                for(i = 0; node = this.nodes[i]; i++) {
                    if(node instanceof Knot) {
                        var dangling = true;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                            if(affectedNodes.indexOf(otherNode) < 0)
                                dangling = false;
                        }
                        if(dangling) {
                            affectedNodes.push(node);
                            for(j = 0; edge = node.edges[j]; j++) {
                                if(affectedEdges.indexOf(edge) < 0)
                                    affectedEdges.push(edge);
                            }
                        }
                    }
                }
                if(confirm("Are you sure you want to delete the following?\n-- " +
                        affectedNodes.length + " nodes (listed below) and " +
                        affectedEdges.length + " edges --\n" + affectedNodes.join('\n'))) {
                    for(i = 0; node = affectedNodes[i]; i++)
                        this.removeNode(node);
                    for(i = 0; edge = affectedEdges[i]; i++)
                        this.removeEdge(edge);
                    this.recordState();
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.start(true);
                }
            },
            connect: function(nodes) {
                var anchor, attribute, tie, knot;
                for(var i = 0; i < nodes.length; i++) {
                    if(nodes[i] instanceof Anchor)
                        anchor = nodes[i];
                    else if(nodes[i] instanceof Attribute)
                        attribute = nodes[i];
                    else if(nodes[i] instanceof Tie)
                        tie = nodes[i];
                    else if(nodes[i] instanceof Knot)
                        knot = nodes[i];
                }
                if(anchor && tie) {
                    this.addEdge(new Edge(tie, anchor, false));
                }
                else if (attribute && knot) {
                    attribute.setKnotted(true);
                    this.addEdge(new Edge(attribute, knot, false));
                }
                else if (tie && knot) {
                    tie.setKnotted(true);
                    this.addEdge(new Edge(tie, knot, false));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleKnotted: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot, edge;
                    if(nodes[i].getKnotted()) {
                        for(var j = 0; edge = nodes[i].edges[j]; j++) {
                            if(edge.otherNode instanceof Knot) {
                                if(edge.otherNode.edges.length == 1) {
                                    if(!confirm("This will also delete the knot: " + edge.otherNode +
                                            ".\nDo you still want to un-knot the attribute?"))
                                        break;
                                }
                                this.removeNode(edge.otherNode);
                                this.removeEdge(edge);
                                if(edge.otherNode.dataRange)
                                    nodes[i].dataRange = edge.otherNode.dataRange;
                                nodes[i].setKnotted(false);
                            }
                        }
                    }
                    else {
                        knot = new Knot(nodes[i].xPosition +
                                2 * LayoutEngine.normalDistance, nodes[i].yPosition -
                                2 * LayoutEngine.normalDistance);
                        if(nodes[i].dataRange)
                            knot.dataRange = nodes[i].dataRange;
                        this.addNode(knot);
                        this.addEdge(new Edge(nodes[i], knot, true));
                        nodes[i].setKnotted(true);
                    }
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleHistorized: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    nodes[i].setHistorized(!nodes[i].getHistorized());
                    if(nodes[i] instanceof Tie)
                        nodes[i].checkIdentifiers();
                }
                this.recordState();
                DrawingEngine.start(false);
            },
            toggleIdentifier: function(nodes) {
                var ties = [];
                for(var i = 0; i < nodes.length; i++) {
                    if(nodes[i] instanceof Edge) {
                        nodes[i].identifier = !nodes[i].identifier;
                        if(nodes[i].node instanceof Tie && ties.indexOf(nodes[i].node) < 0)
                            ties.push(nodes[i].node);
                        if(nodes[i].otherNode instanceof Tie && ties.indexOf(nodes[i].otherNode) < 0)
                            ties.push(nodes[i].otherNode);
                    }
                }
                for(i = 0; i < ties.length; i++)
                    ties[i].checkIdentifiers();
                this.recordState();
                DrawingEngine.start(false);
            },
            makeFirstRole: function(nodes) {
                var tie;
                for(var i = 0; i < nodes.length; i++) {
                    if(nodes[i] instanceof Edge) {
                        if(tie = nodes[i].node instanceof Tie ? nodes[i].node :
                                nodes[i].otherNode instanceof Tie ? nodes[i].otherNode : null) {
                            tie.setFirstRole(nodes[i]);
                        }
                    }
                }
                this.recordState();
                DrawingEngine.start(false);
            },
            addAttribute: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var attribute = new Attribute(nodes[i].xPosition + 2 * LayoutEngine.normalDistance,
                            nodes[i].yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(attribute);
                    this.addEdge(new Edge(attribute, nodes[i], true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTie: function(nodes) {
                var tie;
                // multiple anchors selected
                if(nodes.length > 1) {
                    var i, xAverage = 0, yAverage = 0;
                    for(i = 0; i < nodes.length; i++) {
                        xAverage += nodes[i].xPosition;
                        yAverage += nodes[i].yPosition;
                    }
                    xAverage /= nodes.length;
                    yAverage /= nodes.length;
                    tie = new Tie(xAverage, yAverage, false);
                    this.addNode(tie);
                    for(i = 0; i < nodes.length; i++)
                        this.addEdge(new Edge(tie, nodes[i], true));
                }
                // single anchor selected
                else {
                    var anchor = nodes[0];
                    tie = new Tie(anchor.xPosition +
                            2 * LayoutEngine.normalDistance, anchor.yPosition -
                            3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    var edge = new Edge(tie, anchor, true);
                    this.addEdge(edge);
                    edge = new Edge(tie, anchor, true);
                    this.addEdge(edge);
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var anchor = new Anchor(nodes[i].xPosition +
                            2 * LayoutEngine.normalDistance, nodes[i].yPosition -
                            3 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    this.addEdge(new Edge(nodes[i], anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTieAndAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var tie = new Tie(nodes[i].xPosition +
                            2 * LayoutEngine.normalDistance, nodes[i].yPosition -
                            3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    var edge = new Edge(tie, nodes[i], true);
                    this.addEdge(edge);
                    var anchor = new Anchor(nodes[i].xPosition +
                            4 * LayoutEngine.normalDistance, nodes[i].yPosition -
                            6 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    edge = new Edge(tie, anchor, true);
                    this.addEdge(edge);
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addKnot: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot = new Knot(nodes[i].xPosition +
                            2 * LayoutEngine.normalDistance, nodes[i].yPosition -
                            3 * LayoutEngine.normalDistance);
                    this.addNode(knot);
                    this.addEdge(new Edge(nodes[i], knot, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            /*
            switchEdgeNodes: function(oldNode, newNode) {
                if(oldNode == Model.topmostNode)
                    Model.topmostNode = newNode;
                if(oldNode == Model.bottommostNode)
                    Model.bottommostNode = newNode;
                if(oldNode == Model.leftmostNode)
                    Model.leftmostNode = newNode;
                if(oldNode == Model.rightmostNode)
                    Model.rightmostNode = newNode;
            },
            */
            explode: function(nodes, startEngine) {
                var node, i, j, k, edge, otherNode, knot, knotEdge, visibleEdges;
                for(i = 0; node = nodes[i]; i++) {
                    if(node instanceof Anchor) {
                        if(node.imploded) {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node == node ? edge.otherNode : edge.node;
                                if(otherNode instanceof Attribute) {
                                    if(otherNode.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node == otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot instanceof Knot) {
                                                break;
                                            }
                                        }
                                        if(!knot.visible) {
                                            knot.xPosition = node.xPosition + j + 1;
                                            knot.yPosition = node.yPosition + j + 1;
                                            knot.start();
                                            knot.setFixed(false);
                                            knot.visible = true;
                                        }
                                        knotEdge.start();
                                        knotEdge.visible = true;
                                    }
                                    otherNode.xPosition = node.xPosition + j + 2;
                                    otherNode.yPosition = node.yPosition + j + 2;
                                    otherNode.start();
                                    otherNode.setFixed(false);
                                    otherNode.visible = true;
                                    edge.start();
                                    edge.visible = true;
                                }
                            }
                        }
                        else {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node == node ? edge.otherNode : edge.node;
                                if(otherNode instanceof Attribute) {
                                    if(otherNode.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node == otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot instanceof Knot) {
                                                break;
                                            }
                                        }
                                        knotEdge.visible = false;
                                        visibleEdges = 0;
                                        for(k = 0; knotEdge = knot.edges[k]; k++)
                                            if(knotEdge.visible)
                                                visibleEdges++;
                                        if(visibleEdges == 0) {
                                            //this.switchEdgeNodes(knot, node);
                                            knot.visible = false;
                                        }
                                    }
                                    //this.switchEdgeNodes(otherNode, node);
                                    otherNode.visible = false;
                                    edge.visible = false;
                                }
                            }
                        }
                        node.setImploded(!node.imploded);
                    }
                    else if(node instanceof Tie) {
                        if(node.imploded) {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node == node ? edge.otherNode : edge.node;
                                if(otherNode instanceof Knot) {
                                    if(!otherNode.visible) {
                                        otherNode.xPosition = node.xPosition + j + 1;
                                        otherNode.yPosition = node.yPosition + j + 1;
                                        otherNode.start();
                                        otherNode.setFixed(false);
                                        otherNode.visible = true;
                                    }
                                    edge.start();
                                    edge.visible = true;
                                }
                            }
                        }
                        else {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node == node ? edge.otherNode : edge.node;
                                if(otherNode instanceof Knot) {
                                    edge.visible = false;
                                    visibleEdges = 0;
                                    for(k = 0; knotEdge = otherNode.edges[k]; k++)
                                        if(knotEdge.visible)
                                            visibleEdges++;
                                    if(visibleEdges == 0) {
                                        // this.switchEdgeNodes(otherNode, node);
                                        otherNode.visible = false;
                                    }
                                }
                            }
                        }
                        node.setImploded(!node.imploded);
                    }
                }
                this.refresh();
                if(startEngine == null || startEngine)
                    DrawingEngine.start(true);
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            initialized: false,
            canvas: null,
            shadowCanvas: null,
            miniatureCanvas: null,
            context: null,
            shadowContext: null,
            miniatureContext: null,
            running: false,
            xyScale: 1,
            xTranslation: 0,
            yTranslation: 0,
            xVisible: 0,
            yVisible: 0,
            widthVisible: 0,
            heightVisible: 0,
            miniScale: 0.2, // one fifth of the large canvas
            miniPadding: 50,
            miniWidth: 0,
            miniHeight: 0,
            miniCounter: 0,
            miniature: null,
            showNames: false,
            drawShadows: false,
            drawCurves: true,
            newState: true,
            miniatureFramesBetweenRefresh: 50,
            layout: false,
            init: function(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext) {
                var requestAnimationFrame =
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        window.oRequestAnimationFrame;
                window.requestAnimationFrame = requestAnimationFrame;
                if(!window.requestAnimationFrame) {
                    window.requestAnimationFrame = function(callback, canvas) {
                        return setTimeout(callback, 10);
                    }
                }
                var cancelRequestAnimationFrame =
                        window.cancelRequestAnimationFrame ||
                        window.webkitCancelRequestAnimationFrame ||
                        window.mozCancelRequestAnimationFrame ||
                        window.msCancelRequestAnimationFrame ||
                        window.oCancelRequestAnimationFrame;
                window.cancelRequestAnimationFrame = cancelRequestAnimationFrame;
                if(!window.cancelRequestAnimationFrame) {
                    window.cancelRequestAnimationFrame = function(id) {
                        return clearTimeout(id);
                    }
                }
                this.canvas = canvas;
                this.shadowCanvas = shadowCanvas;
                this.miniatureCanvas = miniatureCanvas;
                this.context = context;
                this.shadowContext = shadowContext;
                this.miniatureContext = miniatureContext;
                this.context.font = '10px sans-serif';
                this.viewport = document.createElementNS(SVGNS, 'rect');
                this.viewport.setAttributeNS(null, 'id', 'viewport');
                this.viewport.setAttributeNS(null, 'x', SVG.viewBox.baseVal.x);
                this.viewport.setAttributeNS(null, 'y', SVG.viewBox.baseVal.y);
                this.viewport.setAttributeNS(null, 'width', SVG.viewBox.baseVal.width);
                this.viewport.setAttributeNS(null, 'height', SVG.viewBox.baseVal.height);
                this.viewport.setAttributeNS(null, 'style', 'stroke: red; stroke-width: 2px; fill: none;');
                this.initialized = true;
                this.refreshViewportCoordinates();
            },
            storeSettings: function(storage) {
                storage.setItem("xyScale", this.xyScale);
                storage.setItem("xTranslation", this.xTranslation);
                storage.setItem("yTranslation", this.yTranslation);
            },
            loadSettings: function(storage) {
                this.xyScale = 1 * storage.getItem("xyScale") || 1;
                this.xTranslation = 1 * storage.getItem("xTranslation") || 0;
                this.yTranslation = 1 * storage.getItem("yTranslation") || 0;
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            reset: function() {
                this.xyScale = 1;
                this.xTranslation = 0;
                this.yTranslation = 0;
                this.miniScale = 0.2;
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            scale: function(scale) {
                this.xyScale *= scale;
                this.context.scale(scale, scale);
                this.shadowContext.scale(scale, scale);
                this.refreshViewportCoordinates();
            },
            translate: function(x, y) {
                this.xTranslation += x * this.xyScale;
                this.yTranslation += y * this.xyScale;
                this.context.translate(x, y);
                this.shadowContext.translate(x, y);
                this.refreshViewportCoordinates();
            },
            refreshViewportCoordinates: function() {
                if(this.initialized) {
                    this.xVisible = -this.xTranslation/this.xyScale;
                    this.yVisible = -this.yTranslation/this.xyScale;
                    this.widthVisible = this.canvas.width/this.xyScale;
                    this.heightVisible = this.canvas.height/this.xyScale;
                }
            },
            xContext: function(xScreen) {
                return (xScreen - this.xTranslation) / this.xyScale;
            },
            yContext: function(yScreen) {
                return (yScreen - this.yTranslation) / this.xyScale;
            },
            xScreen: function(xContext) {
                return xContext * this.xyScale + this.xTranslation;
            },
            yScreen: function(yContext) {
                return yContext * this.xyScale + this.yTranslation;
            },
            setCursor: function(cursor) {
                this.canvas.style.cursor = cursor;
            },
            getNodeAt: function(x, y) {
                // clear the shadow context
                this.shadowContext.fillStyle = Color.scheme.shadowBackground;
                this.shadowContext.fillRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);

                var i, node;
                // draw all visible nodes on the shadow context
                for(i = 0; node = Model.visibleNodes[i]; i++)
                    node.drawShadow(this.shadowContext);

                var data = this.shadowContext.getImageData(x, y, 1, 1).data;
                return Model.getNodeFromShadow(UniqueColor.formatColor(data[0], data[1], data[2]));
            },
            start: function(layoutModel) {
                if(this.initialized) {
                    this.layout = layoutModel;
                    this.invalidateMiniature();
                    if(!this.running) {
                        this.running = true;
                        this.drawId = window.requestAnimationFrame(DrawingEngine.engine, DrawingEngine.canvas);
                        if(this.layout)
                            ControlButtons.setPauseState();
                    }
                }
            },
            stop: function() {
                if(this.running) {
                    window.cancelRequestAnimationFrame(this.drawId);
                    this.running = false;
                    ControlButtons.setPlayState();
                }
            },
            engine: function() {
                // layout nodes
                if(DrawingEngine.layout || !LayoutEngine.equilibrium) {
                    LayoutEngine.layout(Model);
                    DrawingEngine.newState = true;
                }
                DrawingEngine.draw();
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    DrawingEngine.stop();
                    DrawingEngine.invalidateMiniature();
                    if(DrawingEngine.newState) {
                        DrawingEngine.newState = false;
                        Model.recordState();
                    }
                    DrawingEngine.layout = false;
                    ControlButtons.setPlayState();
                }
                else if(DrawingEngine.running) {
                    window.requestAnimationFrame(DrawingEngine.engine, DrawingEngine.canvas);
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            draw: function() {
                // clear the visible context
                //this.context.clearRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);

                if(DEBUG) {
                    var partition;
                    for(var key in LayoutEngine.partitions) {
                        partition =  LayoutEngine.partitions[key];
                        this.context.lineWidth = 5;
                        this.context.strokeStyle = Color.scheme.partitionOutline;
                        this.context.strokeRect(
                                partition.xMin - LayoutEngine.fuzz,
                                partition.yMin - LayoutEngine.fuzz,
                                partition.xMax - partition.xMin + 2 * LayoutEngine.fuzz,
                                partition.yMax - partition.yMin + 2 * LayoutEngine.fuzz
                        );
                        this.context.fillStyle = Color.scheme.partitionForceEndpoint;
                        this.context.fillRect(partition.xPosition + LayoutEngine.normalDistance * partition.xVelocity - 5,
                                partition.yPosition + LayoutEngine.normalDistance * partition.yVelocity - 5, 10, 10);
                        this.context.beginPath();
                        this.context.moveTo(partition.xPosition, partition.yPosition);
                        // draw an exaggerated velocity vector
                        this.context.lineTo(partition.xPosition + LayoutEngine.normalDistance * partition.xVelocity,
                                partition.yPosition + LayoutEngine.normalDistance * partition.yVelocity);
                        this.context.strokeStyle = Color.scheme.partitionForceVector;
                        this.context.lineWidth = 0.5;
                        this.context.stroke();
                    }
                }

                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % this.miniatureFramesBetweenRefresh;
                var i, node;
                i = Model.visibleNodes.length;
                while(i--) {
                    node = Model.visibleNodes[i];
                    node.draw(node.svg);
                    if(this.miniCounter === 1)
                        node.draw(node.nav);
                    if(this.showNames)
                        node.drawName(node.svg);
                }
                if(this.miniCounter === 1)
                    this.updateMiniature();
            },
            viewport: null,
            screenCircumference: 0,
            updateMiniature: function() {
                if(!NAVLayer.viewport.contains(this.viewport))
                    NAVLayer.viewport.appendChild(this.viewport);
                this.viewport.x.baseVal.value = SVG.viewBox.baseVal.x;
                this.viewport.y.baseVal.value = SVG.viewBox.baseVal.y;
                this.viewport.width.baseVal.value = SVG.viewBox.baseVal.width || window.innerWidth;
                this.viewport.height.baseVal.value = SVG.viewBox.baseVal.height || window.innerHeight;
                var nodeBox = NAV.getElementById('nodes').getBBox();
                var pad = 50;
                var width = nodeBox.width + 2 * pad;
                var height = nodeBox.height + 2 * pad;
                var screenCircumference = window.innerWidth + window.innerHeight;
                var viewportCircumference = width + height;
                var scale;
                if(viewportCircumference < screenCircumference/6) {
                    scale = screenCircumference/6/viewportCircumference;
                    width *= scale;
                    height *= scale;
                }
                else if(viewportCircumference > screenCircumference/4) {
                    scale = screenCircumference/4/viewportCircumference;
                    height *= scale;
                    width *= scale;
                }
                NAV.style.width = width + 'px';
                NAV.style.height = height + 'px';
                NAV.viewBox.baseVal.x = nodeBox.x - pad;
                NAV.viewBox.baseVal.y = nodeBox.y - pad;
                NAV.viewBox.baseVal.width = nodeBox.width + 2 * pad;
                NAV.viewBox.baseVal.height = nodeBox.height + 2 * pad;
            }
        };

        var CanvasEventHandler = {
            dragging: false,
            hasMoved: false,
            contextMenu: null,
            focusedNode: null,
            xLastKnown: 0,
            yLastKnown: 0,
            hoveringPrepared: false,
            hoveringId: null,
            hoveredNode: null,
            selectedNodes: [],
            keyboardShortcuts: true,
            disableKeyboardShortcuts: function() {
                this.keyboardShortcuts = false;
            },
            enableKeyboardShortcuts: function() {
                this.keyboardShortcuts = true;
            },
            mousedown: function(event) {
                if(this.focusedNode = DrawingEngine.getNodeAt(event.xScreen, event.yScreen)) {
                    if(event.shiftKey) {
                        if(this.selectedNodes.indexOf(this.focusedNode) >= 0)
                            this.removeNodeFromSelection(this.focusedNode);
                        else
                            this.addNodeToSelection(this.focusedNode);
                    }
                }
                else if(event.shiftKey) {
                    // we are shift clicking the canvas background
                    this.clearSelection();
                }
                this.dragging = true;
                return false;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    this.hasMoved = true;
                    // if we are dragging a node, we must also be hovering over it
                    if(this.focusedNode) {
                        if(this.focusedNode.isInteractive()) {
                            this.focusedNode.xPosition = DrawingEngine.xContext(event.xScreen);
                            this.focusedNode.yPosition = DrawingEngine.yContext(event.yScreen);
                            this.focusedNode.setFixed(true);
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;
                            }
                            Model.invalidateNode(this.focusedNode);
                            DrawingEngine.start(true);
                        }
                    }
                    // if the dragging started over an empty part of the canvas
                    else {
                        DrawingEngine.setCursor('move');
                        DrawingEngine.translate((event.xScreen - this.xLastKnown)/DrawingEngine.xyScale,
                                (event.yScreen - this.yLastKnown)/DrawingEngine.xyScale);
                        DrawingEngine.start(false);
                    }
                }
                else {
                    // we are hovering, but not dragging
                    if(this.hoveredNode) {
                        var mouse = {
                            xPosition: DrawingEngine.xContext(event.xScreen),
                            yPosition: DrawingEngine.yContext(event.yScreen)
                        };
                        if(LayoutEngine.manhattanDistance(this.hoveredNode, mouse) >
                                1.5 * LayoutEngine.normalDistance) {
                            DrawingEngine.setCursor('default');
                            this.hoveredNode = null;
                            this.hoveringPrepared = false;
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;
                            }
                            DrawingEngine.start(false);
                        }
                    }
                    // if we are not hovering, set up a check in half a second
                    else if (!this.hoveringPrepared) {
                        this.hoveringPrepared = true;
                        this.hoveringId = setTimeout(function(self) { self.mousehover(event); }, 500, this);
                    }
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
                return false;
            },
            mousehover: function(event) {
                // mouse pointer over node
                if(this.hoveredNode = DrawingEngine.getNodeAt(this.xLastKnown, this.yLastKnown)) {
                    if(this.contextMenu == null)
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    else if (this.contextMenu.collapsed) {
                        this.contextMenu.close();
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    }
                    DrawingEngine.setCursor('pointer');
                    DrawingEngine.start(false);
                }
                // mouse pointer not over node, trigger a new check
                else {
                    this.hoveringPrepared = false;
                }
                return false;
            },
            closeContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;
                }
            },
            keypress: function(event) {
                if(this.keyboardShortcuts) {
                    if(this.hoveredNode || this.selectedNodes.length > 0) {
                        var allNodes = this.selectedNodes.slice(0);
                        if(this.hoveredNode && allNodes.indexOf(this.hoveredNode) < 0)
                            allNodes.push(this.hoveredNode);
                        switch(String.fromCharCode(event.which)) {
                            case "e":
                                if(!this.contextMenu)
                                    this.contextMenu = new ContextMenu(allNodes[0], this.selectedNodes);
                                this.contextMenu.toggle();
                                break;
                            case "a":
                                if(Operations.isSupported("addAttribute", allNodes))
                                    Model.addAttribute(allNodes);
                                else if(Operations.isSupported("addAnchor", allNodes))
                                    Model.addAnchor(allNodes);
                                break;
                            case "t":
                                if(Operations.isSupported("addTie", allNodes) && this.selectedNodes.length > 0)
                                    Model.addTie(allNodes);
                                else if(Operations.isSupported("addTieAndAnchor", allNodes))
                                    Model.addTieAndAnchor(allNodes);
                                break;
                            case "c":
                                if(Operations.isSupported("connect", allNodes)) {
                                    var i, operation, validator;
                                    for(i = 0; operation = Operations.list[i]; i++)
                                        if(operation[0] == "connect")
                                            validator = operation[3];
                                    if(validator(allNodes))
                                        Model.connect(allNodes);
                                }
                                break;
                            case "h":
                                if(Operations.isSupported("toggleHistorized", allNodes))
                                    Model.toggleHistorized(allNodes);
                                break;
                            case "k":
                                if(Operations.isSupported("toggleKnotted", allNodes))
                                    Model.toggleKnotted(allNodes);
                                else if(Operations.isSupported("addKnot", allNodes))
                                    Model.addKnot(allNodes);
                                break;
                            case "i":
                                if(Operations.isSupported("toggleIdentifier", allNodes))
                                    Model.toggleIdentifier(allNodes);
                                break;
                            case "f":
                                if(Operations.isSupported("makeFirstRole", allNodes))
                                    Model.makeFirstRole(allNodes);
                                break;
                            case "x":
                                if(Operations.isSupported("explode", allNodes))
                                    Model.explode(allNodes);
                                break;
                            case "d":
                                if(Operations.isSupported("erase", allNodes))
                                    Model.erase(allNodes);
                                break;
                        }
                        if(event.stopPropagation)
                            event.stopPropagation();
                        if(event.preventDefault)
                            event.preventDefault();
                    }
                }
                return false;
            },
            // this is special Firefox handling
            DOMMouseScroll: function(event) {
                this.mousewheel(event);
            },
            mousewheel: function(event) {
                var zoom = 1 + ((event.detail<0 || event.wheelDelta>0) ? 1 : -1) * 0.01;
                var scale = DrawingEngine.xyScale * zoom;
                if(scale > 0.1 && scale < 10) {
                    DrawingEngine.scale(zoom);
                    DrawingEngine.translate(DrawingEngine.xContext(event.xScreen) -
                            DrawingEngine.xContext(event.xScreen) * zoom, DrawingEngine.yContext(event.yScreen) -
                            DrawingEngine.yContext(event.yScreen) * zoom);
                    DrawingEngine.start(false);
                }
                return false;
            },
            mouseup: function(event) {
                var layout = false;
                // the dragging started over a node
                if(this.focusedNode && !this.hasMoved && !event.shiftKey) {
                    this.focusedNode.setFixed(!this.focusedNode.getFixed());
                    layout = true;
                }
                this.focusedNode = null;
                this.dragging = false;
                this.hasMoved = false;
                DrawingEngine.setCursor('default');
                DrawingEngine.start(layout);
                return false;
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.CanvasEventHandler[event.type])
                    this.CanvasEventHandler[event.type](event);
            },
            addNodeToSelection: function(node) {
                if(this.selectedNodes.indexOf(node) < 0)
                    this.selectedNodes.push(node);
            },
            removeNodeFromSelection: function(node) {
                this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1);
            },
            clearSelection: function() {
                this.selectedNodes = [];
            }
        };

        var MiniatureEventHandler = {
            dragging: false,
            xLastKnown: 0,
            yLastKnown: 0,
            mousedown: function(event) {
                var xCenter = DrawingEngine.xVisible + DrawingEngine.widthVisible/2;
                var yCenter = DrawingEngine.yVisible + DrawingEngine.heightVisible/2;
                // scale down
                xCenter = xCenter * DrawingEngine.miniScale + DrawingEngine.miniScale *
                        (DrawingEngine.miniPadding - Model.leftmostNode.xPosition);
                yCenter = yCenter * DrawingEngine.miniScale + DrawingEngine.miniScale *
                        (DrawingEngine.miniPadding - Model.topmostNode.yPosition);

                var xTranslate = xCenter - event.xScreen;
                var yTranslate = yCenter - event.yScreen;
                // scale up
                xTranslate /= DrawingEngine.miniScale;
                yTranslate /= DrawingEngine.miniScale;

                DrawingEngine.translate(xTranslate, yTranslate);
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    DrawingEngine.translate(
                            (this.xLastKnown - event.xScreen)/DrawingEngine.miniScale,
                            (this.yLastKnown - event.yScreen)/DrawingEngine.miniScale
                    );
                    DrawingEngine.start(false);
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mouseup: function(event) {
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.start(false);
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.MiniatureEventHandler[event.type])
                    this.MiniatureEventHandler[event.type](event);
            }
        };


        var UniqueIdentity = {
            lastId: 0,
            usedIds: [],
            nextId: function() {
                while(this.usedIds[++this.lastId]);
                this.usedIds[this.lastId] = true;
                return this.lastId;
            },
            takeId: function(id) {
                this.usedIds[id] = true;
                return id;
            }
        };

        var Editables = {
            descriptorEdit: {
                name: 'Descriptor',
                description:
                       'Should be a descriptive name of that which you are creating. ' +
                       'An understandable description of something found in the domain ' +
                       'you are modeling, for example "CoffeeMachine".',
                setMember: function (element, node) { node.descriptor = element.value; },
                getMember: function (node) { return node.descriptor },
                setElement: function (element, node) { element.value = node.descriptor },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '(' + UPPER + LOWER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            twoMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A two letter mnemonic, that needs to be unique within the entire ' +
                       'model. If an anchor is named "CoffeeMachine" for example, then ' +
                       '"CM" is a suitable mnemonic.',
                setMember: function (element, node) { node.mnemonic = element.value; },
                getMember: function (node) { return node.mnemonic },
                setElement: function (element, node) { element.value = node.mnemonic },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: UPPER + '{2}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            threeMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A three letter mnemonic, that needs to be unique within the entire ' +
                       'model for knots, but only within the anchor for attributes. If an ' +
                       'attribute is named "Capacity" for example, then "CAP" is a ' +
                       'suitable mnemonic.',
                setMember: function (element, node) { node.mnemonic = element.value; },
                getMember: function (node) { return node.mnemonic },
                setElement: function (element, node) { element.value = node.mnemonic },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: UPPER + '{3}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                description: 'The data type of the column in the resulting implementation.',
                setMember: function (element, node) { node.dataRange = element.value; },
                getMember: function (node) { return node.dataRange },
                setElement: function (element, node) { element.value = node.dataRange },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            changingRangeEdit: {
                name: 'Time range',
                description:
                       'Changing time data type. Versions of data are stored over changing time ' +
                       'and this data type should be granular enough to handle the expected ' +
                       'update frequency.',
                setMember: function (element, node) { node.changingRange = element.value; },
                getMember: function (node) { return node.changingRange },
                setElement: function (element, node) { element.value = node.changingRange },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            identityEdit: {
                name: 'Identity',
                description:
                       'Identity data type. The identity is an abstract and immutable property ' +
                       'that uniquely identifies an entity. If you expect to store very many ' +
                       'entities you also need an appropriately large data type.',
                setMember: function (element, node) { node.identity = element.value; },
                getMember: function (node) { return node.identity },
                setElement: function (element, node) { element.value = node.identity },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            generatorEdit: {
                name: 'Generator',
                description:
                       'Identity generator. Check this if you would like the database to generate ' +
                       'identities for you through some auto incremented sequence. Uncheck if you ' +
                       'intend to manage your identities somewhere else.',
                setMember: function (element, node) { node.generator = element.checked; },
                getMember: function (node) { return node.generator },
                setElement: function (element, node) { element.checked = node.generator },
                getElement: function (element) { return element.checked },
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            restatabilityEdit: {
                name: 'Restatable',
                description:
                       'Check this if you want to allow temporal restatements. A temporal restatement ' +
                       'is when two consecutive values over changing time are identical. Uncheck this ' +
                       'to introduce a constraint preventing restatements from being made.',
                setMember: function (element, node) { node.restatable = element.checked; },
                getMember: function (node) { return node.restatable },
                setElement: function (element, node) { element.checked = node.restatable },
                getElement: function (element) { return element.checked },
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            idempotencyEdit: {
                name: 'Idempotent',
                description:
                       'Checking this modifies the insert and update triggers such that changed values ' +
                       'must be different in order to be recorded. Idempotency is not recommended when ' +
                       'data can arrive asynchronously with respect to changing time.',
                setMember: function (element, node) { node.idempotent = element.checked; },
                getMember: function (node) { return node.idempotent },
                setElement: function (element, node) { element.checked = node.idempotent },
                getElement: function (element) { return element.checked },
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            roleEdit: {
                name: 'Role',
                description:
                       'The role of the connected entity in the relationship. The same entity may, for example ' +
                       'participate more than once in the same relationship and must therefore be distinguished ' +
                       'through which role it plays. Because of this, roles must be unique within a tie.',
                setMember: function (element, node) { node.role = element.value; },
                getMember: function (node) { return node.role },
                setElement: function (element, node) { element.value = node.role },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '(' + LOWER + UPPER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            encapsulationEdit: {
                name: 'Capsule',
                description:
                       'In order to achieve separation of concerns, different parts of the model can be encapsulated ' +
                       'in different "capsules", which translate to schemas in the relational database implementation.',
                setMember: function (element, node) { node.encapsulation = element.value; },
                getMember: function (node) { return node.encapsulation },
                setElement: function (element, node) { element.value = node.encapsulation },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: LOWER + '*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            }
        };

        function AbstractNode(x, y) {
            this.xPosition = x;
            this.yPosition = y;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.velocity = 0;
            this.moving = true;
            this.fixed = false;
            this.visible = true;
            this.shadowColor = UniqueColor.reserveUniqueColor();
            this.id = UniqueIdentity.nextId();
            this.edges = [];
            this.editables = [];
            this.operations = ['erase', 'connect'];
            this.incomplete = true;
            this.svg = {
                graphicsElement: null,
                useElement: null,
                boundingBox: null,
                xOffset: null,
                yOffset: null,
                control: null,
                nameElement: null,
                nameText: null,
                highlightElement: null,
                fixationElement: null,
                pathElement: null,
                pathControl: null
            };
            this.svg.highlightElement = document.createElementNS(SVGNS, 'use');
            this.svg.highlightElement.setAttributeNS(XLINKNS, 'xlink:href', '#highlight');
            this.svg.fixationElement = document.createElementNS(SVGNS, 'use');
            this.svg.fixationElement.setAttributeNS(XLINKNS, 'xlink:href', '#fixation');
            this.nav = {
                graphicsElement: null,
                useElement: null,
                control: null,
                pathElement: null,
                pathControl: null
            };
        }
        AbstractNode.prototype = {
            description: '',
            xPosition: null,
            yPosition: null,
            xVelocity: null,
            yVelocity: null,
            velocity: null,
            edges: null,
            moving: true,
            shadowColor: Color.scheme.defaultShadowColor,
            editables: null,
            incomplete: true,
            operations: null,
            type: 'Node',
            id: null,
            fixed: false,
            visible: true,
            svg: null,
            nav: null,
            nameable: false,
            hasHighlight: false,
            lastName: '',
            setId: function(id)  {
                if(id) {
                    UniqueIdentity.takeId(id);
                    this.id = id;
                }
            },
            getId: function() {
                if (!this.id)
                    this.id = UniqueIdentity.nextId();
                return this.id;
            },
            setNameable: function(nameable) {
                if(nameable && !this.svg.nameElement) {
                    this.svg.nameElement = document.createElementNS(SVGNS, 'text');
                    this.svg.nameElement.setAttributeNS(null, 'class', 'label');
                    this.svg.nameElement.setAttributeNS(null, 'x', this.xPosition.toFixed(2));
                    this.svg.nameElement.setAttributeNS(null, 'y', this.yPosition.toFixed(2));
                    this.svg.nameText = document.createTextNode('I am a placeholder');
                    this.svg.nameElement.appendChild(this.svg.nameText);
                    SVGLayer.names.appendChild(this.svg.nameElement);
                }
                this.nameable = nameable;
            },
            updateName: function() {
                if(this.nameable) {
                    var name = this.contextualName();
                    if(name != this.lastName) {
                        this.lastName = name;
                        this.svg.nameText.nodeValue = name;
                    }
                }
            },
            // override to change behavior
            isInteractive: function() {
                return false;
            },
            // subclasses must override these
            getMass: function() {
                return null;
            },
            getCharge: function() {
                return null;
            },
            // this should always return the name according to the naming conventions
            toString: function() {
                return null;
            },
            // this should return the name depending on the visual context
            contextualName: function() {
                return this.toString();
            },
            isEmpty: function(value) {
                return typeof value == "undefined" || value == null ||
                        value.toString().replace(/^[^\S]+/,'').replace(/[^\S]+$/,'') == '';
            },
            isIncomplete: function() {
                var editable;
                for(var i = 0; editable = this.editables[i]; i++) {
                    // only those that are supposed to contain text (i.e. not checkboxes, select lists, ...)
                    if(editable.pattern) {
                        if(this.isEmpty(editable.getMember(this)))
                            return true;
                        if(!editable.getMember(this).toString().match(new RegExp('^' + editable.pattern + '$')))
                            return true;
                    }
                }
                return false;
            },
            // override in order to check conditions under which the node breaks the model
            isConforming: function() {
                return true;
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            toSVG: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addLayoutXML: function(element, schema) {
                if(!this.isEmpty(this.description)) {
                    var description = schema.createElement("description");
                    description.innerHTML = this.description;
                    element.appendChild(description);
                }
                var layout = schema.createElement("layout");
                layout.setAttribute("x", this.xPosition.toFixed(2));
                layout.setAttribute("y", this.yPosition.toFixed(2));
                layout.setAttribute("fixed", this.getFixed());
                if(this.imploded)
                    layout.setAttribute("imploded", this.imploded);
                element.appendChild(layout);
            },
            stop: function() {
                this.moving = false;
            },
            // movement is propagated to the edges of a node
            start: function() {
                this.moving = true;
                for(var i = 0; i < this.edges.length; i++)
                    this.edges[i].start();
            },
            drawName: function(context) {
                if(this.svg.nameElement) {
                    this.updateName();
                    var i, edge, xAverage = 0, closestEdge = this.edges[0];
                    i = this.edges.length;
                    while(i--) {
                        xAverage += this.edges[i].xPosition;
                        if(LayoutEngine.manhattanDistance(this, this.edges[i]) <
                           LayoutEngine.manhattanDistance(this, closestEdge)) {
                            closestEdge = this.edges[i];
                        }
                    }
                    xAverage /= this.edges.length;
                    var quarter = this.svg.yOffset + this.svg.boundingBox.height / 4;
                    var nameYOffset = this.yPosition < closestEdge.yPosition ? -quarter : quarter;
                    var nameXOffset = this.svg.xOffset + this.svg.boundingBox.width / 2;
                    if(this.xPosition < xAverage) {
                        this.svg.nameElement.classList.add('end');
                        nameXOffset = -nameXOffset;
                    }
                    else {
                        this.svg.nameElement.classList.remove('end');
                    }
                    if(this.incomplete)
                        this.svg.nameElement.classList.add('bad');
                    else
                        this.svg.nameElement.classList.remove('bad');
                    this.svg.nameElement.x.baseVal.getItem(0).value = this.xPosition + nameXOffset;
                    this.svg.nameElement.y.baseVal.getItem(0).value = this.yPosition + nameYOffset;
                }
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(context, detailLevel) {
                if(DEBUG) {
                    context.beginPath();
                    context.moveTo(this.xPosition, this.yPosition);
                    // draw an exaggerated velocity vector
                    context.lineTo(this.xPosition + LayoutEngine.normalDistance * this.xVelocity,
                            this.yPosition + LayoutEngine.normalDistance * this.yVelocity);
                    context.strokeStyle = Color.scheme.forceVector;
                    context.lineWidth = 0.5;
                    context.stroke();
                    context.fillStyle = Color.scheme.forceEndpoint;
                    context.fillRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3,
                            this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                    context.strokeRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3,
                            this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                }
            },
            // this is how a node draws itself on the shadow context
            drawShadow: function(context) {
                /*
                this.drawOutline(context);
                context.fillStyle = this.shadowColor;
                context.fill();
                */
            },
            setFixed: function(fixed) {
                this.fixed = fixed;
                if(fixed && !this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.appendChild(this.svg.fixationElement);
                }
                else if (!fixed && this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.fixationElement);
                }
            },
            getFixed: function() {
                return this.fixed;
            },
            setHighlight: function(highlight) {
                this.hasHighlight = highlight;
                if(highlight && !this.svg.graphicsElement.contains(this.highlight)) {
                    this.svg.highlightElement.addEventListener('click', EventHandler.clickHighlight, false);
                    this.svg.graphicsElement.insertBefore(
                            this.svg.highlightElement,
                            this.svg.graphicsElement.firstChild
                    );
                }
                else if (!highlight && this.svg.graphicsElement.contains(this.svg.highlightElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.highlightElement);
                    this.svg.highlightElement.removeEventListener('click', EventHandler.clickHighlight, false);
                }
            },
            contextMenu: null,
            showContextMenu: function(hovered, selection) {
                if(!this.contextMenu)
                    this.contextMenu = new ContextMenu(hovered, selection);
            },
            hideContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;
                }
            }
        };

        var EventHandler = {
            selectedNodes: [], // may be larger than interacted with SHIFT clicks
            interactedNodes: [], // currently "touched" nodes
            interaction: null,
            previousInteraction: null,
            addNodeToSelection: function(node) {
                if(this.selectedNodes.indexOf(node) < 0)
                    this.selectedNodes.push(node);
            },
            removeNodeFromSelection: function(node) {
                if(this.selectedNodes.indexOf(node) >= 0)
                    this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1);
            },
            clearSelection: function() {
                this.selectedNodes = [];
            },
            isSelected: function(node) {
                return this.selectedNodes.indexOf(node) >= 0;
            },
            setInteraction: function(interaction) {
                if(this.interaction) this.previousInteraction = this.interaction;
                this.interaction = interaction;
            },
            getInteraction: function() {
                return this.interaction;
            },
            getPreviousInteraction: function() {
                return this.previousInteraction;
            },
            addNodeToInteraction: function(node) {
                if(this.interactedNodes.indexOf(node) < 0)
                    this.interactedNodes.push(node);
            },
            removeNodeFromInteraction: function(node) {
                if(this.interactedNodes.indexOf(node) >= 0)
                    this.interactedNodes.splice(this.interactedNodes.indexOf(node), 1);
            },
            clearInteraction: function() {
                this.interactedNodes = [];
                this.setInteraction(null);
            },
            isInteracted: function(node) {
                return this.interactedNodes.indexOf(node) >= 0;
            },
            hasOngoingInteractions: function() {
                return this.interaction != null;
            },
            beginInteraction: function(event) {
                event.preventDefault();
                if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("beginInteraction");
                    var component = this.component; // note that _this_ refers to the SVG element here
                    if(!EventHandler.isInteracted(component))
                        EventHandler.addNodeToInteraction(component);
                    if(!EventHandler.isSelected(component))
                        EventHandler.addNodeToSelection(component);
                    window.addEventListener('keypress', EventHandler.keypress, false);
                    SVG.addEventListener('mouseover', EventHandler.endInteraction, false);
                    component.svg.graphicsElement.addEventListener('mousedown', EventHandler.prepareDragging, false);
                    component.svg.graphicsElement.addEventListener('click', EventHandler.clickComponent, false);
                    component.setHighlight(true);
                    component.showContextMenu(component, EventHandler.selectedNodes);
                }
                event.stopPropagation();
            },
            prepareDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "beginInteraction") {
                    EventHandler.setInteraction("prepareDragging");
                    var component, i;
                    for(i = 0; component = EventHandler.interactedNodes[i]; i++) {
                        if(event.shiftKey) {
                            if(EventHandler.isSelected(component))
                                EventHandler.removeNodeFromSelection(component);
                            else
                                EventHandler.addNodeToSelection(component);
                        }
                        component.hideContextMenu();
                        component.svg.graphicsElement.removeEventListener('mousedown', EventHandler.prepareDragging, false);
                    }
                    SVG.addEventListener('mousemove', EventHandler.whileDragging, false);
                    SVG.addEventListener('mouseup', EventHandler.completeDragging, false);
                }
                event.stopPropagation();
            },
            whileDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileDragging" ||
                   EventHandler.getInteraction() === "prepareDragging") {
                    var component, i, svgPoint;
                    for(i = 0; component = EventHandler.interactedNodes[i]; i++) {
                        if(component.isInteractive()) {
                            svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY)
                            if(EventHandler.getInteraction() === "whileDragging") {
                                component.xPosition = svgPoint.x;
                                component.yPosition = svgPoint.y;
                                component.setFixed(true);
                                component.setHighlight(false);
                                Model.invalidateNode(this);
                                DrawingEngine.start(true);
                            }
                            else if(EventHandler.getInteraction() === "prepareDragging") {
                                if(LayoutEngine.manhattanDistance(component, {
                                    xPosition: svgPoint.x,
                                    yPosition: svgPoint.y
                                }) > 10) {
                                    EventHandler.setInteraction("whileDragging");
                                }
                            } // switch behavior if we actually move the thing a fair distance
                        }
                    }
                }
                event.stopPropagation();
            },
            completeDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileDragging") {
                    EventHandler.setInteraction("completeDragging");
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whileDragging, false);
                    SVG.removeEventListener('mouseup', EventHandler.completeDragging, false);
                }
                event.stopPropagation();
            },
            clickComponent: function(event) {
                event.preventDefault();
                var component, i;
                for(i = 0; component = EventHandler.interactedNodes[i]; i++) {
                    component.svg.graphicsElement.removeEventListener('click', EventHandler.clickComponent, false);
                    if(EventHandler.getPreviousInteraction() !== "completeDragging")
                        component.setFixed(!component.getFixed());
                }
                EventHandler.clearInteraction();
                event.stopPropagation();
            },
            clickHighlight: function(event) {
                event.preventDefault();
                alert("clicked highlight");
                EventHandler.clearInteraction();
                event.stopPropagation();
            },
            endInteraction: function(event) {
                event.preventDefault();
                if(event.toElement === SVG && (
                        !EventHandler.hasOngoingInteractions() ||
                        EventHandler.getInteraction() === "beginInteraction")) {
                    var component, i;
                    for(i = 0; component = EventHandler.interactedNodes[i]; i++) {
                        if(EventHandler.isSelected(component))
                            EventHandler.removeNodeFromSelection(component);
                        component.hideContextMenu();
                        component.setHighlight(false);
                    }
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whileDragging, false);
                    SVG.removeEventListener('mouseup', EventHandler.completeDragging, false);
                    SVG.removeEventListener('mouseover', EventHandler.endInteraction, false);
                    window.removeEventListener('keypress', EventHandler.keypress, false);
                }
                event.stopPropagation();
            },
            preparePanning: function(event) {
                event.preventDefault();
                if(event.shiftKey) {
                    // we are shift clicking the canvas background
                    EventHandler.clearInteraction();
                    EventHandler.clearSelection();
                }
                else if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("preparePanning");
                    var screenWidth = SVG.width.baseVal.value;
                    var screenHeight = SVG.height.baseVal.value;
                    var viewBoxWidth = SVG.viewBox.baseVal.width || screenWidth;
                    var viewBoxHeight = SVG.viewBox.baseVal.height || screenHeight;
                    SVG.viewBox.baseVal.width = viewBoxWidth;
                    SVG.viewBox.baseVal.height = viewBoxHeight;
                    EventHandler.scaleX = viewBoxWidth / screenWidth;
                    EventHandler.scaleY = viewBoxHeight / screenHeight;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                    SVG.addEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.addEventListener('mouseup', EventHandler.completePanning, false);
                }
                event.stopPropagation();
            },
            lastX: null,
            lastY: null,
            scaleX: null,
            scaleY: null,
            whilePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning" ||
                   EventHandler.getInteraction() === "preparePanning") {
                    EventHandler.setInteraction("whilePanning");
                    SVG.viewBox.baseVal.x -= (event.clientX - EventHandler.lastX) * EventHandler.scaleX;
                    SVG.viewBox.baseVal.y -= (event.clientY - EventHandler.lastY) * EventHandler.scaleY;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                }
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            completePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning") {
                    EventHandler.setInteraction("completePanning");
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.removeEventListener('mouseup', EventHandler.completePanning, false);
                }
                event.stopPropagation();
            },
            scaling: 0.03,
            zoom: function(event) {
                event.preventDefault();
                var zoom = 1 + ((event.detail<0 || event.wheelDelta>0) ? 1 : -1) * EventHandler.scaling;
                var width = SVG.viewBox.baseVal.width || SVG.width.baseVal.value;
                var height = SVG.viewBox.baseVal.height || SVG.height.baseVal.value;
                var x = SVG.viewBox.baseVal.x;
                var y = SVG.viewBox.baseVal.y;
                var svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY);
                SVG.viewBox.baseVal.width = width * zoom;
                SVG.viewBox.baseVal.height = height * zoom;
                SVG.viewBox.baseVal.x = x + (1 - zoom) * (svgPoint.x - x);
                SVG.viewBox.baseVal.y = y + (1 - zoom) * (svgPoint.y - y);
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            screenToSVG: function(x, y) {
                var screenPoint = SVG.createSVGPoint();
                screenPoint.x = x;
                screenPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return screenPoint.matrixTransform( matrix.inverse() );
            },
            svgToScreen: function(x, y) {
                var svgPoint = SVG.createSVGPoint();
                svgPoint.x = x;
                svgPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return svgPoint.matrixTransform( matrix );
            },
            keypress: function(event) {
                if(this.selectedNodes.length > 0) {
                    var allNodes = this.selectedNodes.slice(0);
                    switch(String.fromCharCode(event.which)) {
                        case "e":
                            if(!this.contextMenu)
                                this.contextMenu = new ContextMenu(allNodes[0], this.selectedNodes);
                            this.contextMenu.toggle();
                            break;
                        case "a":
                            if(Operations.isSupported("addAttribute", allNodes))
                                Model.addAttribute(allNodes);
                            else if(Operations.isSupported("addAnchor", allNodes))
                                Model.addAnchor(allNodes);
                            break;
                        case "t":
                            if(Operations.isSupported("addTie", allNodes) && this.selectedNodes.length > 0)
                                Model.addTie(allNodes);
                            else if(Operations.isSupported("addTieAndAnchor", allNodes))
                                Model.addTieAndAnchor(allNodes);
                            break;
                        case "c":
                            if(Operations.isSupported("connect", allNodes)) {
                                var i, operation, validator;
                                for(i = 0; operation = Operations.list[i]; i++)
                                    if(operation[0] == "connect")
                                        validator = operation[3];
                                if(validator(allNodes))
                                    Model.connect(allNodes);
                            }
                            break;
                        case "h":
                            if(Operations.isSupported("toggleHistorized", allNodes))
                                Model.toggleHistorized(allNodes);
                            break;
                        case "k":
                            if(Operations.isSupported("toggleKnotted", allNodes))
                                Model.toggleKnotted(allNodes);
                            else if(Operations.isSupported("addKnot", allNodes))
                                Model.addKnot(allNodes);
                            break;
                        case "i":
                            if(Operations.isSupported("toggleIdentifier", allNodes))
                                Model.toggleIdentifier(allNodes);
                            break;
                        case "f":
                            if(Operations.isSupported("makeFirstRole", allNodes))
                                Model.makeFirstRole(allNodes);
                            break;
                        case "x":
                            if(Operations.isSupported("explode", allNodes))
                                Model.explode(allNodes);
                            break;
                        case "d":
                            if(Operations.isSupported("erase", allNodes))
                                Model.erase(allNodes);
                            break;
                    }
                    if(event.stopPropagation)
                        event.stopPropagation();
                    if(event.preventDefault)
                        event.preventDefault();
                }
            }
        };

        function Layer(graph) {
            this.graph = graph;
        }
        Layer.prototype = {
            graph: null,
            layers: [],
            addLayer: function(name) {
                var layer = document.createElementNS(SVGNS, 'g');
                layer.setAttributeNS(null, 'id', name);
                this.graph.appendChild(layer);
                this.layers.push(name);
                this[name] = layer;
            },
            show: function(name) {
                var i = this.layers.indexOf(name) + 1;
                if(i < this.layers.length) {
                    var after = this.layers[i];
                    this.graph.insertBefore(this[name], this[after]);
                }
                else {
                    this.graph.appendChild(this[name]);
                }
            },
            hide: function(name) {
                if(this.graph.contains(this[name]))
                    this.graph.removeChild(this[name]);
            }
       }

        function Attribute(x, y, historized) {
            // call the parent constructor
            AbstractNode.call(this, x, y);
            // set static variables
            Attribute.mass = 1;
            Attribute.charge = 1;
            // set members
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.knotted = false;
            this.historized = historized;
            this.restatable = Defaults.restatability == 'true';
            this.idempotent = Defaults.idempotency == 'true';
            this.encapsulation = Defaults.encapsulation;
            this.operations.push('toggleKnotted','toggleHistorized');
            this.type = 'Attribute';
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            // expando property as a reference back to the underlying component for use in event handlers
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#attribute_historized' : '#attribute';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 5;
            this.svg.yOffset = 2;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
        }
        Attribute.prototype = {
            mnemonic: '',
            descriptor: '',
            dataRange: '',
            changingRange: '',
            historized: false,
            restatable: true,
            idempotent: false,
            knotted: false,
            encapsulation: Defaults.encapsulation,
            getMass: function() {
                return Attribute.mass;
            },
            getCharge: function() {
                return Attribute.charge;
            },
            isInteractive: function() {
                return true;
            },
            isConforming: function() {
                var i, edge, anchor, otherNode;
                // first find the anchor
                for(i = 0; edge = this.edges[i]; i++) {
                    otherNode = (edge.node == this ? edge.otherNode : edge.node);
                    if(otherNode instanceof Anchor) {
                        anchor = otherNode;
                        break;
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; edge = anchor.edges[i]; i++) {
                    otherNode = (edge.node == anchor ? edge.otherNode : edge.node);
                    if(otherNode instanceof Attribute && otherNode != this && otherNode.mnemonic == this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other attributes on the '" + anchor +
                                "' anchor. Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) {
                    this.editables.push(Editables.restatabilityEdit);
                    this.editables.push(Editables.idempotencyEdit);
                }
                else if (!historized && index >= 0)
                    this.editables.splice(index, 2);
                if(this.changingRange == '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#attribute_historized' : '#attribute';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                var index = this.editables.indexOf(Editables.dataRangeEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.dataRangeEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var metadata;
                var capsule = Defaults.encapsulation;
                var restatable = Defaults.restatability == 'true';
                var idempotent = Defaults.idempotency == 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    restatable = metadata.getAttribute("restatable") == 'false' ? false :
                            metadata.getAttribute("restatements") == 'false' ? false :
                                    restatable;
                    idempotent = metadata.getAttribute("idempotent") == 'true' || idempotent;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || '???';
                var descriptor = element.getAttribute("descriptor") || '!Unnamed!';
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || '';
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || '';
                var parent = element.parentNode;
                var attribute = new Attribute(x, y, historized);
                attribute.setFixed(fixed);
                attribute.setKnotted(knotted);
                attribute.setHistorized(historized);
                attribute.changingRange = changingRange;
                attribute.dataRange = dataRange;
                attribute.description = description ? description.firstChild.nodeValue : '';
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                attribute.encapsulation = capsule;
                attribute.restatable = restatable;
                attribute.idempotent = idempotent;
                var anchorLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Anchor)
                        anchorLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var knotLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Knot)
                        knotLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var anchor = anchorLookup[parent.getAttribute("mnemonic")];
                Model.addEdge(new Edge(attribute, anchor, true));
                if(knotted) {
                    var grandparent = parent.parentNode;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(i = 0; i < knots.length; i++) {
                        if(knots[i].getAttribute("mnemonic") == knotRange) {
                            var knot = knotLookup[knots[i].getAttribute("mnemonic")];
                            Model.addEdge(new Edge(attribute, knot, false));
                            break; // only one should match
                        }
                    }
                }
                attribute.incomplete = attribute.isIncomplete();
                attribute.updateName();
                return attribute;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                attribute.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.edges[i]; i++)
                        if(edge.otherNode instanceof Knot)
                            knot = edge.otherNode;
                    attribute.setAttribute("knotRange", this.isEmpty(knot.mnemonic) ? '' : knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);
                }
                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability == 'true' : this.restatable);
                    metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                            Defaults.idempotency == 'true' : this.idempotent);
                }
                attribute.appendChild(metadata);
                this.addLayoutXML(attribute, schema);
                element.appendChild(attribute);
            },
            contextualName: function() {
                var name = '';
                if(Settings.showMnemonics)
                    name += this.toString();
                else
                    name += this.descriptor;
                if(this.historized && (this.restatable || this.idempotent)) {
                    name += ' (';
                    if(this.restatable)
                        name += 'r';
                    if(this.idempotent)
                        name += 'i';
                    name += ')';
                }
                return name;
            },
            toString: function() {
                var anchor, edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.otherNode instanceof Anchor)
                        anchor = edge.otherNode;
                return anchor.mnemonic + "_" + this.mnemonic + "_" + anchor.descriptor + "_" + this.descriptor;
            },
            draw: function(image) {
                image.control.setTranslate(this.xPosition, this.yPosition);
                // AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Attribute, AbstractNode);

        function Anchor(x, y) {
            AbstractNode.call(this, x, y);
            Anchor.mass = 1;
            Anchor.charge = 1;
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.twoMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.encapsulation = Defaults.encapsulation;
            this.identity = Defaults.identity;
            this.operations.push('addAttribute','addTie','addTieAndAnchor','explode');
            this.type = 'Anchor';
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
        }
        Anchor.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: Defaults.identity,
            generator: true,
            encapsulation: Defaults.encapsulation,
            imploded: false,
            size: 10,
            destroy: function() {
                SVGLayer.nodes.removeChild(this.svg);
                this.svg = null;
            },
            setImploded: function(imploded) {
                this.imploded = imploded;
                if(imploded) {
                    if(this.operations.indexOf('addAttribute') >= 0)
                        this.operations.splice(this.operations.indexOf('addAttribute'), 1);
                    this.size = 9;
                }
                else {
                    this.operations.push('addAttribute');
                    this.size = 10;
                }
            },
            getMass: function() {
                return Anchor.mass;
            },
            getCharge: function() {
                return Anchor.charge;
            },
            isInteractive: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                if(this.imploded)
                    name = "(" + name + ")";
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, node, anchor, anchors = [];
                // first find the anchors
                for(i = 0; node = Model.nodes[i]; i++) {
                    if(node instanceof Anchor) {
                        anchors.push(node);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; anchor = anchors[i]; i++) {
                    if(anchor != this && anchor.mnemonic == this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other anchors in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout, imploded;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                    imploded = layout.getAttribute("imploded");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                imploded = imploded ? imploded == 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = true;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    generator = this.isEmpty(metadata.getAttribute("generator")) ? true :
                                metadata.getAttribute("generator") == 'true';
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = this.isEmpty(idElement.getAttribute("generator")) ? true :
                                idElement.getAttribute("generator") == 'true';
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "??";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var anchor = new Anchor(x, y);
                anchor.setFixed(fixed);
                anchor.setImploded(imploded);
                anchor.description = description ? description.firstChild.nodeValue : '';
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                anchor.generator = generator;
                anchor.encapsulation = capsule;
                anchor.incomplete = anchor.isIncomplete();
                anchor.updateName();
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "??" : this.mnemonic);
                anchor.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                anchor.setAttribute("identity", this.isEmpty(this.identity) ? "" : this.identity);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                anchor.appendChild(metadata);

                var edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.node instanceof Attribute)
                        edge.node.addXML(anchor, schema);
                this.addLayoutXML(anchor, schema);
                return anchor;
            },
            draw: function(image) {
                image.control.setTranslate(this.xPosition, this.yPosition);
                // AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Anchor, AbstractNode);

        function Knot(x, y) {
            AbstractNode.call(this, x, y);
            Knot.mass = 1;
            Knot.charge = 1;
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.encapsulation = Defaults.encapsulation;
            this.type = 'Knot';
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#knot');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#knot');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
        }
        Knot.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: '',
            dataRange: '',
            generator: false,
            encapsulation: Defaults.encapsulation,
            getMass: function() {
                return Knot.mass;
            },
            getCharge: function() {
                return Knot.charge;
            },
            isInteractive: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, node, knot, knots = [];
                // first find the knots
                for(i = 0; node = Model.nodes[i]; i++) {
                    if(node instanceof Knot) {
                        knots.push(node);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; knot = knots[i]; i++) {
                    if(knot != this && knot.mnemonic == this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other knots in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = false;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    generator = this.isEmpty(metadata.getAttribute("generator")) ? true :
                                metadata.getAttribute("generator") == 'true';
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = this.isEmpty(idElement.getAttribute("generator")) ? true :
                                idElement.getAttribute("generator") == 'true';
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "???";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var dataRange = element.getAttribute("dataRange") || '';
                var knot = new Knot(x, y);
                knot.setFixed(fixed);
                knot.description = description ? description.firstChild.nodeValue : '';
                knot.mnemonic = mnemonic;
                knot.descriptor = descriptor;
                knot.identity = identity;
                knot.dataRange = dataRange;
                knot.generator = generator;
                knot.encapsulation = capsule;
                knot.incomplete = knot.isIncomplete();
                knot.updateName();
                return knot;
            },
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                knot.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                knot.setAttribute("identity", this.isEmpty(this.identity) ? '' : this.identity);
                knot.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                knot.appendChild(metadata);

                this.addLayoutXML(knot, schema);
                return knot;
            },
            draw: function(image) {
                image.control.setTranslate(this.xPosition, this.yPosition);
                // AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Knot, AbstractNode);

        function Tie(x, y, historized) {
            AbstractNode.call(this, x, y);
            Tie.mass = 1;
            Tie.charge = 1;
            this.historized = historized;
            this.restatable = Defaults.restatability == 'true';
            this.idempotent = Defaults.idempotency == 'true';
            this.incomplete = this.isIncomplete();
            this.editables.push(Editables.encapsulationEdit);
            this.operations.push('toggleHistorized','addKnot','addAnchor','explode');
            this.encapsulation = Defaults.encapsulation;
            this.type = 'Tie';
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#tie_historized' : '#tie';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 2;
            this.svg.yOffset = 2;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
        }
        Tie.prototype = {
            changingRange: Defaults.changingRange,
            historized: false,
            restatable: true,
            idempotent: false,
            encapsulation: Defaults.encapsulation,
            imploded: false,
            size: 15,
            setImploded: function(imploded) {
                this.imploded = imploded;
                if(imploded) {
                    if(this.operations.indexOf('addKnot') >= 0)
                        this.operations.splice(this.operations.indexOf('addKnot'), 1);
                    this.size = 12;
                }
                else {
                    this.operations.push('addKnot');
                    this.size = 15;
                }
            },
            getMass: function() {
                return Tie.mass;
            },
            getCharge: function() {
                return Tie.charge;
            },
            isInteractive: function() {
                return true;
            },
            setFirstRole: function(edge) {
                this.edges.splice(this.edges.indexOf(edge), 1);
                this.edges.splice(0, 0, edge);
            },
            checkIdentifiers: function() {
                if(this.historized) {
                    var otherNode, outside = 0;
                    for(var i = 0; i < this.edges.length; i++)
                        outside += this.edges[i].identifier ? 0 : 1;
                    if(outside > 1)
                        alert("The tie " + this + " has " + outside +
                                " roles outside the identifier, which is not recommended for a historized tie. " +
                                "In order to determine what changes over time leaving exactly one role outside the " +
                                "identifier is recommended.");
                    else if (outside == 0)
                        alert("The tie " + this +
                                " has no role outside the identifier, which is not recommended for a historized tie. " +
                                "If you want a many-to-many relationship then gaps in the timeline needs to be " +
                                "modeled explicitly using a knotted tie.");
                }
            },
            isConforming: function() {
                var i, j, edge, otherEdge, mnemonic, otherMnemonic, node, roles = {}, identical;
                // check that no roles are identical in the tie
                for(i = 0; edge = this.edges[i]; i++) {
                    for(j = 0; otherEdge = this.edges[j]; j++) {
                        if(i != j && edge.role == otherEdge.role) {
                            mnemonic = (edge.node == this ? edge.otherNode : edge.node).toString();
                            otherMnemonic = (otherEdge.node == this ? otherEdge.otherNode : otherEdge.node).toString();
                            if(mnemonic == otherMnemonic)
                                return !confirm("The roles named '" + edge.role + "' for the anchor '" +
                                        mnemonic + "' cannot be identical in this tie. " +
                                        "Please give the roles different and distinguishing names.");
                        }
                    }
                }
                // first find the anchors and knots connected to this tie
                for(i = 0; edge = this.edges[i]; i++)
                    roles[edge.role + "_" + (edge.node == this ? edge.otherNode : edge.node)] = true;
                // then find all other ties of the same cardinality
                for(i = 0; node = Model.nodes[i]; i++) {
                    if(node instanceof Tie && node != this && node.edges.length == this.edges.length) {
                        identical = true;
                        for(j = 0; edge = node.edges[j]; j++) {
                            identical &= roles[edge.role + "_" + (edge.node == node ? edge.otherNode : edge.node)];
                        }
                        if(identical) {
                            return !confirm("This tie will become identical to the already existing tie named " +
                                    node + ". Please rename the role.");
                        }
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) {
                    this.editables.push(Editables.restatabilityEdit);
                    this.editables.push(Editables.idempotencyEdit);
                }
                else if (!historized && index >= 0)
                    this.editables.splice(index, 2);
                if(this.changingRange == '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#tie_historized' : '#tie';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            isIncomplete: function() {
                return AbstractNode.prototype.isIncomplete.apply(this, arguments) ||
                        !this.toString().match(/^(_?[A-Z]+_[a-zA-Z]+)+$/);
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout, imploded;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                    imploded = layout.getAttribute("imploded");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                imploded = imploded ? imploded == 'true' : false;
                var metadata;
                var capsule = Defaults.encapsulation;
                var restatable = Defaults.restatability == 'true';
                var idempotent = Defaults.idempotency == 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    restatable = metadata.getAttribute("restatable") == 'false' ? false :
                            metadata.getAttribute("restatements") == 'false' ? false :
                                    restatable;
                    idempotent = metadata.getAttribute("idempotent") == 'true' || idempotent;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var tie = new Tie(x, y, historized);
                tie.setFixed(fixed);
                tie.setHistorized(historized);
                tie.setImploded(imploded);
                tie.changingRange = changingRange;
                tie.encapsulation = capsule;
                tie.restatable = restatable;
                tie.idempotent = idempotent;
                tie.description = description ? description.firstChild.nodeValue : '';
                var anchorLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Anchor)
                        anchorLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var knotLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Knot)
                        knotLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var grandparent = element.parentNode.parentNode;
                var j, type, edge, role, identifier, anchor, anchorRoles = element.getElementsByTagName("anchorRole");
                for(i = 0; i < anchorRoles.length; i++) {
                    type = anchorRoles[i].getAttribute("type") || "??";
                    role = anchorRoles[i].getAttribute("role") || "!unknown!";
                    identifier = anchorRoles[i].getAttribute("identifier") || false;
                    var anchors = grandparent.getElementsByTagName("anchor");
                    for(j = 0; j < anchors.length; j++) {
                        if(anchors[j].getAttribute("mnemonic") == type) {
                            anchor = anchorLookup[anchors[j].getAttribute("mnemonic")];
                            edge = new Edge(tie, anchor, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            edge.updateName();
                            break; // only one should match
                        }
                    }
                }
                var knot, knotRoles = element.getElementsByTagName("knotRole");
                for(i = 0; i < knotRoles.length; i++) {
                    type = knotRoles[i].getAttribute("type") || "???";
                    role = knotRoles[i].getAttribute("role") || "!unknown!";
                    identifier = knotRoles[i].getAttribute("identifier") || false;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(j = 0; i < knots.length; j++) {
                        if(knots[j].getAttribute("mnemonic") == type) {
                            knot = knotLookup[knots[j].getAttribute("mnemonic")];
                            edge = new Edge(tie, knot, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            edge.updateName();
                            break; // only one should match
                        }
                    }
                }
                tie.incomplete = tie.isIncomplete();
                tie.updateName();
                return tie;
            },
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                if(this.historized)
                    tie.setAttribute("timeRange", this.changingRange);
                for(var i = 0; i < this.edges.length; i++) {
                    var role;
                    var node = this.edges[i].otherNode;
                    if(this.edges[i].otherNode instanceof Anchor)
                        role = schema.createElement("anchorRole");
                    else if(this.edges[i].otherNode instanceof Knot)
                        role = schema.createElement("knotRole");
                    role.setAttribute("role", this.isEmpty(this.edges[i].role) ? "!unknown!" : this.edges[i].role);
                    role.setAttribute("type", this.isEmpty(node.mnemonic) ? "???" : node.mnemonic);
                    role.setAttribute("identifier",
                            this.isEmpty(this.edges[i].identifier) ? false : this.edges[i].identifier);
                    tie.appendChild(role);
                }

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.encapsulation);
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability == 'true' : this.restatable);
                    metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                            Defaults.idempotency == 'true' : this.idempotent);
                }
                tie.appendChild(metadata);

                this.addLayoutXML(tie, schema);
                return tie;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = null;
                if(this.imploded) {
                    if(name) {
                        name = "(" + name + ")";
                    }
                    else {
                        name = "(";
                        for(i = 0; edge = this.edges[i]; i++) {
                            if(i > 0)
                                name += " ";
                            name += edge.role;
                        }
                        name += ")";
                    }
                }
                return name;
            },
            toString: function() {
                var i, edge, name="";
                for(i = 0; edge = this.edges[i]; i++) {
                    if(i > 0)
                        name += "_";
                    name += edge.otherNode.mnemonic + "_" + edge.role;
                }
                return name;
            },
            draw: function(image) {
                image.control.setTranslate(this.xPosition, this.yPosition);
                // AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Tie, AbstractNode);

        function Edge(node, otherNode, identifier) {
            Edge.mass = 1;
            Edge.charge = 1;
            // assume that the control point and midway point coincide with the center point
            this.centerPoint = {
                xPosition: node.xPosition + (otherNode.xPosition - node.xPosition)/2,
                yPosition: node.yPosition + (otherNode.yPosition - node.yPosition)/2,
                getMass: function() {
                    return Edge.mass;
                },
                getCharge: function() {
                    return Edge.charge;
                }
            };
            this.controlPoint = {
                xPosition: this.centerPoint.xPosition,
                yPosition: this.centerPoint.yPosition,
                getMass: function() {
                    return Edge.mass;
                },
                getCharge: function() {
                    return Edge.charge;
                }
            };
            AbstractNode.call(this, this.controlPoint.xPosition, this.controlPoint.yPosition);
            this.role = '';
            this.node = node;
            this.otherNode = otherNode;
            this.identifier = identifier;
            node.edges.push(this);
            otherNode.edges.push(this);
            this.edges.push(node);
            this.edges.push(otherNode);
            this.editables.push(Editables.roleEdit);
            this.operations.push('toggleIdentifier', 'makeFirstRole');
            this.incomplete = false;
            this.tied = node.type === "Tie" || otherNode.type === "Tie";
            this.type = 'Edge';
            // SVG
            this.svg.pathElement = document.createElementNS(SVGNS, 'path');
            this.svg.pathElement.setAttributeNS(null, 'class', 'edge');
            this.svg.pathElement.setAttributeNS(null, 'd', 'M' + this.node.xPosition.toFixed(2) + ',' + this.node.yPosition.toFixed(2) +
                    ' Q' + this.controlPoint.xPosition.toFixed(2) + ',' + this.controlPoint.yPosition.toFixed(2) +
                    ' ' + this.otherNode.xPosition.toFixed(2) + ',' + this.otherNode.yPosition.toFixed(2));
            this.svg.pathControl = {
                m: this.svg.pathElement.pathSegList.getItem(0),
                q: this.svg.pathElement.pathSegList.getItem(1)
            };
            SVGLayer.edges.appendChild(this.svg.pathElement);
            if(this.tied) {
                this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
                this.svg.graphicsElement.component = this;
                var bubble = document.createElementNS(SVGNS, 'use');
                bubble.setAttributeNS(XLINKNS, 'xlink:href', '#bubble');
                this.svg.graphicsElement.appendChild(bubble);
                this.svg.useElement = document.createElementNS(SVGNS, 'use');
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', this.identifier ? '#many' : '#one');
                this.svg.graphicsElement.appendChild(this.svg.useElement);
                this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + this.xPosition + ',' + this.yPosition + ')');
                this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
                SVGLayer.edges.appendChild(this.svg.graphicsElement);
                this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
                this.svg.boundingBox = this.svg.graphicsElement.getBBox();
                this.svg.xOffset = 2;
                this.svg.yOffset = 2;
                this.setNameable(true);
            }
            // NAV
            this.nav.pathElement = document.createElementNS(SVGNS, 'path');
            this.nav.pathElement.setAttributeNS(null, 'class', 'edge');
            this.nav.pathElement.setAttributeNS(null, 'd', 'M' + this.node.xPosition.toFixed(2) + ',' + this.node.yPosition.toFixed(2) +
                    ' Q' + this.controlPoint.xPosition.toFixed(2) + ',' + this.controlPoint.yPosition.toFixed(2) +
                    ' ' + this.otherNode.xPosition.toFixed(2) + ',' + this.otherNode.yPosition.toFixed(2));
            this.nav.pathControl = {
                m: this.nav.pathElement.pathSegList.getItem(0),
                q: this.nav.pathElement.pathSegList.getItem(1)
            };
            NAVLayer.edges.appendChild(this.nav.pathElement);
        }
        Edge.prototype = {
            role: null,
            node: null,
            otherNode: null,
            controlPoint: { xPosition: null, yPosition: null },
            centerPoint: { xPosition: null, yPosition: null },
            identifier: true,
            path: null,
            pathControl: null,
            use: null,
            tied: false,
            getMass: function() {
                return Edge.mass;
            },
            getCharge: function() {
                return Edge.charge;
            },
            isInteractive: function() {
                return this.tied;
            },
            // overload to remove propagation of movement
            start: function() {
                this.moving = true;
            },
            // edges never fixate
            setFixed: function(fixed) {
                this.fixed = false;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = null;
                else
                    name = this.toString();
                var tie;
                if(this.node instanceof Tie)
                    tie = this.node;
                else if(this.otherNode instanceof Tie)
                    tie = this.otherNode;
                if(tie && tie.imploded)
                    return null;
                return name;
            },
            toString: function() {
                return this.role;
            },
            draw: function(image) {
                image.pathControl.m.x = this.node.xPosition;
                image.pathControl.m.y = this.node.yPosition;
                image.pathControl.q.x1 = this.controlPoint.xPosition;
                image.pathControl.q.y1 = this.controlPoint.yPosition;
                image.pathControl.q.x = this.otherNode.xPosition;
                image.pathControl.q.y = this.otherNode.yPosition;
                if(this.tied && image.control) {
                    image.control.setTranslate(this.xPosition, this.yPosition);
                }
                //AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Edge, AbstractNode);


        // global function providing inheritance
        function extend(child, supertype){
            child.prototype.supertype = {};
            for(var member in supertype.prototype)
                if(!child.prototype[member])
                    child.prototype[member] = supertype.prototype[member];
                else
                    child.prototype.supertype[member] = supertype.prototype[member];
            /* moving away from this type of inheritance, as it has worse performance, and not supported in IE9 */
            //child.prototype.__proto__ = supertype.prototype;
        }

        function ModalBackground(message) {
            CanvasEventHandler.disableKeyboardShortcuts();
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;
            if(message) {
                var text = document.createTextNode(message);
                modalBackground.appendChild(text);
            }
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
                CanvasEventHandler.enableKeyboardShortcuts();
            }
        };

        function URLPopover(url) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "urlPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('iframe');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.src = url;

            popover.appendChild(content);
            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        URLPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CodePopover(documentFragment, preformatted) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "codePopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            if(preformatted)
                content.setAttribute("class", "preformatted");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.appendChild(documentFragment);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CodePopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CloudBrowserPopover(scope) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudBrowserPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var filter = document.createElement('div');
            filter.setAttribute("id", "keywordFilter");
            filter.appendChild(document.createTextNode('Keyword: '));
            var keywords = document.createElement('input');
            keywords.setAttribute('type', 'text');
            keywords.addEventListener('change', function() { self.keywordFilter = this.value; }, false);
            filter.appendChild(keywords);
            var searchButton = document.createElement('input');
            searchButton.setAttribute('type', 'button');
            searchButton.value = 'Search';
            searchButton.addEventListener('click', function(e) {
                self.generateList();
            }, false);
            this.searchButton=searchButton;
            filter.appendChild(searchButton);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';

            this.listContainer=content;
            this.scope=scope;
            this.generateList();

            popover.appendChild(filter);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudBrowserPopover.prototype = {
            popover: null,
            modalBackground: null,
            listContainer:null,
            searchButton:null,
            scope:'',
            keywordFilter:'',
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            },
            generateList : function() {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var self = this;
                var xmlhttp = new window.XMLHttpRequest();
                this.searchButton.disabled=true;
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var modelList = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        self.fillFromList(modelList);
                    }
				};
                var params = {};
                params.action = 'list';
                params.maxItemsReturned = '100';
                params.scope = this.scope;
                if(self.keywordFilter!='') {
                    params.filterBy='keywords';
                    params.filterValue=self.keywordFilter;
                }
                Actions.cloudWrapper(xmlhttp, params);
            },
            fillFromList : function(modelList) {
                var self = this;
                var models = modelList.getElementsByTagName('Model');
                var model, modelContainer;
                while (this.listContainer.hasChildNodes())
                    this.listContainer.removeChild(this.listContainer.firstChild);
                for(var i = 0; i < models.length; i++) {
                    model = models.item(i);
                    modelContainer = document.createElement('div');
                    modelContainer.setAttribute("class", "modelContainer");
                    modelContainer.modelId = model.getAttribute("modelId");
                    modelContainer.modelName = model.getAttribute("modelName");
                    modelContainer.modelScope = model.getAttribute("scope") || "private";
                    modelContainer.modelKeywords = model.getAttribute("keywords");
                    modelContainer.modelDescription = unescape(model.getAttribute("description"));
                    modelContainer.lastLoaded = model.getAttribute("lastLoaded");
                    modelContainer.loadedCount = model.getAttribute("loadedCount");
                    modelContainer.url = window.location.protocol + '//' +
                            window.location.hostname + window.location.pathname + "?id=" + modelContainer.modelId;
                    modelContainer.addEventListener('click', function(e) {
                        Actions.loadModelFromCloud(
                                this.modelId,
                                this.modelName,
                                this.modelScope,
                                this.modelKeywords,
                                this.modelDescription
                        );
                        self.close(e);
                    }, false);

                    //modelContainer.setAttribute("id","codePopover");
                    if(LOGGED_IN && (USER_ID==model.getAttribute("userId"))) {
                        var deleteButton = document.createElement('div');
                        deleteButton.className = 'modelDeleteButton';
                        deleteButton.setAttribute(
                                "style",
                                "border-style: hidden; display: block; margin: 0px 0px -28px; padding: 0;"
                        );
                        deleteButton.modelId = modelContainer.modelId;
                        deleteButton.modelName = modelContainer.modelName;
                        deleteButton.modelContainer = modelContainer;
                        deleteButton.addEventListener('click', function(event) {
                            //Disable click for modelcontainer
                            if (event.stopPropagation)
                                event.stopPropagation();
                            else if(window.event)
                               window.event.cancelBubble=true;
                            if(confirm("Are you sure you want to delete this model:?\n" + this.modelName)) {
                                Actions.deleteModelFromCloud(this.modelId);
                                self.listContainer.removeChild(this.modelContainer);
                            }
                        }, false);
                        modelContainer.appendChild(deleteButton);
                    }
                    var icon = document.createElement('img');
                    icon.setAttribute("src", model.getAttribute("icon"));
                    icon.setAttribute("class", "modelIcon");
                    var name = document.createElement("div");
                    name.appendChild(document.createTextNode(model.getAttribute("modelName") + " "));
                    name.className = 'modelName';
                    var keywords = document.createElement("div");
                    keywords.className = 'modelKeywords';
                    keywords.appendChild(document.createTextNode(model.getAttribute("keywords")));
                    var description = document.createElement("div");
                    description.className = 'modelDescription';
                    description.appendChild(document.createTextNode(modelContainer.modelDescription));
                    modelContainer.appendChild(icon);
                    modelContainer.appendChild(name);
                    modelContainer.appendChild(keywords);
                    modelContainer.appendChild(description);
                    if(modelContainer.modelScope == 'public') {
                        var twitter = document.createElement('div');
                        var tweet = document.createElement("a");
                        var externalLink = document.createElement("img");
                        externalLink.setAttribute("src", "externalLink.png");
                        externalLink.setAttribute("class", "externalLink");
                        var params = [];
                        params.push("url=" + modelContainer.url);
                        params.push("via=anchormodeling");
                        params.push("text=" + modelContainer.modelName);
                        params.push("lang=en");
                        params.push("count=vertical");
                        tweet.setAttribute("href", "https://twitter.com/share?" + params.join('&'));
                        tweet.setAttribute("class", "tweet");
                        tweet.setAttribute("target", "_blank");
                        tweet.appendChild(document.createTextNode("tweet this model"));
                        twitter.setAttribute("class", "twitter");
                        twitter.appendChild(tweet);
                        twitter.appendChild(externalLink);
                        modelContainer.appendChild(twitter);
                    }
                    modelContainer.title = modelContainer.modelName +
                            ' - ' + modelContainer.loadedCount + ' views, last on ' + modelContainer.lastLoaded;
                    this.listContainer.appendChild(modelContainer);
                }
				self.searchButton.disabled=false;
            }
        };

        function CloudSaverPopover() {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudSaverPopover");
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");

            var icon = document.createElement('img');
            icon.setAttribute('src', DrawingEngine.miniatureCanvas.toDataURL());
            content.appendChild(icon);

            var table = document.createElement('table');
            var tr = document.createElement('tr');
            var td = document.createElement('td');
            td.appendChild(document.createTextNode('Model name: '));
            tr.appendChild(td);
            td = document.createElement('td');
            var modelName = document.createElement('input');
            modelName.setAttribute('type', 'text');
            if(Model.name && Model.name != null)
                modelName.value = Model.name;
            modelName.addEventListener('change', function() { Model.name = this.value; }, false);
            td.appendChild(modelName);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelScope = document.createElement('select');
            var privateOption = document.createElement('option');
            privateOption.setAttribute('value', 'private');
            privateOption.appendChild(document.createTextNode('Private'));
            modelScope.appendChild(privateOption);
            var publicOption = document.createElement('option');
            publicOption.setAttribute('value', 'public');
            publicOption.appendChild(document.createTextNode('Public'));
            modelScope.appendChild(publicOption);
            if(Model.scope && Model.scope != null)
                modelScope.value = Model.scope;
            modelScope.addEventListener('change', function() { Model.scope = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Scope: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelScope);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelKeywords = document.createElement('input');
            modelKeywords.setAttribute('type', 'text');
            modelKeywords.setAttribute('placeholder', 'keywords separated with spaces');
            if(Model.keywords && Model.keywords != null)
                modelKeywords.value = Model.keywords;
            modelKeywords.addEventListener('change', function() { Model.keywords = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Keywords: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelKeywords);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelDesc = document.createElement('textarea');
            modelDesc.setAttribute('rows', '4');
            modelDesc.setAttribute('cols', '40');
            if(Model.description && Model.description != null)
                modelDesc.value = Model.description;
            modelDesc.addEventListener('change', function() { Model.description = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Description: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelDesc);
            tr.appendChild(td);
            table.appendChild(tr);

            content.appendChild(table);

            if(Model.id) {
                var overwriteButton = document.createElement('input');
                overwriteButton.setAttribute('type', 'button');
                overwriteButton.className = 'overwriteButton';
                overwriteButton.value = 'Overwrite';
                overwriteButton.addEventListener('click', function(e) {
                    Actions.saveModelInCloud(false);
                    self.close(e);
                }, false);
                content.appendChild(overwriteButton);
            }
            var saveButton = document.createElement('input');
            saveButton.setAttribute('type', 'button');
            saveButton.className = 'saveButton';
            saveButton.value = 'Save New';
            saveButton.addEventListener('click', function(e) {
                Model.id = null;
                Actions.saveModelInCloud(false);
                self.close(e);
            }, false);
            content.appendChild(saveButton);

            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudSaverPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        var Operations = {
            // operations are defined as 'method', 'display name', 'description', 'optional rule'
            list: [
                ['erase',
                    'Delete selected...',
                    'Deletes the selected item(s) from the model.'],
                ['toggleKnotted',
                    'Toggle knotted',
                    'Adds or removes a knot from the selected attribute(s).'], // TODO: only remove knot if it is the last attribute
                ['toggleHistorized',
                    'Toggle historized',
                    'Historized items can store versions of values over changing time and are marked by a double outline in the model.'],
                ['addAttribute',
                    'Add attribute',
                    'Add an attribute to the selected anchor(s).'],
                ['addTie',
                    'Add tie',
                    'Add a tie between the selected anchors.'],
                ['addAnchor',
                    'Add anchor',
                    'Add an anchor to the selected tie(s).'],
                ['addKnot',
                    'Add knot',
                    'Add a knot to the selected tie(s).'],
                ['addTieAndAnchor',
                    'Add tied anchor',
                    'Add a tie with a connected anchor to the selected anchor(s).'],
                ['toggleIdentifier',
                    'Toggle identifier',
                    'Toggles whether the selected role(s) should be a part of the primary key or not.'],
                ['makeFirstRole',
                    'Make first role',
                    'Make the selected role(s) the first role in the primary key and tie name.'],
                ['connect',
                    'Connect',
                    'Connect the selected node(s).',
                    function(allNodes) {
                        if(allNodes.length != 2)
                            return false;
                        var node, anchors = 0, ties = 0, knots = 0, knotted, attributes = 0;
                        for(var i = 0; node = allNodes[i]; i++) {
                            if(node instanceof Anchor)
                                anchors++;
                            else if(node instanceof Tie)
                                ties++;
                            else if(node instanceof Knot)
                                knots++;
                            else if(node instanceof Attribute) {
                                attributes++;
                                knotted = node.getKnotted();
                            }
                        }
                        return anchors && ties || knots && ties || attributes && knots && !knotted;
                    }],
                ['explode',
                    'Explode/Implode',
                    'Change the level of detail for the selected item(s) in the model.']
            ],
            isSupported: function(operation, nodes) {
                for(var i = 0; i < nodes.length; i++)
                    if(nodes[i].operations.indexOf(operation) < 0)
                        return false;
                return true;
            }
        };

        function ContextMenu(hoveredNode, selectedNodes) {
            var self = this;

            this.hoveredNode = hoveredNode;
            this.selectedNodes = selectedNodes;
            var contextMenu = document.createElement('div');
            contextMenu.setAttribute('id', 'contextMenu');
            this.toggler = document.createElement('div');
            this.toggler.setAttribute('class', 'toggler collapsed');
            this.toggler.setAttribute('title', 'Click to open the context menu.');
            this.toggler.addEventListener('click', function(e) { self.toggle() }, false);
            contextMenu.appendChild(this.toggler);
            this.contextMenu = contextMenu;

            this.topper = document.createElement('div');
            this.topper.setAttribute('class', 'topper unselectable');
            this.topper.addEventListener('mousedown', function(e) { self.mousedown(e); }, false);

            var editable;
            this.editsHaveBeenMade = false;
            this.editables = document.createElement('table');
            this.editables.setAttribute('class', 'items');
            this.showEditables = false;

            var i, j, tr;
            // if we are operating a single node, show its editable fields
            if(selectedNodes.length == 0 || (selectedNodes.length == 1 && selectedNodes[0] == hoveredNode)) {
                this.topper.appendChild(document.createTextNode("Edit " + hoveredNode.type));
                for(i = 0; editable = hoveredNode.editables[i]; i++) {
                    this.showEditables = true;
                    var element = document.createElement(editable.type);
                    element.className = 'editable';
                    if(editable.pattern)
                        element.setAttribute('pattern', editable.pattern);
                    for(j = 0; j < editable.attributes.length;) {
                        var attribute = editable.attributes[j++];
                        var value = editable.attributes[j++];
                        element.setAttribute(attribute, value);
                    }
                    editable.setElement(element, hoveredNode);
                    element.editable = editable;
                    element.addEventListener(editable.event, function(e) { self.edit(this, hoveredNode); }, false);
                    element.addEventListener('change', function(e) { self.editsHaveBeenMade = true; }, false);
                    element.addEventListener('keypress', function(e) { self.keypress(self, e); }, false);
                    if(editable.pattern)
                        element.addEventListener('invalid', function(e) { self.invalid(this, hoveredNode); }, false);
                    tr = document.createElement('tr');
                    tr.setAttribute('valign', 'top');
                    tr.setAttribute('title', editable.description);
                    var td1 = document.createElement('td');
                    td1.appendChild(document.createTextNode(editable.name + ":"));
                    tr.appendChild(td1);
                    var td2 = document.createElement('td');
                    td2.appendChild(element);
                    tr.appendChild(td2);
                    this.editables.appendChild(tr);
                }
            }
            else {
                this.topper.appendChild(document.createTextNode("Edit selection"));
            }

            var supportedOperations = [];

            var allNodes = selectedNodes.slice(0);
            if(allNodes.indexOf(hoveredNode) < 0)
                allNodes.push(hoveredNode);

            var validator;
            for(i = 0; i < Operations.list.length; i++) {
                if(Operations.isSupported(Operations.list[i][0], allNodes)) {
                    if(validator = Operations.list[i][3]) {
                        if(validator(allNodes))
                            supportedOperations.push(Operations.list[i]);
                    }
                    else
                        supportedOperations.push(Operations.list[i]);
                }
            }

            this.operators = document.createElement('fieldset');
            this.operators.setAttribute('class', 'operators');
            var operations = document.createElement('legend');
            operations.setAttribute(
                    'title',
                    'Context sensitive list of operations that can be performed ' +
                    'on the selected item(s). Shift+click in order to select ' +
                    'multiple items in the model graph.'
            );
            operations.appendChild(document.createTextNode('OPERATIONS'));
            this.operators.appendChild(operations);
            for(i = 0; i < supportedOperations.length; i++) {
                var operator = document.createElement('div');
                operator.setAttribute('class', 'operator');
                operator.setAttribute('title', supportedOperations[i][2]);
                operator.appendChild(document.createTextNode(supportedOperations[i][1]));
                operator.method = supportedOperations[i][0];
                operator.addEventListener('click', function() { self.operate(this, allNodes); }, false);
                this.operators.appendChild(operator);
            }

            this.updatePosition();
            document.body.appendChild(contextMenu);
            return this;
        }
        ContextMenu.prototype = {
            contextMenu: null,
            hoveredNode: null,
            selectedNodes: null,
            showEditables: false,
            editables: null,
            operators: null,
            divider: null,
            topper: null,
            toggler: null,
            collapsed: true,
            modalBackground: null,
            editsHaveBeenMade: false,
            dragging: false,
            operate: function(button, nodes) {
                Model[button.method](nodes);
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].incomplete = nodes[i].isIncomplete();
                CanvasEventHandler.closeContextMenu();
            },
            edit: function(element, node) {
                if(element && node) {
                    element.editable.setMember(element, node);
                    if(node.node instanceof Tie)
                        node.node.incomplete = node.node.isIncomplete();
                    element.checkValidity();
                }
            },
            invalid: function(element, node) {
                node.incomplete = true;
            },
            mousedown: function(event) {
                var self = this;
                window.addEventListener('mousemove', function(e) { self.mousemove(self, e); }, false);
                window.addEventListener('mouseup', function(e) { self.mouseup(self, e); }, false);
                this.dragging = true;
            },
            mousemove: function(self, event) {
                if(self.dragging) {
                    var xScreen, yScreen;
                    xScreen = event.clientX
                            - self.contextMenu.offsetWidth / 2;
                    yScreen = event.clientY
                            - self.topper.offsetHeight / 2;
                    this.updatePosition(xScreen, yScreen);
                }
            },
            mouseup: function(self, event) {
                this.dragging = false;
                // TODO: This does not remove the listener!
                window.removeEventListener('mousemove', function(event) { self.mousemove(self, event); }, false);
                window.removeEventListener('mouseup', function(event) { self.mouseup(self, event); }, false);
            },
            updatePosition: function(x, y) {
                var point = EventHandler.svgToScreen(
                        this.hoveredNode.xPosition + 15, // inside the highlight ring with radius 30
                        this.hoveredNode.yPosition + 15
                );
                x = x ? x : point.x;
                y = y ? y : point.y;
                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
            },
            keypress: function(self, event) {
                if(event.keyCode == 13) {
                    event.srcElement.blur();
                    if(Model.isConforming())
                        CanvasEventHandler.closeContextMenu();
                }
            },
            toggle: function() {
                var self = this;
                if(this.collapsed) {
                    this.toggler.className = 'toggler expanded';
                    this.toggler.setAttribute('title', 'Click to close the context menu.');
                    this.collapsed = false;
                    this.modalBackground = new ModalBackground();
                    this.contextMenu.appendChild(this.topper);
                    if(this.showEditables) {
                        this.contextMenu.appendChild(this.editables);
                        var editables = this.editables.getElementsByClassName('editable');
                        if(editables.length > 0)
                            editables[0].focus();
                    }
                    this.contextMenu.appendChild(this.operators);
                }
                else {
                    if(this.editsHaveBeenMade && !Model.isConforming())
                        return;
                    this.toggler.className = 'toggler collapsed';
                    this.toggler.setAttribute('title', 'Click to open the context menu.');
                    this.collapsed = true;
                    this.contextMenu.removeChild(this.operators);
                    if(this.showEditables) {
                        this.contextMenu.removeChild(this.editables);
                    }
                    this.contextMenu.removeChild(this.topper);
                    this.unmodal();
                    DrawingEngine.start(false);
                }
            },
            unmodal: function() {
                if(this.modalBackground) {
                    this.modalBackground.close();
                    this.modalBackground = null;
                }
                this.hoveredNode.incomplete = this.hoveredNode.isIncomplete();
            },
            close: function() {
                this.unmodal();
                if(this.editsHaveBeenMade)
                    Model.recordState();
                document.body.removeChild(this.contextMenu);
            }
        };

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                // does not work in Safari, but works in Firefox 3.6 and Chrome 6.
                this.reader = new FileReader();
                this.reader.onload = function(e) { FileHandler.fileLoaded(e) };
                this.reader.onerror = function(e) {
                    console.error("File could not be read! Code " + event.target.error.code);
                };
                this.reader.readAsText(files[0]);
            },
            replaceInput: function(parent, input) {
                var newInput = document.createElement('input');
                newInput.className = 'fileSelect';
                newInput.setAttribute('type', 'file');
                newInput.addEventListener('change', function() {
                    FileHandler.handleFiles(this.files);
                    FileHandler.replaceInput(this.parentNode, this);
                }, false);
                parent.replaceChild(newInput, input)
            },
            fileLoaded: function(event) {
                try {
                    var parser = new DOMParser();
                    var xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                    throw exception;
                }
                CanvasEventHandler.clearSelection();
                Model.uncloud();
                Model.clearStates();
                Model.fromXML(xml);
                Actions.setModelStatus();
                DrawingEngine.reset();
                Actions.resetZoom();
                Actions.centerModel();
                DrawingEngine.start(false);
            }
        };

        var Actions = {
            populateSelector: function(selector, searchString) {
                this.startKeyboardEvents();
                var node;
                var selected = selector.value;
                selector.options.length = 0;
                selector.options.add(new Option("None selected", "none"));
                var nodes = Model.nodes.slice();
                nodes.sort(
                    function(a, b) {
                        var nameA = a.encapsulation + '.' + a.toString();
                        var nameB = b.encapsulation + '.' + b.toString();
                        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
                    }
                );
                for(var i = 0; node = nodes[i]; i++) {
                    if(node.toString() && !(node instanceof Edge)) {
                        var fullName = node.encapsulation + '.' + node.toString();
                        if(node.isIncomplete())
                            fullName = "* " + fullName;
                        var option = new Option(fullName, node.shadowColor);
                        if(searchString && searchString.trim() != '') {
                            if(fullName.indexOf(searchString) >= 0)
                                selector.options.add(option);
                        }
                        else {
                            selector.options.add(option);
                        }
                    }
                }
                selector.value = selected;
            },
            getMiniatureImage: function() {
                var img = new Image();
                var graph = SVG.cloneNode(true);
                var names = graph.getElementById('names');
                if(names) graph.removeChild(names);
                graph.setAttribute("width", "200px");
                graph.setAttribute("height", "200px");
                var pad = 50;
                var boundingBox =
                        (Model.leftmostNode.xPosition - pad) + " " +
                        (Model.topmostNode.yPosition - pad) + " " +
                        (Model.rightmostNode.xPosition + pad) + " " +
                        (Model.bottommostNode.yPosition + pad);
                graph.setAttribute("viewBox", boundingBox);
                graph.setAttribute("preserveAspectRatio", "xMinYMin slice");
                var svg = (new XMLSerializer()).serializeToString(graph);
                img.style.width = '200px';
                img.style.heigth = '200px';
                img.src = "data:image/svg+xml;base64," + btoa(svg);
                return img;
            },
            stopKeyboardEvents: function() {
                window.onkeypress = null;
            },
            startKeyboardEvents: function() {
                window.onkeypress = CanvasEventHandler.handleEvent;
            },
            findNodeToExplode: function(node) {
                for(i = 0; edge = node.edges[i]; i++) {
                    otherNode = edge.node == node ? edge.otherNode : edge.node;
                    if((otherNode instanceof Anchor || otherNode instanceof Tie) && otherNode.imploded) {
                        Model.explode([otherNode]);
                        break;
                    }
                }
            },
            selectNode: function(shadowColor) {
                if(shadowColor != 'none') {
                    var i, edge, otherNode, node = Model.getNodeFromShadow(shadowColor);
                    // find the closest imploded node and explode it
                    if(!node.visible) {
                        if(node instanceof Attribute)
                            this.findNodeToExplode(node);
                        else if(node instanceof Knot) {
                            this.findNodeToExplode(node);
                            if(!node.visible) {
                                for(i = 0; edge = node.edges[i]; i++) {
                                    otherNode = edge.node == node ? edge.otherNode : edge.node;
                                    if(otherNode instanceof Attribute) {
                                        this.findNodeToExplode(otherNode);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    CanvasEventHandler.clearSelection();
                    CanvasEventHandler.addNodeToSelection(node);
                    Actions.centerModelOn(node);
                }
                else {
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.start(false);
                }
            },
            transform: function (xmlDocument, transformationURL, ownerDocument) {
                var result;
                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    // Added random parameter to prevent caching...
                    xmlhttp.open("GET", transformationURL + '?r=' + Math.random(), false);
                    xmlhttp.send(null);
                    var processor = new XSLTProcessor();
                    if(xmlhttp.responseXML) {
                        processor.importStylesheet(xmlhttp.responseXML.documentElement);
                    }
                    else {
                        var xml = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        processor.importStylesheet(xml.documentElement);
                    }
                    processor.setParameter(null, 'metadataPrefix', Defaults.metadataPrefix);
                    processor.setParameter(null, 'metadataType', Defaults.metadataType);
                    processor.setParameter(null, 'metadataUsage', Defaults.metadataUsage);
                    processor.setParameter(null, 'changingSuffix', Defaults.changingSuffix);
                    processor.setParameter(null, 'identitySuffix', Defaults.identitySuffix);
                    processor.setParameter(null, 'temporalization', Settings.temporalization);
                    processor.setParameter(null, 'recordingRange', Defaults.recordingRange);
                    processor.setParameter(null, 'recordingSuffix', Defaults.recordingSuffix);
                    processor.setParameter(null, 'erasingSuffix', Defaults.erasingSuffix);
                    processor.setParameter(null, 'partitioning', Defaults.partitioning);
                    processor.setParameter(null, 'entityIntegrity', Defaults.entityIntegrity);
                    processor.setParameter(null, 'defaultCapsule', Defaults.encapsulation);
                    processor.setParameter(null, 'namingConvention', Defaults.naming);
                    result = processor.transformToFragment(xmlDocument, ownerDocument);
                }
                catch(exception){
                    alert(exception);
                    throw exception;
                }
                return result;
            },
            saveToDisk: function (str) {
                // while waiting for a working method
                window.open(
                        'data:text/xml,'
                        + '<!-- Due to browser limitations you have to copy or save this content manually -->'
                        + str, '_newtab'
                );
            },
            loadFromURL: function (url) {
//                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET", url, false);
                    xmlhttp.send(null);
                    CanvasEventHandler.clearSelection();
                    Model.uncloud();
                    Model.clearStates();
                    Model.fromXML(xmlhttp.responseXML);
                    Actions.setModelStatus();
                    DrawingEngine.reset();
                    Actions.resetZoom();
                    Actions.centerModel();
                    DrawingEngine.start(false);
/*                }
                catch(exception){
                    alert(exception);
                    throw exception;
                }*/
            },
            modelStatusText: null,
            setModelStatus: function() {
                var statusElement = document.getElementById("model");
                var status = "Local editing mode";
                if(Model.name && Model.id)
                    status = "Cloud mode, editing " + Model.scope + " model: " + Model.name;
                if(Actions.modelStatusText)
                    statusElement.removeChild(Actions.modelStatusText);
                Actions.modelStatusText = document.createTextNode(status);
                statusElement.appendChild(Actions.modelStatusText);
            },
            cloudStatusText: null,
            checkCloudConnectionStatus: function(redirect) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var statusElement = document.getElementById("cloud");
                        if(Actions.cloudStatusText)
                            statusElement.removeChild(Actions.cloudStatusText);
                        var lines, response = xmlhttp.responseText;
                        if(response.match(/^OK:/) && !redirect) {
                            lines = response.split(/[\r\n]/);
                            var login = lines[0].replace(/^OK:/, '').replace(/^[^\S]+/,'');
                            Actions.cloudStatusText = document.createTextNode(login);
                            statusElement.appendChild(Actions.cloudStatusText);
                            USER_ID = lines[2];
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^LOGIN:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging in...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            window.location = response.replace(/^LOGIN:/, '').replace(/^[^\S]+/,'');
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^OK:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging out...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            lines = response.split(/[\r\n]/);
                            window.location = lines[1];
                            LOGGED_IN = false;
                        }
                        else {
                            Actions.cloudStatusText = document.createTextNode("Not logged in (click here to log in)");
                            statusElement.appendChild(Actions.cloudStatusText);
                            LOGGED_IN = false;
                        }
                        Actions.setModelStatus();
                    }
                };

                var params = {};
                params.action = 'status';
                this.cloudWrapper(xmlhttp, params);
            },
            listModelsInCloud: function(scope) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";

                if(scope == 'private' && !LOGGED_IN) {
                    alert("You need to log in to reach your private models. Try again after logging in!");
                    this.checkCloudConnectionStatus(true);
                }

                new CloudBrowserPopover(scope);
            },
            loadModelFromCloud: function(modelId, modelName, modelScope, modelKeywords, modelDescription) {
                var modalBackground = new ModalBackground('Loading model, please wait...');
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be loaded from the cloud service!");
                            if(Model.isEmpty())
                                Model.setupMinimal(false);
                        }
                        else {
                            var model = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                            CanvasEventHandler.clearSelection();
                            Model.uncloud();
                            Model.clearStates();
                            Model.fromXML(model);
                            Model.id = modelId;
                            Model.name = modelName;
                            Model.scope = modelScope;
                            Model.keywords = modelKeywords;
                            Model.description = modelDescription;
                            Actions.setModelStatus();
                            DrawingEngine.reset();
                            Actions.resetZoom();
                            Actions.centerModel();
                            DrawingEngine.start(false);
                        }
                        modalBackground.close();
                    }
                };

                var params = {};
                params.action = 'load';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp,params);
            },
            saveModelInCloud: function(popover) {
                if(popover) {
                    new CloudSaverPopover();
                }
                else {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                        if(xmlhttp.readyState == 4) {
                            var response = xmlhttp.responseText;
                            if(response.match(/^LOGIN:/)) {
                                alert("You need to log in before saving. Try to save again after logging in!");
                                ASKBEFOREUNLOAD = false;
                                window.location = response.replace(/^LOGIN:/, '');
                            }
                            else if(response.match(/^OK:/)) {
                                var modelId = response.replace(/^OK:/, '').replace(/^[^\S]+/,'').replace(/[^\S]+$/,'');
                                Model.id = modelId;
                                Actions.setModelStatus();
                                alert("Model saved in cloud as: " + Model.name);
                            }
                            else {
                                // this is probably an error msg from the server
                                alert(response);
                            }
                        }
                    };

                    var params = {};
                    params.action = 'save';
                    params.modelName = Model.name;
                    params.modelXml = new XMLSerializer().serializeToString(Model.toXML(false));
                    params.icon = DrawingEngine.miniatureCanvas.toDataURL();
                    params.scope = Model.scope || "private";
                    params.keywords = Model.keywords;
                    params.description = escape(Model.description);
                    if(Model.id)
                        params.modelId = Model.id;
                    this.cloudWrapper(xmlhttp,params);
                }
            },
            deleteModelFromCloud : function(modelId) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be deleted from the cloud service!\n" + response);
                        }
                        else {
                            alert("The model was deleted successfully.");
                        }
                    }
                };
                var params = {};
                params.action = 'delete';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp, params);
            },
            sendMultiPart: function(xmlhttp, params) {
                var BOUNDARY = "---------------------------1966284435497298061834782736";
                var rn = "\r\n";
                var req = "--" + BOUNDARY;
                for (var i in params) {
                    req += rn + "Content-Disposition: form-data; name=\"" + i + "\"";
                    req += rn + rn + params[i] + rn + "--" + BOUNDARY;
                }
                req += "--";
                xmlhttp.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
                xmlhttp.sendAsBinary(req);
            },
            cloudWrapper : function(xmlhttp, params) {
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                //var url = "http://localhost:8888/anchormodeler";
                xmlhttp.open("POST", url, true);
                xmlhttp.withCredentials = 'true';
                if(window.FormData) {
                    var formData = new FormData();
                    for (var i in params)
                        formData.append(i,params[i]);
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    this.sendMultiPart(xmlhttp, params);
                }
            },

            resetZoom: function() {
                ControlButtons.doZoom(1/DrawingEngine.xyScale);
                DrawingEngine.start(false);
            },
            centerModel: function() {
                var xCenter = Model.leftmostNode.xPosition +
                        (Model.rightmostNode.xPosition - Model.leftmostNode.xPosition)/2;
                var yCenter = Model.topmostNode.yPosition +
                        (Model.bottommostNode.yPosition - Model.topmostNode.yPosition)/2;
                this.centerModelAt(xCenter, yCenter);
            },
            centerModelOn: function(node) {
                this.centerModelAt(node.xPosition, node.yPosition);
            },
            centerModelAt: function(x, y) {
                var xAdjust = DrawingEngine.xContext(DrawingEngine.canvas.width/2) - x;
                var yAdjust = DrawingEngine.yContext(DrawingEngine.canvas.height/2) - y;
                DrawingEngine.translate(xAdjust, yAdjust);
                DrawingEngine.start(false);
            },
            randomizeLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    if(!Model.visibleNodes[i].getFixed()) {
                        Model.visibleNodes[i].xPosition = Math.random() * window.innerWidth;
                        Model.visibleNodes[i].yPosition = Math.random() * window.innerHeight;
                    }
                }
                DrawingEngine.start(true);
            },
            toggleFixation: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].setFixed(!Model.nodes[i].getFixed());
                DrawingEngine.start(true);
            },
            releaseAll: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].setFixed(false);
                DrawingEngine.start(true);
            },
            toggleNames: function () {
                DrawingEngine.showNames = !DrawingEngine.showNames;
                if(DrawingEngine.showNames)
                    SVGLayer.show('names');
                else
                    SVGLayer.hide('names');
                DrawingEngine.start(false);
            },
            toggleMnemonics: function () {
                Settings.showMnemonics = !Settings.showMnemonics;
                DrawingEngine.start(false);
            },
            toggleCardinalities: function () {
                Settings.showCardinalities = !Settings.showCardinalities;
                DrawingEngine.start(false);
            },
            toggleShadows: function() {
                DrawingEngine.drawShadows = !DrawingEngine.drawShadows;
            },
            toggleCurves: function() {
                DrawingEngine.drawCurves = !DrawingEngine.drawCurves;
            },
            implodeAll: function() {
                var i, node, allNodes = [];
                for(i = 0; node = Model.nodes[i]; i++) {
                    if((node instanceof Anchor || node instanceof Tie) && !node.imploded)
                        allNodes.push(node);
                }
                CanvasEventHandler.clearSelection();
                Model.explode(allNodes);
            },
            explodeAll: function() {
                var i, node, allNodes = [];
                for(i = 0; node = Model.nodes[i]; i++) {
                    if((node instanceof Anchor || node instanceof Tie) && node.imploded)
                        allNodes.push(node);
                }
                Model.explode(allNodes);
            },
            generateURL: function() {
                if(Model.id) {
                    if(Model.scope != 'public')
                        alert("This model not public. Please note that only you will be able to use the URL.");
                    var url = window.location.protocol + '//' + window.location.hostname + window.location.pathname;
                    url += "?id=" + Model.id;
                    prompt("Sharable and social media friendly URL:", url);
                }
                else {
                    alert("This model is not saved in the cloud. Please save the model before generating a URL.");
                }
            },
            generateHTML: function() {
                var html = window.open('', '_newtab').document;
                html.open();
                html.write(
                    '<!DOCTYPE HTML>'+
                    '<html><head>'+
                    '  <title>Anchor Model</title>' +
                    '  <link rel="stylesheet" type="text/css" href="documentation.css">'+
                    '</head><body>'+
                    '</body></html>'
                );
                html.close();
                var fragment = this.transform(Model.toXML(false), 'xml2documentation.xsl', html);
                // alert(new XMLSerializer().serializeToString(fragment));
                html.body.appendChild(fragment);
            }
        };

        var Settings = {
            // default values for some 'global' settings
            databaseTransform: 'SQLServer.xsl',
            calculations: 'simple',
            showMnemonics: true,
            showCardinalities: true,
            temporalization: 'mono',
            init: function() {
                document.getElementById('damping').value = ((1 - LayoutEngine.damping) * 100).toFixed(0);
                document.getElementById('longRangeEffect').value = (LayoutEngine.longRangeEffect * 100).toFixed(0);
                document.getElementById('fuzziness').value = (LayoutEngine.fuzziness * 100).toFixed(0);
                document.getElementById('normalDistance').value = LayoutEngine.normalDistance.toFixed(0);
                document.getElementById('stoppingVelocity').value = LayoutEngine.stoppingVelocity.toFixed(1);
                document.getElementById('minimumStartingVelocity').value = LayoutEngine.minimumStartingVelocity.toFixed(1);
                document.getElementById('maximumStartingVelocity').value = LayoutEngine.maximumStartingVelocity.toFixed(1);
                document.getElementById('partitionFactor').value = LayoutEngine.partitionFactor.toFixed(0);
                document.getElementById('stiffness').value = LayoutEngine.stiffness.toFixed(1);
                document.getElementById('temporalization').value = this.temporalization;
                document.getElementById('database').value = this.databaseTransform;
                document.getElementById('miniatureFramesBetweenRefresh').value = DrawingEngine.miniatureFramesBetweenRefresh;
                document.getElementById('calculations').value = this.calculations;
                document.getElementById('defaultCapsule').value = Defaults.encapsulation;
                document.getElementById('defaultIdentity').value = Defaults.identity;
                document.getElementById('defaultChangingRange').value = Defaults.changingRange;
                document.getElementById('metadataPrefix').value = Defaults.metadataPrefix;
                document.getElementById('metadataType').value = Defaults.metadataType;
                document.getElementById('restatability').checked = Defaults.restatability == 'true';
                document.getElementById('idempotency').checked = Defaults.idempotency == 'true';
                document.getElementById('metadataUsage').checked = Defaults.metadataUsage == 'true';
                document.getElementById('changingSuffix').value = Defaults.changingSuffix;
                document.getElementById('identitySuffix').value = Defaults.identitySuffix;
                document.getElementById('naming').value = Defaults.naming;
            },
            resetDefaults: function() {
                this.setDefaultCapsule('dbo');
                this.setDefaultIdentity('int');
                this.setDefaultChangingRange('datetime');
                this.setMetadataPrefix('Metadata');
                this.setMetadataType('int');
                this.setRestatability('true');
                this.setIdempotency('false');
                this.setMetadataUsage('true');
                this.setChangingSuffix('ChangedAt');
                this.setIdentitySuffix('ID');
                this.setRecordingRange('datetime');
                this.setRecordingSuffix('RecordedAt');
                this.setErasingSuffix('ErasedAt');
                this.setPartitioning('false');
                this.setEntityIntegrity('true');
                this.setTemporalization('mono');
                this.setDatabase('SQLServer.xsl');
                this.setNaming('improved');
                this.init();
            },
            resetSettings: function() {
                this.setDamping(4);
                this.setLongRangeEffect(25);
                this.setFuzziness(10);
                this.setNormalDistance(30);
                this.setStoppingVelocity(0.1);
                this.setMinimumStartingVelocity(1);
                this.setMaximumStartingVelocity(5);
                this.setPartitionFactor(8);
                this.setStiffness(6);
                this.setMiniRate(50);
                this.setCalculations('simple');
                Knot.mass = 1;
                Knot.charge = 1;
                Anchor.mass = 1;
                Anchor.charge = 1;
                Attribute.mass = 1;
                Attribute.charge = 1;
                Tie.mass = 1;
                Tie.charge = 1;
                Edge.mass = 1;
                Edge.charge = 1;
                this.init();
            },
            storeSettings: function(storage) {
                storage.setItem("damping", (1 - LayoutEngine.damping) * 100);
                storage.setItem("longRangeEffect", LayoutEngine.longRangeEffect * 100);
                storage.setItem("fuzziness", LayoutEngine.fuzziness * 100);
                storage.setItem("normalDistance", LayoutEngine.normalDistance);
                storage.setItem("stoppingVelocity", LayoutEngine.stoppingVelocity);
                storage.setItem("minimumStartingVelocity", LayoutEngine.minimumStartingVelocity);
                storage.setItem("maximumStartingVelocity", LayoutEngine.maximumStartingVelocity);
                storage.setItem("partitionFactor", LayoutEngine.partitionFactor);
                storage.setItem("stiffness", LayoutEngine.stiffness);
                storage.setItem("temporalization", this.temporalization);
                storage.setItem("database", this.databaseTransform);
                storage.setItem("miniatureFramesBetweenRefresh", DrawingEngine.miniatureFramesBetweenRefresh);
                storage.setItem("calculations", this.calculations);
                storage.setItem("defaultCapsule", Defaults.encapsulation);
                storage.setItem("defaultIdentity", Defaults.identity);
                storage.setItem("defaultChangingRange", Defaults.changingRange);
                storage.setItem("metadataPrefix", Defaults.metadataPrefix);
                storage.setItem("metadataType", Defaults.metadataType);
                storage.setItem("metadataUsage", Defaults.metadataUsage);
                storage.setItem("restatability", Defaults.restatability);
                storage.setItem("idempotency", Defaults.idempotency);
                storage.setItem("changingSuffix", Defaults.changingSuffix);
                storage.setItem("identitySuffix", Defaults.identitySuffix);
                storage.setItem("recordingRange", Defaults.recordingRange);
                storage.setItem("recordingSuffix", Defaults.recordingSuffix);
                storage.setItem("erasingSuffix", Defaults.erasingSuffix);
                storage.setItem("partitioning", Defaults.partitioning);
                storage.setItem("entityIntegrity", Defaults.entityIntegrity);
                storage.setItem("naming", Defaults.naming);
                storage.setItem("knotMass", Knot.mass);
                storage.setItem("knotCharge", Knot.charge);
                storage.setItem("anchorMass", Anchor.mass);
                storage.setItem("anchorCharge", Anchor.charge);
                storage.setItem("attributeMass", Attribute.mass);
                storage.setItem("attributeCharge", Attribute.charge);
                storage.setItem("tieMass", Tie.mass);
                storage.setItem("tieCharge", Tie.charge);
                storage.setItem("edgeMass", Edge.mass);
                storage.setItem("edgeCharge", Edge.charge);
            },
            loadSettings: function(storage) {
                this.setDamping(storage.getItem('damping') || 4);
                this.setLongRangeEffect(storage.getItem('longRangeEffect') || 25);
                this.setFuzziness(storage.getItem('fuzziness') || 10);
                this.setNormalDistance(storage.getItem('normalDistance') || 30);
                this.setStoppingVelocity(storage.getItem('stoppingVelocity') || 0.1);
                this.setMinimumStartingVelocity(storage.getItem('minimumStartingVelocity') || 1);
                this.setMaximumStartingVelocity(storage.getItem('maximumStartingVelocity') || 5);
                this.setPartitionFactor(storage.getItem('partitionFactor') || 8);
                this.setStiffness(storage.getItem('stiffness') || 6);
                this.setTemporalization(storage.getItem('temporalization') || 'mono');
                this.setDatabase(storage.getItem('database') || 'SQLServer.xsl');
                this.setMiniRate(storage.getItem('miniatureFramesBetweenRefresh') || 50);
                this.setCalculations(storage.getItem('calculations') || 'simple');
                this.setDefaultCapsule(storage.getItem('defaultCapsule') || Defaults.encapsulation);
                this.setDefaultIdentity(storage.getItem('defaultIdentity') || Defaults.identity);
                this.setDefaultChangingRange(storage.getItem('defaultChangingRange') || Defaults.changingRange);
                this.setMetadataPrefix(storage.getItem('metadataPrefix') || Defaults.metadataPrefix);
                this.setMetadataType(storage.getItem('metadataType') || Defaults.metadataType);
                this.setMetadataUsage(storage.getItem('metadataUsage') || Defaults.metadataUsage);
                this.setChangingSuffix(storage.getItem('changingSuffix') || Defaults.changingSuffix);
                this.setIdentitySuffix(storage.getItem('identitySuffix') || Defaults.identitySuffix);
                this.setRecordingRange(storage.getItem('recordingRange') || Defaults.recordingRange);
                this.setRecordingSuffix(storage.getItem('recordingSuffix') || Defaults.recordingSuffix);
                this.setErasingSuffix(storage.getItem('erasingSuffix') || Defaults.erasingSuffix);
                this.setPartitioning(storage.getItem('partitioning') || Defaults.partitioning);
                this.setEntityIntegrity(storage.getItem('entityIntegrity') || Defaults.entityIntegrity);
                this.setRestatability(storage.getItem('restatability') || Defaults.restatability);
                this.setIdempotency(storage.getItem('idempotency') || Defaults.idempotency);
                this.setNaming(storage.getItem('naming') || Defaults.naming);
                Knot.mass = 1 * storage.getItem('knotMass') || 1;
                Knot.charge = 1 * storage.getItem('knotCharge') || 1;
                Anchor.mass = 1 * storage.getItem('anchorMass') || 1;
                Anchor.charge = 1 * storage.getItem('anchorCharge') || 1;
                Attribute.mass = 1 * storage.getItem('attributeMass') || 1;
                Attribute.charge = 1 * storage.getItem('attributeCharge') || 1;
                Tie.mass = 1 * storage.getItem('tieMass') || 1;
                Tie.charge = 1 * storage.getItem('tieCharge') || 1;
                Edge.mass = 1 * storage.getItem('edgeMass') || 1;
                Edge.charge = 1 * storage.getItem('edgeCharge') || 1;
                this.init();
            },
            setRecordingRange: function(value) {
                Defaults.recordingRange = value;
            },
            setRecordingSuffix: function(value) {
                Defaults.recordingSuffix = value;
            },
            setErasingSuffix: function(value) {
                Defaults.erasingSuffix = value;
            },
            setPartitioning: function(value) {
                Defaults.partitioning = value;
            },
            setEntityIntegrity: function(value) {
                Defaults.entityIntegrity = value;
            },
            setNaming: function(value) {
                Defaults.naming = value;
            },
            recordingRange: null,
            recordingSuffix: null,
            erasingSuffix: null,
            partitioning: null,
            entityIntegrity: null,
            setTemporalization: function(value) {
                var listOfDefaults = document.getElementById('listOfDefaults');
                var tempoItem = document.getElementById('tempoItem');
                if(value == 'bi') {
                    if(!this.recordingRange) {
                        this.recordingRange = document.createElement('li');
                        var recordingRangeInput = document.createElement('input');
                        recordingRangeInput.setAttribute('type', 'text');
                        recordingRangeInput.setAttribute('class', 'inputDefaults');
                        this.recordingRange.setAttribute('title',
                                "The recording time (corrections) 'data type' used throughout the implementation."
                        );
                        recordingRangeInput.value = Defaults.recordingRange;
                        recordingRangeInput.addEventListener('blur', function() {
                            Settings.setRecordingRange(this.value);
                        }, false);
                        this.recordingRange.appendChild(recordingRangeInput);
                        this.recordingRange.appendChild(document.createTextNode(' Recording time range'));
                        listOfDefaults.insertBefore(this.recordingRange, tempoItem);
                    }
                    if(!this.recordingSuffix) {
                        this.recordingSuffix = document.createElement('li');
                        var recordingSuffixInput = document.createElement('input');
                        recordingSuffixInput.setAttribute('type', 'text');
                        recordingSuffixInput.setAttribute('class', 'inputDefaults');
                        this.recordingSuffix.setAttribute('title',
                                "The suffix used for the column storing the start of a recording time period."
                        );
                        recordingSuffixInput.value = Defaults.recordingSuffix;
                        recordingSuffixInput.addEventListener('blur', function() {
                            Settings.setRecordingSuffix(this.value);
                        }, false);
                        this.recordingSuffix.appendChild(recordingSuffixInput);
                        this.recordingSuffix.appendChild(document.createTextNode(' Recording suffix'));
                        listOfDefaults.insertBefore(this.recordingSuffix, tempoItem);
                    }
                    if(!this.erasingSuffix) {
                        this.erasingSuffix = document.createElement('li');
                        var erasingSuffixInput = document.createElement('input');
                        erasingSuffixInput.setAttribute('type', 'text');
                        erasingSuffixInput.setAttribute('class', 'inputDefaults');
                        this.erasingSuffix.setAttribute('title',
                                "The suffix used for the column storing the end of a recording time period."
                        );
                        erasingSuffixInput.value = Defaults.erasingSuffix;
                        erasingSuffixInput.addEventListener('blur', function() {
                            Settings.setErasingSuffix(this.value);
                        }, false);
                        this.erasingSuffix.appendChild(erasingSuffixInput);
                        this.erasingSuffix.appendChild(document.createTextNode(' Erasing suffix'));
                        listOfDefaults.insertBefore(this.erasingSuffix, tempoItem);
                    }
                    if(!this.entityIntegrity) {
                        this.entityIntegrity = document.createElement('li');
                        var entityIntegrityInput = document.createElement('input');
                        entityIntegrityInput.setAttribute('type', 'checkbox');
                        entityIntegrityInput.setAttribute('class', 'inputDefaults');
                        this.entityIntegrity.setAttribute('title',
                                "Entity integrity adds constraints ensuring that no temporal duplicates " +
                                        "can co-exist for the same entity and version, that no negative recording " +
                                        "time intervals can be stored, and that there are no overlapping intervals " +
                                        "with respect to recording time."
                        );
                        entityIntegrityInput.checked = Defaults.entityIntegrity == 'true';
                        entityIntegrityInput.addEventListener('change', function() {
                            Settings.setEntityIntegrity(this.checked ? 'true' : 'false');
                        }, false);
                        this.entityIntegrity.appendChild(entityIntegrityInput);
                        this.entityIntegrity.appendChild(document.createTextNode(' Ensure entity integrity'));
                        listOfDefaults.insertBefore(this.entityIntegrity, tempoItem);
                    }
                    if(!this.partitioning) {
                        this.partitioning = document.createElement('li');
                        var partitioningInput = document.createElement('input');
                        partitioningInput.setAttribute('type', 'checkbox');
                        partitioningInput.setAttribute('class', 'inputDefaults');
                        this.partitioning.setAttribute('title',
                                "Partitioning will put currently recorded information in a separate partition " +
                                        "from erased information, greatly speeding up querying in the bitemporal implementation."
                        );
                        partitioningInput.checked = Defaults.partitioning == 'true';
                        partitioningInput.addEventListener('change', function() {
                            Settings.setPartitioning(this.checked ? 'true' : 'false');
                        }, false);
                        this.partitioning.appendChild(partitioningInput);
                        this.partitioning.appendChild(document.createTextNode(' Use partitioning'));
                        listOfDefaults.insertBefore(this.partitioning, tempoItem);
                    }
                }
                else {
                    if(this.recordingRange) listOfDefaults.removeChild(this.recordingRange);
                    this.recordingRange = null;
                    if(this.recordingSuffix) listOfDefaults.removeChild(this.recordingSuffix);
                    this.recordingSuffix = null;
                    if(this.erasingSuffix) listOfDefaults.removeChild(this.erasingSuffix);
                    this.erasingSuffix = null;
                    if(this.entityIntegrity) listOfDefaults.removeChild(this.entityIntegrity);
                    this.entityIntegrity = null;
                    if(this.partitioning) listOfDefaults.removeChild(this.partitioning);
                    this.partitioning = null;
                }
                this.temporalization = value;
            },
            setMetadataPrefix: function(value) {
                Defaults.metadataPrefix = value;
            },
            setMetadataType: function(value) {
                Defaults.metadataType = value;
            },
            setMetadataUsage: function(value) {
                Defaults.metadataUsage = value;
            },
            setRestatability: function(value) {
                Defaults.restatability = value;
            },
            setIdempotency: function(value) {
                Defaults.idempotency = value;
            },
            setChangingSuffix: function(value) {
                Defaults.changingSuffix = value;
            },
            setIdentitySuffix: function(value) {
                Defaults.identitySuffix = value;
            },
            setDefaultCapsule: function(value) {
                Defaults.encapsulation = value;
            },
            setDefaultIdentity: function(value) {
                Defaults.identity = value;
            },
            setDefaultChangingRange: function(value) {
                Defaults.changingRange = value;
            },
            setDamping: function(value) {
                LayoutEngine.damping = (100 - value)/100;
                LayoutEngine.init();
            },
            setLongRangeEffect: function(value) {
                LayoutEngine.longRangeEffect = value/100;
                LayoutEngine.init();
            },
            setFuzziness: function(value) {
                LayoutEngine.fuzziness = value/100;
                LayoutEngine.init();
            },
            setNormalDistance: function(value) {
                LayoutEngine.normalDistance = 1 * value;
                LayoutEngine.init();
            },
            setStoppingVelocity: function(value) {
                LayoutEngine.stoppingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMinimumStartingVelocity: function(value) {
                LayoutEngine.minimumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMaximumStartingVelocity: function(value) {
                LayoutEngine.maximumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setPartitionFactor: function(value) {
                LayoutEngine.partitionFactor = 1 * value;
                LayoutEngine.init();
            },
            setStiffness: function(value) {
                LayoutEngine.stiffness = 1 * value;
                LayoutEngine.init();
            },
            setDatabase: function(value) {
                this.databaseTransform = value;
            },
            setMiniRate: function(value) {
                DrawingEngine.miniatureFramesBetweenRefresh = 1 * value;
            },
            toggleDebug: function () {
                DEBUG = !DEBUG;
                DrawingEngine.start(false);
            },
            knotMass: null,
            knotCharge: null,
            anchorMass: null,
            anchorCharge: null,
            attributeMass: null,
            attributeCharge: null,
            tieMass: null,
            tieCharge: null,
            edgeMass: null,
            edgeCharge: null,
            setCalculations: function(value) {
                var listOfSettings = document.getElementById('listOfSettings');
                var calcsItem = document.getElementById('calcsItem');
                if(value == 'simple') {
                    LayoutEngine.layout = LayoutEngine.simpleLayout;
                    if(this.knotMass) listOfSettings.removeChild(this.knotMass);
                    if(this.knotCharge) listOfSettings.removeChild(this.knotCharge);
                    if(this.anchorMass) listOfSettings.removeChild(this.anchorMass);
                    if(this.anchorCharge) listOfSettings.removeChild(this.anchorCharge);
                    if(this.attributeMass) listOfSettings.removeChild(this.attributeMass);
                    if(this.attributeCharge) listOfSettings.removeChild(this.attributeCharge);
                    if(this.tieMass) listOfSettings.removeChild(this.tieMass);
                    if(this.tieCharge) listOfSettings.removeChild(this.tieCharge);
                    if(this.edgeMass) listOfSettings.removeChild(this.edgeMass);
                    if(this.edgeCharge) listOfSettings.removeChild(this.edgeCharge);
                    this.knotMass = null;
                    this.knotCharge = null;
                    this.anchorMass = null;
                    this.anchorCharge = null;
                    this.attributeMass = null;
                    this.attributeCharge = null;
                    this.tieMass = null;
                    this.tieCharge = null;
                    this.edgeMass = null;
                    this.edgeCharge = null;
                }
                else if (value == 'complex') {
                    LayoutEngine.layout = LayoutEngine.complexLayout;
                    this.knotMass = document.createElement('li');
                    this.knotCharge = document.createElement('li');
                    this.anchorMass = document.createElement('li');
                    this.anchorCharge = document.createElement('li');
                    this.attributeMass = document.createElement('li');
                    this.attributeCharge = document.createElement('li');
                    this.tieMass = document.createElement('li');
                    this.tieCharge = document.createElement('li');
                    this.edgeMass = document.createElement('li');
                    this.edgeCharge = document.createElement('li');
                    var knotMassInput = document.createElement('input');
                    var knotChargeInput = document.createElement('input');
                    var anchorMassInput = document.createElement('input');
                    var anchorChargeInput = document.createElement('input');
                    var attributeMassInput = document.createElement('input');
                    var attributeChargeInput = document.createElement('input');
                    var tieMassInput = document.createElement('input');
                    var tieChargeInput = document.createElement('input');
                    var edgeMassInput = document.createElement('input');
                    var edgeChargeInput = document.createElement('input');
                    knotMassInput.setAttribute('type', 'number');
                    knotChargeInput.setAttribute('type', 'number');
                    anchorMassInput.setAttribute('type', 'number');
                    anchorChargeInput.setAttribute('type', 'number');
                    attributeMassInput.setAttribute('type', 'number');
                    attributeChargeInput.setAttribute('type', 'number');
                    tieMassInput.setAttribute('type', 'number');
                    tieChargeInput.setAttribute('type', 'number');
                    edgeMassInput.setAttribute('type', 'number');
                    edgeChargeInput.setAttribute('type', 'number');
                    knotMassInput.setAttribute('step', '0.1');
                    knotChargeInput.setAttribute('step', '0.1');
                    anchorMassInput.setAttribute('step', '0.1');
                    anchorChargeInput.setAttribute('step', '0.1');
                    attributeMassInput.setAttribute('step', '0.1');
                    attributeChargeInput.setAttribute('step', '0.1');
                    tieMassInput.setAttribute('step', '0.1');
                    tieChargeInput.setAttribute('step', '0.1');
                    edgeMassInput.setAttribute('step', '0.1');
                    edgeChargeInput.setAttribute('step', '0.1');
                    knotMassInput.value = Knot.mass;
                    knotChargeInput.value = Knot.charge;
                    anchorMassInput.value = Anchor.mass;
                    anchorChargeInput.value = Anchor.charge;
                    attributeMassInput.value = Attribute.mass;
                    attributeChargeInput.value = Attribute.charge;
                    tieMassInput.value = Tie.mass;
                    tieChargeInput.value = Tie.charge;
                    edgeMassInput.value = Edge.mass;
                    edgeChargeInput.value = Edge.charge;
                    knotMassInput.addEventListener('blur', function() { Knot.mass = 1 * this.value; }, false);
                    knotChargeInput.addEventListener('blur', function() { Knot.charge = 1 * this.value; }, false);
                    anchorMassInput.addEventListener('blur', function() { Anchor.mass = 1 * this.value; }, false);
                    anchorChargeInput.addEventListener('blur', function() { Anchor.charge = 1 * this.value; }, false);
                    attributeMassInput.addEventListener('blur', function() { Attribute.mass = 1 * this.value; }, false);
                    attributeChargeInput.addEventListener('blur', function() { Attribute.charge = 1 * this.value; }, false);
                    tieMassInput.addEventListener('blur', function() { Tie.mass = 1 * this.value; }, false);
                    tieChargeInput.addEventListener('blur', function() { Tie.charge = 1 * this.value; }, false);
                    edgeMassInput.addEventListener('blur', function() { Edge.mass = 1 * this.value; }, false);
                    edgeChargeInput.addEventListener('blur', function() { Edge.charge = 1 * this.value; }, false);
                    this.knotMass.appendChild(knotMassInput);
                    this.knotCharge.appendChild(knotChargeInput);
                    this.anchorMass.appendChild(anchorMassInput);
                    this.anchorCharge.appendChild(anchorChargeInput);
                    this.attributeMass.appendChild(attributeMassInput);
                    this.attributeCharge.appendChild(attributeChargeInput);
                    this.tieMass.appendChild(tieMassInput);
                    this.tieCharge.appendChild(tieChargeInput);
                    this.edgeMass.appendChild(edgeMassInput);
                    this.edgeCharge.appendChild(edgeChargeInput);
                    this.knotMass.appendChild(document.createTextNode(' Knot mass'));
                    this.knotCharge.appendChild(document.createTextNode(' Knot charge'));
                    this.anchorMass.appendChild(document.createTextNode(' Anchor mass'));
                    this.anchorCharge.appendChild(document.createTextNode(' Anchor charge'));
                    this.attributeMass.appendChild(document.createTextNode(' Attribute mass'));
                    this.attributeCharge.appendChild(document.createTextNode(' Attribute charge'));
                    this.tieMass.appendChild(document.createTextNode(' Tie mass'));
                    this.tieCharge.appendChild(document.createTextNode(' Tie charge'));
                    this.edgeMass.appendChild(document.createTextNode(' Edge mass'));
                    this.edgeCharge.appendChild(document.createTextNode(' Edge charge'));
                    listOfSettings.insertBefore(this.edgeCharge, calcsItem);
                    listOfSettings.insertBefore(this.edgeMass, calcsItem);
                    listOfSettings.insertBefore(this.tieCharge, calcsItem);
                    listOfSettings.insertBefore(this.tieMass, calcsItem);
                    listOfSettings.insertBefore(this.attributeCharge, calcsItem);
                    listOfSettings.insertBefore(this.attributeMass, calcsItem);
                    listOfSettings.insertBefore(this.anchorCharge, calcsItem);
                    listOfSettings.insertBefore(this.anchorMass, calcsItem);
                    listOfSettings.insertBefore(this.knotCharge, calcsItem);
                    listOfSettings.insertBefore(this.knotMass, calcsItem);
                }
            }
        };

        var ControlButtons = {
            playPauseButton: null,
            nudgeButton: null,
            undoButton: null,
            redoButton: null,
            zoomInButton: null,
            zoomOutButton: null,
            zoomFactor: 1.75,
            init: function() {
                this.playPauseButton = document.getElementById('playpause');
                this.undoButton = document.getElementById('undo');
                this.redoButton = document.getElementById('redo');
                this.zoomInButton = document.getElementById('zoomin');
                this.zoomOutButton = document.getElementById('zoomout');

                // voodoo
                var self = this;

                this.playPauseButton.addEventListener('click', function(event) {
                    return self.togglePlayPause(event)
                }, false);
                this.undoButton.addEventListener('click', function(event) {
                    return self.undo(event)
                }, false);
                this.redoButton.addEventListener('click', function(event) {
                    return self.redo(event)
                }, false);
                this.zoomInButton.addEventListener('click', function(event) {
                    return self.zoomIn(event)
                }, false);
                this.zoomOutButton.addEventListener('click', function(event) {
                    return self.zoomOut(event)
                }, false);
            },
            togglePlayPause: function (event) {
                if(DrawingEngine.running) {
                    DrawingEngine.stop();
                }
                else if (LayoutEngine.equilibrium) {
                    this.invalidateLayout();
                }
                else {
                    DrawingEngine.start(false);
                }
            },
            setUndoLevels: function(numberOfLevels) {
                var undos = '';
                if(numberOfLevels)
                    undos = ' (' + numberOfLevels + ')';
                this.undoButton.firstChild.nodeValue = 'Undo' + undos;
            },
            setRedoLevels: function(numberOfLevels) {
                var redos = '';
                if(numberOfLevels)
                    redos = ' (' + numberOfLevels + ')';
                this.redoButton.firstChild.nodeValue = 'Redo' + redos;
            },
            undo: function() {
                Model.undoState();
                DrawingEngine.start(false);
            },
            redo: function() {
                Model.redoState();
                DrawingEngine.start(false);
            },
            setPlayState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Play';
                this.playPauseButton.className = 'pausing';
            },
            setPauseState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Pause';
                this.playPauseButton.className = 'playing';
            },
            invalidateLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    Model.visibleNodes[i].start();
                }
                DrawingEngine.start(true);
            },
            doZoom: function (zoom) {
                DrawingEngine.scale(zoom);
                var xx = window.innerWidth/2;
                var yy = window.innerHeight/2;
                DrawingEngine.translate(DrawingEngine.xContext(xx) - DrawingEngine.xContext(xx) * zoom,
                        DrawingEngine.yContext(yy) - DrawingEngine.yContext(yy) * zoom);
                DrawingEngine.start(false);
            },
            zoomIn: function (event) {
                this.doZoom(this.zoomFactor);
            },
            zoomOut: function (event) {
                this.doZoom(1/this.zoomFactor);
            }
        };

        // make sure our init function is called when the page is loaded
        window.onload = function() { try { init(this); } catch(e) { alert(e); throw e; } };

        // implementation of our init function
        function init(window) {
            // find any parameters passed in the url
            var gets = window.location.search.substring(1);
            var pair, pairs = gets.split('&');
            for(var i = 0; pair = pairs[i]; i++) {
              pair = pairs[i].split('=');
              PARAMETERS[pair[0]] = pair[1];
            }

            // assign event handlers to buttons
            ControlButtons.init();
            LayoutEngine.init();

            // set the global svg and graph variable
            SVG = document.getElementById("graph");

            // add layers to the SVG
            SVGLayer = new Layer(SVG);
            SVGLayer.addLayer('edges');
            SVGLayer.addLayer('nodes');
            SVGLayer.addLayer('names');
            SVGLayer.addLayer('viewport');
            SVGLayer.hide('names');

            // set up "global" event handlers
            SVG.addEventListener('mousewheel', EventHandler.zoom, false); // Safari and Chrome
            SVG.addEventListener('DOMMouseScroll', EventHandler.zoom, false); // Firefox
            SVG.addEventListener('mousedown', EventHandler.preparePanning, false); // Safari and Chrome

            // set up the miniature navigation
            NAV = document.getElementById("minigraph");

            // add layers to the NAV
            NAVLayer = new Layer(NAV);
            NAVLayer.addLayer('edges');
            NAVLayer.addLayer('nodes');
            NAVLayer.addLayer('viewport');


            var canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext;

            // get the canvas element
            canvas = document.getElementById('canvas');
            context = canvas.getContext('2d');

            // make this a full screen canvas, that can be resized

            shadowCanvas = document.getElementById('shadow');
            shadowContext = shadowCanvas.getContext('2d');


            miniatureCanvas = document.getElementById('miniature');
            miniatureContext = null; // miniatureCanvas.getContext('2d');

            DrawingEngine.init(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext);

            canvas.CanvasEventHandler = CanvasEventHandler;
            /*
            // attach the mousedown, mousemove and mouseup event listeners to the visible canvas
            canvas.addEventListener('mousedown', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousemove', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mouseup', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousewheel', CanvasEventHandler.handleEvent, false); // Safari and Chrome
            canvas.addEventListener('DOMMouseScroll', CanvasEventHandler.handleEvent, false); // Firefox
            */

            // setting a listener on the canvas did not work, so this is a workaround
            // window.onkeypress = CanvasEventHandler.handleEvent;
            /*
            miniatureCanvas.MiniatureEventHandler = MiniatureEventHandler;
            miniatureCanvas.addEventListener('mousedown', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mousemove', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mouseup', MiniatureEventHandler.handleEvent, false);
            */

            // load url or previous model, if any
            var model;
            if(PARAMETERS.id) {
                Actions.loadModelFromCloud(PARAMETERS.id, null, 'public', null, null);
            }
            else if(model = window.localStorage.getItem("model")) {
                Model.fromXML(new DOMParser().parseFromString(model, 'text/xml'));
                Model.id = window.localStorage.getItem("modelId");
                Model.name = window.localStorage.getItem("modelName");
                Model.scope = window.localStorage.getItem("modelScope");
                Model.keywords = window.localStorage.getItem("modelKeywords");
                Model.description = window.localStorage.getItem("modelDescription");
            }
            else
                Actions.loadFromURL('example.xml');

            Actions.checkCloudConnectionStatus(false);

            // set values in the settings input fields
            Settings.loadSettings(window.localStorage);

            // load previous scale and transform
            DrawingEngine.loadSettings(window.localStorage);
            DrawingEngine.start(true);
        }

        // make sure our exit function is called when the page is unloaded
        window.onbeforeunload = function() {
            if(ASKBEFOREUNLOAD)
                return "Are you absolutely sure you want to leave?\nAny unsaved changes will be lost!";
            else
                ASKBEFOREUNLOAD = true;
        };

        window.onunload = function() { try { exit(this); } catch(e) { alert(e); throw e; } };

        function exit(window) {
            window.localStorage.clear();
            if(Model.nodes.length)
                window.localStorage.setItem("model", new XMLSerializer().serializeToString(Model.toXML(false)));
            if(Model.id)
                window.localStorage.setItem("modelId", Model.id);
            if(Model.name)
                window.localStorage.setItem("modelName", Model.name);
            if(Model.scope)
                window.localStorage.setItem("modelScope", Model.scope);
            if(Model.keywords)
                window.localStorage.setItem("modelKeywords", Model.keywords);
            if(Model.description)
                window.localStorage.setItem("modelDescription", Model.description);
            Settings.storeSettings(window.localStorage);
            DrawingEngine.storeSettings(window.localStorage);
        }

        // -->
    </script>
</head>
<body>
    <canvas id="canvas" class="unselectable">
        <!-- this is the main drawing area -->
    </canvas>
    <canvas id="shadow" class="unselectable">
        <!-- we paint objects in "false" colors on this canvas and use that to identify them with mouse clicks -->
    </canvas>

    <svg id="graph"
         class="unselectable"
         xmlns="http://www.w3.org/2000/svg"
         version="1.1"
         xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs>
            <style type="text/css">
                .anchor {
                    fill:               #b55;
                }
                .tie {
                    fill:               #a8a8a8;
                }
                .tie_outline {
                    fill:               #fff;
                    stroke:             #a8a8a8;
                    stroke-width:       1.5px;
                }
                .attribute, .knot {
                    fill:               #fff;
                    stroke:             #f88;
                    stroke-width:       1.5px;
                }
                .edge, .cardinality {
                    fill:               none;
                    stroke:             #544;
                    stroke-width:       1px;
                }
                .highlight {
                    stroke:             #ede5e5;
                    stroke-width:       10px;
                    fill:               #fff;
                }
                .bubble {
                    fill:               #f9f8f7;
                    stroke:             none;
                }
                .fixation {
                    fill:               #000;
                }
                .label {
                    font-size:          8pt;
                    font-family:        "Open Sans", "Helvetica Neue", sans-serif;
                    font-weight:        normal;
                    text-anchor:        left;
                    dominant-baseline:  middle;
                    fill:               #000;
                }
                .bad {
                    fill:               #e00;
                }
                .end {
                    text-anchor:        end;
                }
            </style>
            <g id="knot">
                <rect class="knot" width="20" height="20" rx="5" ry="5" transform="translate(-10, -10)"/>
            </g>
            <g id="anchor">
                <rect class="anchor" width="20" height="20" transform="translate(-10, -10)"/>
            </g>
            <g id="highlight">
                <circle class="highlight" r="30"/>
            </g>
            <g id="tie">
                <rect class="tie" width="20" height="20" transform="rotate(45) translate(-10, -10)"/>
            </g>
            <g id="tie_historized">
                <rect class="tie_outline" width="22" height="22" transform="rotate(45) translate(-11, -11)"/>
                <rect class="tie" width="14" height="14" transform="rotate(45) translate(-7, -7)"/>
            </g>
            <g id="attribute">
                <circle class="attribute" r="10"/>
            </g>
            <g id="attribute_historized">
                <circle class="attribute" r="12"/>
                <circle class="attribute" r="7"/>
            </g>
            <g id="fixation">
                <rect class="fixation" width="2" height="2" transform="translate(-1, -1)"/>
            </g>
            <g id="bubble">
                <circle class="bubble" r="8"/>
            </g>
            <g id="one">
                <line class="cardinality" x1="0" y1="-3" x2="0" y2="3"/>
            </g>
            <g id="many">
                <line class="cardinality" x1="-3" y1="-3" x2="3" y2="-3"/>
                <line class="cardinality" x1="-3" y1="0" x2="3" y2="0"/>
                <line class="cardinality" x1="-3" y1="3" x2="3" y2="3"/>
            </g>
        </defs>
        <!-- layers are appended here -->
    </svg>

    <div id="header" class="unselectable">
        <div id="file" class="menu">File
            <ul class="submenu">
                <li title="Discards the current model and starts a new model with a minimal setup, a single anchor." onclick="Model.setupMinimal(true)">New model...</li>
                <li title="Load a publicly stored model from the Google Cloud connection." onclick="Actions.listModelsInCloud('public')">Load public model from cloud...</li>
                <li title="Load a privately stored model from the Google Cloud connection. Requires that you log in to your Google account." onclick="Actions.listModelsInCloud('private')">Load private model from cloud...</li>
                <li title="Save the current model in the Google Cloud, either publicly or privately. If it already exists you will be given the option to overwrite the old model." onclick="Actions.saveModelInCloud(true)">Save model in cloud...</li>
                <li><i>Load model from local file:</i></li>
                <li title="Load a model from an XML file accessible from your local computer."><input type="file" class="fileSelect" onchange="FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this);"/></li>
                <li title="Browser security currently prevents models from being saved to disk. While waiting for policies to relax, this will generate some text that can be cut and pasted instead." onclick="Actions.saveToDisk(new XMLSerializer().serializeToString(Model.toXML(false)))">Save model to local file...</li>
                <li title="Loads an example model based on a business managing actors that perform programs on different stages." onclick="Actions.loadFromURL('example.xml')">Load example model</li>
            </ul>
        </div>

        <div id="actions" class="menu">Layout
            <ul class="submenu">
                <li title="Toggle whether names should be visible in the modeler or not." onclick="Actions.toggleNames()">Toggle names</li>
                <li title="Toggle whether full names including mnemonics or short names excluding mnemonics should be used." onclick="Actions.toggleMnemonics()">Toggle mnemonics</li>
                <li title="Toggle style of the cardinalities in ties, dots or letters." onclick="Actions.toggleCardinalities()">Toggle cardinalities</li>
                <li title="Release all fixed nodes and fixate all released nodes." onclick="Actions.toggleFixation()">Toggle fixation</li>
                <li title="Release all fixed nodes." onclick="Actions.releaseAll()">Release all fixed</li>
                <li title="Hide attributes from anchors, and knots from both anchors and ties, in order to get a better overview of larger models." onclick="Actions.implodeAll()">Implode all</li>
                <li title="Unhide all hidden attributes and knots." onclick="Actions.explodeAll()">Explode all</li>
                <li title="Lost in your model? Resetting the view will center your model on screen and set the zoom back to its default value." onclick="Actions.resetZoom();Actions.centerModel()">Reset view</li>
                <li title="Having trouble finding a good layout? This will randomize the locations of all items and let the algorithms do the work." onclick="Actions.randomizeLayout()">Randomize layout</li>
            </ul>
        </div>

        <div id="generate" class="menu">Generate
            <ul class="submenu">
                <li title="Generate a portable and compact XML representation of your model, including information about the graphical layout." onclick="new CodePopover(Actions.transform(Model.toXML(false), 'xml2html.xsl', document), false)">XML code</li>
                <li title="Generate SQL code for implementation of a model in a relational database." onclick="new CodePopover(Actions.transform(Model.toXML(true), Settings.databaseTransform, document), true)">SQL code</li>
                <li title="Generate a URL for a public model that can be shared over social media or through email." onclick="Actions.generateURL()">URL for sharing</li>
                <li title="Generate an HTML legend that describes the items in your model." onclick="Actions.generateHTML()">HTML documentation</li>
                <li title="Generate a bitmap image of the view currently shown on screen." onclick="window.open(DrawingEngine.canvas.toDataURL('image/png'), '_newtab')">PNG screenshot</li>
                <li title="Generate a vector image of the entire model." onclick="window.open(Model.toSVGURL(), '_newtab')">SVG graphics</li>
                <li title="Generate the SVG code for a vector image of the entire model." onclick="new CodePopover(Actions.transform(SVG, 'xml2html.xsl', document), false)">SVG code</li>
            </ul>
        </div>

        <div id="controls">
            <div id="playpause">Pause</div>
            <div id="zoomin">Zoom+</div>
            <div id="zoomout">Zoom–</div>
            <div id="redo">Redo</div>
            <div id="undo">Undo</div>
        </div>

        <div id="search">
            <input id="searchFilter" type="text" placeholder=" search filter " title="Search the model for the given (sub)string." onfocus="Actions.stopKeyboardEvents()" onblur="Actions.populateSelector(document.getElementById('nodeSelector'), this.value)"/>
            <select id="nodeSelector" title="Focus model on the selected node." onmouseover="Actions.populateSelector(this, document.getElementById('searchFilter').value)" onchange="Actions.selectNode(this.value)">
                <option value="none" selected="selected">None selected</option>
            </select>
        </div>

        <div id="about" class="menu">Help
            <ul class="submenu">
                <li title="Takes you to a page containing a number of video tutorials explaining how to use the modeling tool." onclick="new URLPopover('http://www.anchormodeling.com/?page_id=186')">Tutorials</li>
                <li title="Shows a page with information about who coded the modeling tool, where it can be found, and the available keyboard shortcuts." onclick="new URLPopover('about.html')">About</li>
            </ul>
        </div>

        <div id="defaults" class="menu">Defaults
            <ul id="listOfDefaults" class="submenu">
                <li title="Selects the target database for the generated SQL code.">
                    <select id="database" onchange="Settings.setDatabase(this.value)">
                        <option value="SQLServer.xsl" selected="selected">Microsoft SQL Server</option>
                        <option value="Oracle.xsl">Oracle</option>
                    </select> Target database
                </li>
                <li title="Selects the version of the naming convention to use for the generated code.">
                    <select id="naming" onchange="Settings.setNaming(this.value)">
                        <option value="original">Original</option>
                        <option value="improved" selected="selected">Improved</option>
                    </select> Naming convention
                </li>
                <li title="The default changing time (versions) 'data type' for newly created and historized items."><input id="defaultChangingRange" class="inputDefaults" type="text" onblur="Settings.setDefaultChangingRange(this.value)"/> Changing time range</li>
                <li title="The suffix used for the columns that store changing time (versions)."><input id="changingSuffix" class="inputDefaults" type="text" onblur="Settings.setChangingSuffix(this.value)"/> Changing suffix</li>
                <li title="Selects if the generated code should be monotemporal (only changing time) or bitemporal (both changing and recording time)." id="tempoItem">
                    <select id="temporalization" onchange="Settings.setTemporalization(this.value)">
                        <option value="mono" selected="selected">Monotemporal</option>
                        <option value="bi">Bitemporal</option>
                    </select> Temporalization
                </li>
                <li title="Default for new items. Restatable items can store the exact same value for consecutive changing times. Unchecking this will introduce a constraint preventing restatements."><input id="restatability" class="inputDefaults" type="checkbox" onchange="Settings.setRestatability(this.checked ? 'true' : 'false')"/> Restatability</li>
                <li title="Default for new items. Idempotent items discard any attempt to insert or update a value that is identical to the latest one stored."><input id="idempotency" class="inputDefaults" type="checkbox" onchange="Settings.setIdempotency(this.checked ? 'true' : 'false')"/> Idempotency</li>
                <li title="Selects if the generated code should contain a metadata reference or not."><input id="metadataUsage" class="inputDefaults" type="checkbox" onchange="Settings.setMetadataUsage(this.checked ? 'true' : 'false')"/> Use metadata</li>
                <li title="The prefix used for the columns that store a metadata reference."><input id="metadataPrefix" class="inputDefaults" type="text" onblur="Settings.setMetadataPrefix(this.value)"/> Metadata prefix</li>
                <li title="The 'data type' of the metadata column."><input id="metadataType" class="inputDefaults" type="text" onblur="Settings.setMetadataType(this.value)"/> Metadata type</li>
                <li title="The default 'schema' to use for new items."><input id="defaultCapsule" class="inputDefaults" type="text" onblur="Settings.setDefaultCapsule(this.value)"/> Capsule</li>
                <li title="The default 'data type' to use for identity columns."><input id="defaultIdentity" class="inputDefaults" type="text" onblur="Settings.setDefaultIdentity(this.value)"/> Identity</li>
                <li title="The suffix used for the columns that store identities."><input id="identitySuffix" class="inputDefaults" type="text" onblur="Settings.setIdentitySuffix(this.value)"/> Identity suffix</li>
                <li title="Resets all settings in this menu to their default values." onclick="Settings.resetDefaults()">Reset to default values</li>
            </ul>
        </div>

        <!-- TODO: focus gets "stuck" on the input fields below sometimes, annoying! -->
        <div id="settings" title="Expert settings" class="menu">Settings
            <ul id="listOfSettings" class="submenu">
                <li title="Damping can be likened to friction and is needed in order to slow down the movement of the nodes."><input id="damping" type="number" min="0" max="99" step="1" onblur="Settings.setDamping(this.value)"/> % Damping</li>
                <li title="The normal distance is the distance in pixels two nodes would be separated by if they were the only nodes in the graph."><input id="normalDistance" type="number" min="10" max="90" step="5" onblur="Settings.setNormalDistance(this.value)"/> px Normal distance</li>
                <li title="Any node whose velocity is smaller than this number is assumed to have stopped."><input id="stoppingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setStoppingVelocity(this.value)"/> px/s Stopping velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a small graph."><input id="minimumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMinimumStartingVelocity(this.value)"/> px/s Minimum starting velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a large graph."><input id="maximumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMaximumStartingVelocity(this.value)"/> px/s Maximum starting velocity</li>
                <li title="The size of space partitions in number of normal distances."><input id="partitionFactor" type="number" min="0" max="10" step="1" onblur="Settings.setPartitionFactor(this.value)"/> Partition size</li>
                <li title="The 'fuzziness' within which the size of the partitions are altered."><input id="fuzziness" type="number" min="0" max="100" step="1" onblur="Settings.setFuzziness(this.value)"/> % Fuzziness</li>
                <li title="The effect of the force from other partitions on nodes in the current partition."><input id="longRangeEffect" type="number" min="0" max="100" step="1" onblur="Settings.setLongRangeEffect(this.value)"/> % Long range effect</li>
                <li title="The stiffness of the edges control whether they behave like rubber bands or steel wires."><input id="stiffness" type="number" min="1" max="20" step="0.5" onblur="Settings.setStiffness(this.value)"/> Edge stiffness factor</li>
                <li title="The number of frame redraws needed in the large canvas to trigger a redraw of the miniature."><input id="miniatureFramesBetweenRefresh" type="number" min="1" max="99" step="1" onblur="Settings.setMiniRate(this.value)"/> Miniature refresh interval</li>
                <li title="Switching on advanced calculations lets you set more properties of nodes and edges, but at the cost of some performance." id="calcsItem">
                    <select id="calculations" onchange="Settings.setCalculations(this.value)">
                        <option value="simple" selected="selected">Simplified</option>
                        <option value="complex">Adjustable</option>
                    </select> &nbsp;Calculations
                </li>
                <li title="Resets all settings in this menu to their default values." onclick="Settings.resetSettings()">Reset settings to default values</li>
                <li title="In debug mode force vectors will be drawn in the graph." onclick="Settings.toggleDebug()">Toggle debug</li>
            </ul>
        </div>
    </div>

    <!-- Removed due to memory issues
    <canvas id="maxiature" class="unselectable">
    </canvas>
    -->
    <!--
    <canvas id="miniature" class="unselectable" title="This is the Navigation Window. It will always show the whole model with the current viewport shown by a red outline. Click and drag to move the viewport.">
    </canvas>
    -->

    <!-- shows a navigatable miniature of the model -->
    <div id="miniature">
        <svg id="minigraph"
             class="unselectable"
             xmlns="http://www.w3.org/2000/svg"
             version="1.1"
             xmlns:xlink="http://www.w3.org/1999/xlink"
             viewBox="0 0 1 1"
             preserveAspectRatio="xMinYMin slice"/>
        <!-- unfortunately using a "use" element here pointing to the original graph slows everything to a crawl -->
    </div>

    <div id="cloud" class="unselectable" onclick="Actions.checkCloudConnectionStatus(true)">
        <!-- filled dynamically -->
    </div>
    <div id="model" class="unselectable">
        <!-- filled dynamically -->
    </div>
</body>
</html>