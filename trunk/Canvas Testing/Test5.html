<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Test 3</title>
    <script type="text/javascript">
        <!--
        // frames per second - set low when debugging
        const FPS = 1000;

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 50,
            // 3 percent damping (simulated friction)
            damping: 0.97,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // starting velocity is a whole pixel
            startingVelocity: 1,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.000008,
            // adjusts the size of the influence square by this factor
            influenceConstant: 3,
            // used to store the corners of the influence square
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,
            // when the layout has reached equilibrium
            equilibrium: true,

            // for some reason Math.abs is slower than this
            absolute: function(value) {
                return value < 0 ? -value : value;
            },

            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },

            // use the taxi cab metric for measuring distances
            distance: function(node, otherNode) {
                return this.absolute(otherNode.xPos - node.xPos) + this.absolute(otherNode.yPos - node.yPos);
            },
            // x component of the repelling force formula
            xRepelling: function(node, otherNode) {
                return (node.xPos - otherNode.xPos)/this.square(this.distance(node, otherNode));
            },

            // y component of the repelling force formula
            yRepelling: function(node, otherNode) {
                return (node.yPos - otherNode.yPos)/this.square(this.distance(node, otherNode));
            },

            // x component of the attracting force formula
            xAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPos - node.xPos) * this.distance(node, otherNode);
            },

            // y component of the attracting force formula
            yAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPos - node.yPos) * this.distance(node, otherNode);
            },

            findSquareCorners: function(node) {
                this.xMin = node.xPos - this.influenceConstant * this.normalDistance;
                this.xMax = node.xPos + this.influenceConstant * this.normalDistance;
                this.yMin = node.yPos - this.influenceConstant * this.normalDistance;
                this.yMax = node.yPos + this.influenceConstant * this.normalDistance;
            },

            withinSquare: function(otherNode) {
                return  otherNode.xPos >= this.xMin &&
                        otherNode.xPos <= this.xMax &&
                        otherNode.yPos >= this.yMin &&
                        otherNode.yPos <= this.yMax;
            },

            // calculate all forces and change the velocity and position of the node
            layout: function(nodes, edges) {
                var node, otherNode, nodeEdges, i, j;
                this.equilibrium = true;
                for(i = 0; node = nodes[i]; i++) {
                    this.findSquareCorners(node);
                    for(j = 0; otherNode = nodes[j]; j++) {
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode)) {
                                node.xVel += this.xRepelling(node, otherNode);
                                node.yVel += this.yRepelling(node, otherNode);
                            }
                        }
                    }
                    nodeEdges = edges[node];
                    // for all edges, add the attracting velocity
                    for(j = 0; otherNode = nodeEdges[j]; j++) {
                        node.xVel += this.xAttracting(node, otherNode);
                        node.yVel += this.yAttracting(node, otherNode);
                    }
                    // apply damping
                    node.xVel *= this.damping;
                    node.yVel *= this.damping;
                    // check to see if the node has stopped/started moving
                    if(this.absolute(node.xVel) + this.absolute(node.yVel) <= this.stoppingVelocity)
                        node.moving = false;
                    if(this.absolute(node.xVel) + this.absolute(node.yVel) >= this.startingVelocity)
                        node.moving = true;
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.fixed) {
                        this.equilibrium = false;
                        node.xPos += node.xVel;
                        node.yPos += node.yVel;
                    }
                }
            }
        };

        var UniqueColor = {
            // note that #000000 is reserved and never assigned
            red: 0,
            green: 0,
            blue: 0,
            formatColor: function(red, green, blue) {
                return '#' +
                        ('0' + red.toString(16)).slice(-2) +
                        ('0' + green.toString(16)).slice(-2) +
                        ('0' + blue.toString(16)).slice(-2);
            },
            getUniqueColor: function() {
                if(this.red != 255) {
                    if(this.green != 255) {
                        if(this.blue != 255) {
                            this.blue++;
                            return this.formatColor(this.red, this.green, this.blue);
                        }
                        this.blue = 0;
                        this.green++;
                        return this.formatColor(this.red, this.green, this.blue);
                    }
                    this.blue = 0;
                    this.green = 0;
                    this.red++;
                    return this.formatColor(this.red, this.green, this.blue);
                }
                this.blue = 0;
                this.green = 0;
                this.red = 0;
                return this.getUniqueColor();
            }
        };

        var Model = {
            nodes: null,
            shadows: null,
            edges: null
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            canvas: null,
            shadowCanvas: null,
            context: null,
            shadowContext: null,
            running: false,
            init: function(canvas, shadowCanvas, context, shadowContext) {
                this.canvas = canvas;
                this.shadowCanvas = shadowCanvas;
                this.context = context;
                this.shadowContext = shadowContext;
            },
            getNodeAt: function(x, y) {
                var data = this.shadowContext.getImageData(x, y, 1, 1).data;
                return Model.shadows[UniqueColor.formatColor(data[0], data[1], data[2])];
            },
            start: function() {
                if(!this.running) {
                    this.running = true;
                    this.drawId = setInterval(function() { DrawingEngine.draw(); }, 1000 / FPS);
                }
            },
            draw: function() {
                // layout nodes
                LayoutEngine.layout(Model.nodes, Model.edges);

                // clear the visible context
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // clear the shadow context
                this.shadowContext.fillStyle = '#000000';
                this.shadowContext.fillRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);

                var i, node, otherNode, nodeEdges;

                // draw all edges on the visible context
                this.context.strokeStyle = '#000000';
                for(i = 0; node = Model.nodes[i]; i++) {
                    nodeEdges = Model.edges[node];
                    // for all edges, add the attracting velocity
                    for(var j = 0; otherNode = nodeEdges[j]; j++) {
                        this.context.beginPath();
                        this.context.moveTo(node.xPos, node.yPos);
                        this.context.lineTo(otherNode.xPos, otherNode.yPos);
                        this.context.stroke();
                    }
                }

                // draw all nodes on the visible and shadow context
                for(i = 0; node = Model.nodes[i]; i++) {
                    node.draw(this.context);
                    node.drawShadow(this.shadowContext);
                }


                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    clearInterval(this.drawId);
                    this.running = false;
                }
            }
        };

        var ResizeHandler = {
            resizeCanvas: function(canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        };

        var MouseHandler = {
            dragging: false,
            draggedNode: null,
            mousedown: function(event) {
                this.draggedNode = DrawingEngine.getNodeAt(event._x, event._y);
                this.draggedNode.fixed = true;
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    this.draggedNode.xPos = event._x;
                    this.draggedNode.yPos = event._y;
                    this.draggedNode.moving = true;
                    DrawingEngine.start();
                }
            },
            mouseup: function(event) {
                if (this.dragging) {
                    this.dragging = false;
                }
            },
            handleEvent: function(event) {
                event._x = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - event.srcElement.offsetLeft;
                event._y = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - event.srcElement.offsetTop;

                if(this.mouseHandler[event.type]) {
                    // note that "this" refers to the object on which we attached the event handler
                    this.mouseHandler[event.type](event);
                }
            }
        };



        function Node(x, y, name) {
            this.name = name;
            this.xPos = x;
            this.yPos = y;
            this.xVel = 0;
            this.yVel = 0;
            this.moving = true;
            this.fixed = false;
            this.shadowColor = UniqueColor.getUniqueColor();
        }
        // override toString in order to provide a unique identifier to be used when emulating hash maps
        Node.prototype.toString = function() {
            return this.name.toString();
        };
        // this is how a node draws itself on the visible context
        Node.prototype.draw = function(context) {
            context.beginPath();
            context.arc(this.xPos, this.yPos, 8, 0, 2*Math.PI, false);
            if(this.moving && !this.fixed)
                context.fillStyle = '#55bb55';
            else
                context.fillStyle = '#bb5555';
            context.fill();
            if(this.fixed) {
                context.strokeStyle = '#000000';
                context.stroke();
            }
        };
        // this is how a node draws itself on the shadow context
        Node.prototype.drawShadow = function(context) {
            context.beginPath();
            context.arc(this.xPos, this.yPos, 8, 0, 2*Math.PI, false);
            context.fillStyle = this.shadowColor;
            context.fill();
        };

        // make sure our init function is called when the page is loaded
        window.onload = init;

        // implementation of our init function
        function init() {
            // create some nodes (that do not overlap)
            var nodes = [
                new Node(200, 300, "A1"),
                new Node(300, 200, "A1B1"),
                new Node(250, 300, "A1B2"),
                new Node(300, 250, "A1B3"),
                new Node(400, 300, "A2"),
                new Node(300, 400, "A2B1"),
                new Node(450, 300, "A2B2"),
                new Node(300, 450, "A2B3"),
                new Node(300, 500, "A2B4"),
                new Node(400, 350, "A3"),
                new Node(350, 400, "A3B1"),
                new Node(450, 350, "A3B2"),
                new Node(350, 450, "A3B3"),
                new Node(350, 500, "A3B4"),
                new Node(350, 550, "A3B5"),
                new Node(350, 600, "A3B5C1"),
                new Node(350, 650, "A3B5C2")
            ];

            Model.nodes = nodes;

            var i, node, shadows = {};
            for(i = 0; node = nodes[i]; i++)
                shadows[node.shadowColor] = node;

            Model.shadows = shadows;

            // experimenting with fixed nodes
            nodes[7].fixed = true;

            // set the edges (as arrays of nodes) of every node
            var edges = {};
            edges[nodes[0]] = [nodes[1], nodes[2], nodes[3], nodes[4], nodes[9]];
            edges[nodes[1]] = [nodes[0]];
            edges[nodes[2]] = [nodes[0]];
            edges[nodes[3]] = [nodes[0]];
            edges[nodes[4]] = [nodes[0], nodes[5], nodes[6], nodes[7], nodes[8], nodes[9]];
            edges[nodes[5]] = [nodes[4]];
            edges[nodes[6]] = [nodes[4]];
            edges[nodes[7]] = [nodes[4]];
            edges[nodes[8]] = [nodes[4]];
            edges[nodes[9]] = [nodes[0], nodes[4], nodes[10], nodes[11], nodes[12], nodes[13], nodes[14]];
            edges[nodes[10]] = [nodes[9]];
            edges[nodes[11]] = [nodes[9]];
            edges[nodes[12]] = [nodes[9]];
            edges[nodes[13]] = [nodes[9]];
            edges[nodes[14]] = [nodes[9], nodes[15], nodes[16]];
            edges[nodes[15]] = [nodes[14]];
            edges[nodes[16]] = [nodes[14], nodes[6], nodes[2]];

            Model.edges = edges;

            var canvas, shadowCanvas, context, shadowContext;

            // get the canvas element
            canvas = document.getElementById('canvas');
            if (!canvas || !canvas.getContext) {
                alert("Cannot find the canvas!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(canvas);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(canvas) }, false);

            shadowCanvas = document.getElementById('shadow');
            if (!shadowCanvas || !shadowCanvas.getContext) {
                alert("Cannot find the shadow canvas!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(shadowCanvas);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(shadowCanvas) }, false);

            // get the canvas 2d context
            context = canvas.getContext('2d');
            if (!context) {
                alert("The canvas has no 2d context!");
                return;
            }
            // get the shadow canvas 2d context
            shadowContext = shadowCanvas.getContext('2d');
            if (!shadowContext) {
                alert("The shadow canvas has no 2d context!");
                return;
            }

            DrawingEngine.init(canvas, shadowCanvas, context, shadowContext);

            canvas.mouseHandler = MouseHandler;
            // attach the mousedown, mousemove and mouseup event listeners to the visible canvas
            canvas.addEventListener('mousedown', MouseHandler.handleEvent, false);
            canvas.addEventListener('mousemove', MouseHandler.handleEvent, false);
            canvas.addEventListener('mouseup',   MouseHandler.handleEvent, false);

            DrawingEngine.start();
        }

        // -->
    </script>
</head>
<body style="background: #f0f0f0; overflow: hidden;">
Click and drag a node to see what happens
<canvas id="canvas" style="position:absolute; top:0; left:0;">
    Your browser does not support HTML5 canvas!
</canvas>
<canvas id="shadow" style="position:absolute; top:0; left:0; visibility: hidden;" />
</body>
</html>