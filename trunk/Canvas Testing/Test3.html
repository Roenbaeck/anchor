<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Test 3</title>
    <script type="text/javascript">
        <!--
        // globally accessible variables
        var canvas = null;
        var context = null;
        var drawId = null;
        var startTime = null;

        // frames per second - set low when debugging
        const FPS = 1000;

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 50,
            // 3 percent damping (simulated friction)
            damping: 0.97,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // starting velocity is a whole pixel
            startingVelocity: 1,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.000008,
            // adjusts the size of the influence square by this factor
            influenceConstant: 1.25,
            // used to store the corners of the influence square
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0,

            // for some reason Math.abs is slower than this
            absolute: function(value) {
                return value < 0 ? -value : value;
            },

            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },

            // use the taxi cab metric for measuring distances
            distance: function(node, otherNode) {
                return this.absolute(otherNode.xPos - node.xPos) + this.absolute(otherNode.yPos - node.yPos);
            },
            // x component of the repelling force formula
            xRepelling: function(node, otherNode) {
                return (node.xPos - otherNode.xPos)/this.square(this.distance(node, otherNode));
            },

            // y component of the repelling force formula
            yRepelling: function(node, otherNode) {
                return (node.yPos - otherNode.yPos)/this.square(this.distance(node, otherNode));
            },

            // x component of the attracting force formula
            xAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPos - node.xPos) * this.distance(node, otherNode);
            },

            // y component of the attracting force formula
            yAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPos - node.yPos) * this.distance(node, otherNode);
            },

            findSquareCorners: function(node) {
                this.xMin = node.xPos - this.influenceConstant * this.normalDistance;
                this.xMax = node.xPos + this.influenceConstant * this.normalDistance;
                this.yMin = node.yPos - this.influenceConstant * this.normalDistance;
                this.yMax = node.yPos + this.influenceConstant * this.normalDistance;
            },

            withinSquare: function(otherNode) {
                return  otherNode.xPos >= this.xMin &&
                        otherNode.xPos <= this.xMax &&
                        otherNode.yPos >= this.yMin &&
                        otherNode.yPos <= this.yMax;
            },

            // iterates over all nodes and checks if any are still moving
            complete: function(nodes) {
                var node;
                for(var i = 0; node = nodes[i]; i++)
                    if(node.moving && !node.fixed)
                        return false;
                return true;
            },

            // calculate all forces and change the velocity and position of the node
            layout: function(nodes, edges) {
                var node, otherNode, nodeEdges, i, j;
                for(i = 0; node = nodes[i]; i++) {
                    this.findSquareCorners(node);
                    for(j = 0; otherNode = nodes[j]; j++) {
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode)) {
                                node.xVel += this.xRepelling(node, otherNode);
                                node.yVel += this.yRepelling(node, otherNode);
                            }
                        }
                    }
                    nodeEdges = edges[node];
                    // for all edges, add the attracting velocity
                    for(j = 0; otherNode = nodeEdges[j]; j++) {
                        node.xVel += this.xAttracting(node, otherNode);
                        node.yVel += this.yAttracting(node, otherNode);
                    }
                    // apply damping
                    node.xVel *= this.damping;
                    node.yVel *= this.damping;
                    // check to see if the node has stopped/started moving
                    if(this.absolute(node.xVel) + this.absolute(node.yVel) <= this.stoppingVelocity)
                        node.moving = false;
                    if(this.absolute(node.xVel) + this.absolute(node.yVel) >= this.startingVelocity)
                        node.moving = true;
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.fixed) {
                        node.xPos += node.xVel;
                        node.yPos += node.yVel;
                    }
                }
            }
        };

        function Node(x, y, id) {
            this.id = id;
            this.xPos = x;
            this.yPos = y;
            this.xVel = 0;
            this.yVel = 0;
            this.moving = true;
            this.fixed = false;
        }
        // override toString in order to provide a unique identifier to be used when emulating hash maps
        Node.prototype.toString = function() {
            return this.id.toString();
        };

        // create some nodes (that do not overlap)
        var nodes = [
            new Node(200, 300, "A1"),
            new Node(300, 200, "A1B1"),
            new Node(250, 300, "A1B2"),
            new Node(300, 250, "A1B3"),
            new Node(400, 300, "A2"),
            new Node(300, 400, "A2B1"),
            new Node(450, 300, "A2B2"),
            new Node(300, 450, "A2B3"),
            new Node(300, 500, "A2B4"),
            new Node(400, 350, "A3"),
            new Node(350, 400, "A3B1"),
            new Node(450, 350, "A3B2"),
            new Node(350, 450, "A3B3"),
            new Node(350, 500, "A3B4"),
            new Node(350, 550, "A3B5"),
            new Node(350, 600, "A3B5C1"),
            new Node(350, 650, "A3B5C2")
        ];

        // experimenting with fixed nodes
        nodes[7].fixed = true;

        // set the edges (as arrays of nodes) of every node
        var edges = {};
        edges[nodes[0]] = [nodes[1], nodes[2], nodes[3], nodes[4], nodes[9]];
        edges[nodes[1]] = [nodes[0]];
        edges[nodes[2]] = [nodes[0]];
        edges[nodes[3]] = [nodes[0]];
        edges[nodes[4]] = [nodes[0], nodes[5], nodes[6], nodes[7], nodes[8], nodes[9]];
        edges[nodes[5]] = [nodes[4]];
        edges[nodes[6]] = [nodes[4]];
        edges[nodes[7]] = [nodes[4]];
        edges[nodes[8]] = [nodes[4]];
        edges[nodes[9]] = [nodes[0], nodes[4], nodes[10], nodes[11], nodes[12], nodes[13], nodes[14]];
        edges[nodes[10]] = [nodes[9]];
        edges[nodes[11]] = [nodes[9]];
        edges[nodes[12]] = [nodes[9]];
        edges[nodes[13]] = [nodes[9]];
        edges[nodes[14]] = [nodes[9], nodes[15], nodes[16]];
        edges[nodes[15]] = [nodes[14]];
        edges[nodes[16]] = [nodes[14], nodes[6], nodes[2]];

        // make sure our init function is called when the page is loaded
        window.onload = init;

        // implementation of our init function
        function init() {
            // get the canvas element
            canvas = document.getElementById('myCanvas');
            if (!canvas || !canvas.getContext) {
                return;
            }

            // get the canvas 2d context
            context = canvas.getContext('2d');
            if (!context) {
                return;
            }
            context.fillStyle = '#55bb55';
            context.strokeStyle = '#000000';

            // start a new "thread"
            startTime = new Date();
            drawId = setInterval(draw, 1000 / FPS);
        }

        function draw() {            
            // layout nodes
            LayoutEngine.layout(nodes, edges);

            // start the drawing
            context.clearRect(0, 0, canvas.width, canvas.height);

            var node, otherNode, nodeEdges;

            // draw all edges
            for(var i = 0; node = nodes[i]; i++) {
                nodeEdges = edges[node];
                // for all edges, add the attracting velocity
                for(var j = 0; otherNode = nodeEdges[j]; j++) {
                    context.beginPath();
                    context.moveTo(node.xPos, node.yPos)
                    context.lineTo(otherNode.xPos, otherNode.yPos);
                    context.stroke();
                }
            }

            // draw all nodes
            for(var i = 0; node = nodes[i]; i++) {
                context.beginPath();
                context.arc(node.xPos, node.yPos, 8, 0, 2*Math.PI, false);
                context.fill();
                if(node.fixed)
                    context.stroke();                    
            }

            // check if all nodes have stopped moving
            if(LayoutEngine.complete(nodes)) {
                var stopTime = new Date();
                alert("Layout complete in " + (stopTime.getTime() - startTime.getTime()) + "ms");
                clearInterval(drawId);
            }
        }
        // -->
    </script>
</head>
<body bgcolor="#f0f0f0">
This is a canvas<br/>
<canvas id="myCanvas" width="800" height="800">
    Your browser does not support HTML5 canvas!
</canvas>
</body>
</html>