<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Anchor Modeler</title>
    <style type="text/css">
    body {
        font:               75% georgia, sans-serif;
        line-height:        1.88889;
        color:              #000000;
        background:         #f9f8f7;
        overflow:           hidden;
        margin:             0;
        padding:            0;
    }

    .unselectable {
        user-select:        none;
        -moz-user-select:   none;
        -khtml-user-select: none;
    }

    .invisible {
        opacity:            0;
        filter:             alpha(opacity=0);
        z-index:            1000;
        position:           absolute;
        left:               0;
    }

    .editable:invalid {
        background-color:   #fbb;
    }

    .closebutton {
        display:            none;
        background-image:   url(deleteButton.png);
        position:           absolute;
        left:               -15px;
        top:                -15px;
        height:             30px;
        width:              30px;
        z-index:            14;
    }
    .closebutton:active {
        background-image:   url(deleteButtonPressed.png);
    }

    /* visible canvas - at the bottom of the visible layers */
    #canvas {
        position:           absolute;
        top:                0px;
        left:               0px;
        z-index:            1;
    }

    /* invisible canvas - at the very z-bottom */
    #shadow {
        position:           absolute;
        top:                0px;
        left:               0px;
        display:            none;
        z-index:            0;
    }

    #maxiature {
        position:           absolute;
        top:                0px;
        left:               0px;
        width:              0px;
        height:             0px;
        display:            none;
        z-index:            0;
    }

    /* minature canvas - positioned in the southeast corner */
    #miniature {
        position:           absolute;
        bottom:             40px;
        right:              42px;
        background-color:   #fff;
        z-index:            2;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }

    /* shows login status to the cloud (google app engine) */
    #cloud {
        font:               8pt sans-serif;
        position:           absolute;
        color:              black;
        text-align:         left;
        bottom:             12px;
        left:               12px;
        cursor:             pointer;
        display:            block;
        z-index:            10;
    }

    /* shows model name if cloud based or local */
    #model {
        font:               8pt sans-serif;
        position:           absolute;
        color:              black;
        text-align:         left;
        bottom:             26px;
        left:               12px;
        display:            block;
        z-index:            10;
    }

    /* context menu that pops up when editing */
    #contextMenu {
        position:           absolute;
        top:                0;
        left:               0;
        display:            block;
        background-color:   rgba(212, 212, 212, 0.8);
        color:              black;
        padding:            0;
        margin:             0;
        text-align:         left;
        border:             2px solid #fff;
        z-index:            11;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    #contextMenu .items {
        margin:             10px 10px 5px 10px;
    }
    #contextMenu .topper {
        font:               10px sans-serif;
        cursor:             move;
        color:              #333;
        height:             15px;
        padding-top:        2px;
        padding-left:       24px;
        border-bottom:      1px solid #888;
        background-color:   rgba(255, 255, 255, 0.8);
    }
    #contextMenu .divider {
        border-top:         1px dotted #888;
        height:             2px;
    }

    .toggler {
        position:           absolute;
        margin:             0;
        padding:            0;
        border:             1px solid #555;
        width:              16px;
        height:             16px;
        z-index:            12;
    }
    .expanded {
        cursor:             nw-resize;
        background-color:   #f55;
    }
    .collapsed {
        cursor:             se-resize;
        left:               -3px;
        top:                -3px;
        background-color:   #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    .collapsed:hover {
        background-color:   #fa5;
    }
    
    .operators {
        position:           relative;
        margin:             0px 5px 5px 5px;
        padding:            5px 0px 0px 0px;
        top:                0;
        left:               0;
    }

    .operator {
        margin:             0;
        line-height:        25px;
        text-align:         left;
        cursor:             pointer;
        white-space:        nowrap;
        padding-right:      10px;
        padding-left:       10px;
        z-index:            8;
    }

    .operator:hover {
        color:              white;
        background-color:   rgba(128, 128, 128, 0.8);
        text-decoration:    none;
        text-shadow:        0px 0px 6px #555;
    }


    /* is used in the code popover */
    #modalBackground {
        position:           absolute;
        top:                0;
        left:               0;
        background-color:   rgba(142, 128, 128, 0.5);
        margin:             0;
        padding:            0;
        overflow:           hidden;
        z-index:            10;
    }

    #urlPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #urlPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #urlPopover #content {
        margin-top:         -30px;
        padding:            0;
    }


    #cloudBrowserPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #cloudBrowserPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #cloudBrowserPopover #content {
        margin:             -10px 10px 20px 10px;
        padding:            0;
    }
    #cloudBrowserPopover #content div {
        display:            inline-block;
        text-align:         center;
        color:              black;
        border-width:       medium;
        border-style:       inset;
        margin:             0px 5px 10px 5px;
        padding:            8px;
        cursor:             pointer;
    }
    #cloudBrowserPopover #content img {
        background:         #fff;
        border:             1px solid black; 
        box-shadow:         0px 3px 5px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 3px 5px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 3px 5px rgba(0, 0, 0, 0.5);
    }
    .modelName {
        font:               100% georgia, sans-serif;
    }
    .modelKeywords {
        font:               75% georgia, sans-serif;        
    }


    #cloudSaverPopover {
        position:           relative;
        border:             2px solid white;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(249, 248, 247, 0.95);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #cloudSaverPopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    #cloudSaverPopover #content {
        margin:             -10px 10px 10px 10px;
        padding:            0;
        text-align:         center;
    }
    #cloudSaverPopover #content table {
        margin-top:         20px;
        margin-bottom:      20px;
    }
    #cloudSaverPopover #content td {
        font:               84% georgia, sans-serif;
        color:              black;
        padding-top:        5px;
        text-align:         left;
    }
    #cloudSaverPopover #content img {
        background:         #fff;
        border:             1px solid black;
        box-shadow:         0px 3px 5px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 3px 5px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 3px 5px rgba(0, 0, 0, 0.5);
    }


    /* these classes style the xml representation */
    #codePopover {
        position:           relative;
        border:             2px solid black;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(8, 0, 0, 0.8);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #codePopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    
    #content {
        position:           relative;
        margin-top:         -30px;
        text-align:         left;
        font:               125% Andale Mono, monospace;
        color:              white;
        padding:            15px 20px;
        overflow:           auto;
        background-color:   transparent;
        z-index:            12;
    }
    #content .tabs {
        visibility:         hidden;
    }
    #content .texts {
        color:              #f55;
        font-weight:        bold;
    }
    #content .brackets {
        color:              white;
    }
    #content .elements {
        color:              #ffffc0;
    }
    #content .attributes {
        color:              #c0c0c0;
        font-weight:        bold;
    }
    #content .values {
        color:              #ffc0c0;
        font-style:         italic;
    }
    .preformatted {
        white-space:        pre;        
    }


    /* Menus and control buttons */
    ul, li, table, tr, td {
		list-style-type:    none;
		margin:             0;
        padding:            0;
        border:             0;
        border-collapse:    collapse;
	}

    td {
        padding:            0px 5px 2px 5px;
    }

    #header {
        font:               10pt georgia, sans-serif;
        position:           relative;
        margin:             0;
        padding:            0;
        top:                0;
        left:               0;
        height:             32px;
        display:            block;
        background-color:   rgba(212, 212, 212, 0.9);
        color:              black;
        border-bottom:      2px solid #fff;
        box-shadow:         0px 0px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 0px 10px rgba(0, 0, 0, 0.5);
        z-index:            7;
    }

    /* http://www.ie7nomore.com/fun/menu2/ */
    /* TODO: position using relative instead */
    #actions, #settings, #file, #generate, #about {
        position:           absolute;
        display:            block;
        top:                0px;
        z-index:            8;
    }
    #file {
        left:               8px;
        text-align:         left;
    }
    #actions {
        left:               50px;
        text-align:         left;
    }
    #generate {
        left:               110px;
        text-align:         left;
    }
    #about {
        left:               180px;
        text-align:         left;
    }
    #settings {
        right:              8px;
        text-align:         right;
    }
    .menu {
        font:               10pt georgia, sans-serif;
        margin:             0;
        cursor:             pointer;
        list-style:         none;
    }
    .menu li {
        padding-left:       8px;
        padding-right:      8px;
        line-height:        32px;
    }
    .menu > li {
        display:            inline-block;
    }
    .submenu {
        opacity:            0;
        background-color:   rgba(212, 212, 212, 0.9);
        white-space:        nowrap;
        border:             2px solid #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
        z-index:            9;
    }
    .submenu li {
        height:             0;
        line-height:        25px;
        list-style-type:    none;
        margin:             0;
        padding-right:      8px;
        padding-left:       8px;
        text-align:         left;
    }
    .menu > li:hover .submenu, .menu > li.focus .submenu {
        opacity:            1;
    }
    .menu > li:hover .submenu li, .menu > li.focus .submenu li {
        height:             25px;
    }
    .submenu li:hover {
        color:              white;
        background-color:   rgba(128, 128, 128, 0.8);
        text-decoration:    none;
        text-shadow:        0px 0px 6px #555;
    }
    .submenu select {
        width:              130px;
    }
    .submenu input {
        width:              45px;
    }

    #controls {
        position:           absolute;
        top:                0px;
        left:               50%;
        margin-left:        -325px; /* half of the actual width */
        height:             32px;
        display:            block;
        z-index:            9;
    }
    #controls .playing {
        background-color:   #fa5;      
    }
    #controls .pausing {
        /* just go back to normal */
    }
    #controls div {
        cursor:             pointer;
        position:           relative;
        top:                0;
        display:            inline-block;
        width:              150px; 
        height:             16px;
        padding:            8px 0 8px 20px;
        margin:             0;
        border:             0;
        background:         #b55;
        color:              #fff;
        text-decoration:    none;
        text-shadow:        0px 0px 6px #777;
        -moz-border-radius: 10px 0 / 40px 0;
        -webkit-border-radius: 10px 0 / 40px 0;
        border-radius:      10px 0 / 40px 0;
        -webkit-transition: .5s;
        -moz-transition:    .5s;
        transition:         .5s;
    }
    #controls div:hover {
        background:         #f77;
    }
    #controls div + div {
        margin-left:        -50px;
    }
    
    </style>

    <script type="text/javascript">
        <!--
        // set to true to show debugging information
        var DEBUG = false;

        // frames per second - set low when debugging
        var FPS = 100;

        // draw the miniature every minirate frames
        var MINIRATE = 50;

        // which transform to use when generating SQL code
        var DATABASE_TRANSFORM = 'SQLServer.xsl';

        // used when creating svg elements
        var SVGNS = "http://www.w3.org/2000/svg";

        var CALCS = 'simple';

        var ASKBEFOREUNLOAD = true;
        
        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 30,
            // 4 percent damping (simulated friction)
            damping: 0.96,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // minimum starting velocity is a whole pixel
            minimumStartingVelocity: 1,
            // maximum starting velocity is higher (to remove "twitching" when few nodes are moving)
            maximumStartingVelocity: 5,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.00003703703704,
            // adjusts the size of the influence square by this factor
            influenceConstant: 4,
            // the stiffness of the edges
            stiffness: 3,
            // calculated as stiffness^2
            stiffnessBound: 9,
            // when the layout has reached equilibrium
            equilibrium: true,
            // which layout function to use
            layout: null,
            init: function() {
                this.layout = this.simpleLayout;
                this.attractionConstant = 1/this.normalDistance/this.normalDistance/this.normalDistance;
                this.stiffnessBound = this.stiffness * this.stiffness;
            },
            // for some reason Math.abs is slower than this
            absolute: function(value) {
                return value < 0 ? -value : value;
            },

            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },
            // measures distance between two nodes
            manhattanDistance: function(node, otherNode) {
                var d = this.absolute(otherNode.xPosition - node.xPosition) + this.absolute(otherNode.yPosition - node.yPosition);
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            euclideanDistance: function(node, otherNode) {
                var d = Math.sqrt(this.square(otherNode.xPosition - node.xPosition) + this.square(otherNode.yPosition - node.yPosition));
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            // x component of the repelling force formula
            xSimpleRepelling: function(node, otherNode) {
                return (node.xPosition - otherNode.xPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            ySimpleRepelling: function(node, otherNode) {
                return (node.yPosition - otherNode.yPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xSimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPosition - node.xPosition) * this.manhattanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            ySimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPosition - node.yPosition) * this.manhattanDistance(node, otherNode);
            },
            // x component of the repelling force formula
            xComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.xPosition - otherNode.xPosition) / this.square(this.euclideanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            yComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.yPosition - otherNode.yPosition) / this.square(this.euclideanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant * (otherNode.xPosition - node.xPosition) * this.euclideanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            yComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant * (otherNode.yPosition - node.yPosition) * this.euclideanDistance(node, otherNode);
            },
            // create the square of influence
            createSquare: function(node, offset) {
                return {
                    xMin: node.xPosition - offset,
                    xMax: node.xPosition + offset,
                    yMin: node.yPosition - offset,
                    yMax: node.yPosition + offset
                };
            },
            // check if a node falls within the square of influence
            withinSquare: function(otherNode, square) {
                return  otherNode.xPosition >= square.xMin &&
                        otherNode.xPosition <= square.xMax &&
                        otherNode.yPosition >= square.yMin &&
                        otherNode.yPosition <= square.yMax;
            },

            // calculate all forces and change the velocity and position of the node
            simpleLayout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, curvature, square;
                var numberOfNodes = model.nodes.length;
                var numberOfStoppedNodes = 0;
                var startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;

                for(i = 0; node = model.nodes[i]; i++) {
                    square = this.createSquare(node, this.influenceConstant * this.normalDistance);
                    for(j = 0; otherNode = model.nodes[j]; j++) {
                        // not the same node
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode, square)) {
                                node.xVelocity += this.xSimpleRepelling(node, otherNode);
                                node.yVelocity += this.ySimpleRepelling(node, otherNode);
                            }
                        }
                        // the first iteration we count the number of stopped nodes
                        if(j == 0 && (!otherNode.moving || otherNode.getFixed())) {
                            numberOfStoppedNodes++;
                        }
                    }
                    // bending force (straightens out edges)
                    if(node instanceof Edge) {
                        // update the control and center points
                        node.controlPoint.xPosition = 2 * node.xPosition - node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                        node.controlPoint.yPosition = 2 * node.yPosition - node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                        node.centerPoint.xPosition = node.node.xPosition + (node.otherNode.xPosition - node.node.xPosition) / 2;
                        node.centerPoint.yPosition = node.node.yPosition + (node.otherNode.yPosition - node.node.yPosition) / 2;
                        curvature = this.square(this.stiffness * this.manhattanDistance(node.centerPoint, node.controlPoint)/this.manhattanDistance(node.node, node.otherNode));
                        // safeguard
                        curvature = curvature > this.stiffnessBound ? this.stiffnessBound : curvature;
                        // flexure force moves the midway point toward the center point
                        node.xVelocity -= curvature * this.xSimpleRepelling(node, node.centerPoint);
                        node.yVelocity -= curvature * this.ySimpleRepelling(node, node.centerPoint);
                    }
                    // for all edges, add the attracting velocity
                    for(j = 0; edge = node.edges[j]; j++) {
                        node.xVelocity += this.xSimpleAttracting(node, edge)/node.edges.length;
                        node.yVelocity += this.ySimpleAttracting(node, edge)/node.edges.length;
                    }
                    // apply damping
                    node.xVelocity *= this.damping;
                    node.yVelocity *= this.damping;
                    node.velocity = this.absolute(node.xVelocity) + this.absolute(node.yVelocity);
                    // check to see if the node has stopped moving
                    if(node.velocity <= this.stoppingVelocity)
                        node.stop();
                    // the more nodes that have stopped, the larger the starting velocity must be
                    if(node.velocity >= this.minimumStartingVelocity + startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                        node.start();
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.getFixed()) {
                        this.equilibrium = false;
                        node.xPosition += node.xVelocity;
                        node.yPosition += node.yVelocity;
                    }
                    if(node.yPosition < model.topmostNode.yPosition)
                        model.topmostNode = node;
                    if(node.xPosition > model.rightmostNode.xPosition)
                        model.rightmostNode = node;
                    if(node.yPosition > model.bottommostNode.yPosition)
                        model.bottommostNode = node;
                    if(node.xPosition < model.leftmostNode.xPosition)
                        model.leftmostNode = node;
                }
            },
            // calculate all forces and change the velocity and position of the node
            complexLayout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, curvature, square;
                var numberOfNodes = model.nodes.length;
                var numberOfStoppedNodes = 0;
                var startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;

                for(i = 0; node = model.nodes[i]; i++) {
                    square = this.createSquare(node, this.influenceConstant * this.normalDistance);
                    for(j = 0; otherNode = model.nodes[j]; j++) {
                        // not the same node
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode, square)) {
                                node.xVelocity += this.xComplexRepelling(node, otherNode);
                                node.yVelocity += this.yComplexRepelling(node, otherNode);
                            }
                        }
                        // the first iteration we count the number of stopped nodes
                        if(j == 0 && (!otherNode.moving || otherNode.getFixed())) {
                            numberOfStoppedNodes++;
                        }
                    }
                    // bending force (straightens out edges)
                    if(node instanceof Edge) {
                        // update the control and center points
                        node.controlPoint.xPosition = 2 * node.xPosition - node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                        node.controlPoint.yPosition = 2 * node.yPosition - node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                        node.centerPoint.xPosition = node.node.xPosition + (node.otherNode.xPosition - node.node.xPosition) / 2;
                        node.centerPoint.yPosition = node.node.yPosition + (node.otherNode.yPosition - node.node.yPosition) / 2;
                        curvature = this.square(this.stiffness * this.euclideanDistance(node.centerPoint, node.controlPoint)/this.euclideanDistance(node.node, node.otherNode));
                        // safeguard
                        curvature = curvature > this.stiffnessBound ? this.stiffnessBound : curvature;
                        // flexure force moves the midway point toward the center point
                        node.xVelocity -= curvature * this.xSimpleRepelling(node, node.centerPoint);
                        node.yVelocity -= curvature * this.ySimpleRepelling(node, node.centerPoint);
                    }
                    // for all edges, add the attracting velocity
                    for(j = 0; edge = node.edges[j]; j++) {
                        node.xVelocity += this.xComplexAttracting(node, edge)/node.edges.length;
                        node.yVelocity += this.yComplexAttracting(node, edge)/node.edges.length;
                    }
                    // apply damping
                    node.xVelocity *= this.damping;
                    node.yVelocity *= this.damping;
                    node.velocity = this.absolute(node.xVelocity) + this.absolute(node.yVelocity);
                    // check to see if the node has stopped moving
                    if(node.velocity <= this.stoppingVelocity)
                        node.stop();
                    // the more nodes that have stopped, the larger the starting velocity must be
                    if(node.velocity >= this.minimumStartingVelocity + startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                        node.start();
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.getFixed()) {
                        this.equilibrium = false;
                        node.xPosition += node.xVelocity;
                        node.yPosition += node.yVelocity;
                    }
                    if(node.yPosition < model.topmostNode.yPosition)
                        model.topmostNode = node;
                    if(node.xPosition > model.rightmostNode.xPosition)
                        model.rightmostNode = node;
                    if(node.yPosition > model.bottommostNode.yPosition)
                        model.bottommostNode = node;
                    if(node.xPosition < model.leftmostNode.xPosition)
                        model.leftmostNode = node;
                }
            }
        };

        var UniqueColor = {
            // note that #000000 is reserved for the background and never assigned
            takenColors: {},
            formatColor: function(red, green, blue) {
                return '#' +
                        ('0' + red.toString(16)).slice(-2) +
                        ('0' + green.toString(16)).slice(-2) +
                        ('0' + blue.toString(16)).slice(-2);
            },
            reserveUniqueColor: function() {
                var r = Math.ceil(Math.random() * 255);
                var g = Math.ceil(Math.random() * 255);
                var b = Math.ceil(Math.random() * 255);
                var color = this.formatColor(r, g, b);
                if(this.takenColors[color] || (r + g + b) == 0)
                    return this.reserveUniqueColor();
                this.takenColors[color] = true;
                return color;
            },
            releaseUniqueColor: function(color) {
                delete this.takenColors[color];
            }
        };

        var Model = {
            // these are used in the cloud
            name: null,
            scope: 'private',
            keywords: null,
            id: null,
            // other members
            nodes: [],
            edges: [],
            filtered: [],
            shadowToNode: {},
            topmostNode: null,
            rightmostNode: null,
            bottommostNode: null,
            leftmostNode: null,
            version: -1,
            versions: [],
            uncloud: function() {
                this.name = null;
                this.scope = 'private';
                this.keywords = null;
                this.id = null;
            },
            empty: function() {
                this.nodes = [];
                this.edges = [];
                this.shadowToNode = {};
                this.topmostNode = null;
                this.rightmostNode = null;
                this.bottommostNode = null;
                this.leftmostNode = null;
            },
            // TODO: We probably should have a maximum number of versions
            recordState: function() {
                // only record if there is something to record
                if(this.nodes.length) {
                    this.version++;
                    this.versions[this.version] = this.toXML();
                    this.versions.length = this.version + 1;
                    ControlButtons.setUndoLevels(this.version);
                    ControlButtons.setRedoLevels(0);
                }
            },
            undoState: function() {
                this.version -= (this.version == 0 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            redoState: function() {
                this.version += (this.version == this.versions.length - 1 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            setupMinimal: function() {
                if(confirm("Are you sure you want to clear the current model?\nAny unsaved changes will be lost!")) {
                    this.uncloud();
                    this.empty();
                    Actions.setModelStatus();
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.reset();
                    this.addNode(new Anchor(DrawingEngine.canvas.width/2, DrawingEngine.canvas.height/2));
                    DrawingEngine.start(true);
                }
            },
            validate: function(filter) {
                var i, node, isValid = true;
                for(i = 0; node = Model.nodes[i]; i++)
                    isValid &= node.validate();
                return isValid;
            },
            applyFilter: function(filter) {
                var i, node, j, edge;
                for(i = 0; node = this.nodes[i]; i++) {
                    if(filter(node)) {
                        this.filtered[i] = true;
                        for(j = 0; edge = node.edges[j]; j++)
                            this.filtered[this.nodes.indexOf(edge)] = true;
                    }
                }
            },
            removeFilter: function() {
                this.filtered.length = 0;
            },
            sort: function() {
                this.nodes.sort(function(a, b) {
                    if (a instanceof Edge)
                        return -1;
                    if (a instanceof Knot && !(b instanceof Edge))
                        return -1;
                    if (a instanceof Anchor && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    if (a instanceof Attribute && !(b instanceof Anchor) && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    return 1;
                });
            },
            addNode: function(node) {
                // add node at the end of the array
                if(node) {
                    this.nodes[this.nodes.length] = node;
                    this.sort();
                    this.shadowToNode[node.shadowColor] = node;
                    if(this.topmostNode == null || node.yPosition < this.topmostNode.yPosition)
                        this.topmostNode = node;
                    if(this.rightmostNode == null || node.xPosition > this.rightmostNode.xPosition)
                        this.rightmostNode = node;
                    if(this.bottommostNode == null || node.yPosition > this.bottommostNode.yPosition)
                        this.bottommostNode = node;
                    if(this.leftmostNode == null || node.xPosition < this.leftmostNode.xPosition)
                        this.leftmostNode = node;
                    this.invalidateNode(node);
                }
            },
            removeNode: function(node) {
                UniqueColor.releaseUniqueColor(node.shadowColor);
                delete this.shadowToNode[node.shadowColor];
                this.deleteElementFromArray(this.nodes, node);
            },
            addEdge: function(edge) {
                // the edge is also a node
                if(edge) {
                    this.addNode(edge);
                    this.edges[this.edges.length] = edge;                    
                }
            },
            removeEdge: function(edge) {
                this.deleteElementFromArray(this.edges, edge);
                this.deleteElementFromArray(edge.node.edges, edge);
                this.deleteElementFromArray(edge.otherNode.edges, edge);
                this.removeNode(edge);
            },
            getNodeFromShadow: function(shadow) {
                return this.shadowToNode[shadow];
            },
            deleteElementFromArray: function(array, element) {
                array.splice(array.indexOf(element), 1);
            },
            invalidateNode: function(node) {
                var square = LayoutEngine.createSquare(node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.nodes.length; i++)
                    if(LayoutEngine.withinSquare(this.nodes[i], square))
                        this.nodes[i].start();
            },
            toXML: function() {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                for(var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i].toXML(schema);
                    if(node != null)
                        schema.documentElement.appendChild(node);
                }
                return schema;
            },
            toSVG: function() {
                var type = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.0//EN", "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd");
                var svg = document.implementation.createDocument(SVGNS, "svg", type);
                var g = svg.createElementNS(SVGNS, 'g');
                for(var i = 0; i < this.nodes.length; i++)
                    if(!this.filtered[i])
                        this.nodes[i].toSVG(svg, g);
                var node;
                if(DrawingEngine.showNames) {
                    for(i = 0; node = this.nodes[i]; i++)
                        if(!(node instanceof Edge) && !this.filtered[i])
                            node.toSVGName(svg, g);
                }
                svg.documentElement.appendChild(g);
                return svg;
            },
            toSVGURL: function() {
                return 'data:image/svg+xml;base64,' + btoa(new XMLSerializer().serializeToString(this.toSVG()));
            },
            fromXML: function(xml) {
                if(xml) {
                    this.empty();
                    var i;
                    // the order in which we add these are important (attributes create edges to anchors)
                    var knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addNode(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addNode(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addNode(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addNode(Tie.prototype.fromXML(ties[i]));
                }
            },
            walkFromNode: function(node, affectedNodes, affectedEdges) {
                var i, k, edge, otherNode, otherEdge, anotherNode, otherNodeShouldAlsoBeErased;
                for(i = 0; edge = node.edges[i]; i++) {
                    if(affectedEdges.indexOf(edge) < 0)
                        affectedEdges.push(edge);
                    otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                    otherNodeShouldAlsoBeErased = true;
                    for(k = 0; otherEdge = otherNode.edges[k]; k++) {
                        anotherNode = (otherNode == otherEdge.otherNode ? otherEdge.node : otherEdge.otherNode);
                        otherNodeShouldAlsoBeErased &= affectedNodes.indexOf(anotherNode) >= 0;
                    }
                    if(otherNodeShouldAlsoBeErased && affectedNodes.indexOf(otherNode) < 0) {
                        affectedNodes.push(otherNode);
                        this.walkFromNode(otherNode, affectedNodes, affectedEdges);
                    }
                }
            },
            walkFromEdge: function(edge, affectedNodes, affectedEdges) {
                var i, k, otherEdge, potentialNode, potentialNodeShouldAlsoBeErased;
                var potentialNodes = [edge.node, edge.otherNode];
                for(i = 0; potentialNode = potentialNodes[i]; i++) {
                    potentialNodeShouldAlsoBeErased = true;
                    for(k = 0; otherEdge = potentialNode.edges[k]; k++)
                        potentialNodeShouldAlsoBeErased &= affectedEdges.indexOf(otherEdge) >= 0;
                    if(potentialNodeShouldAlsoBeErased && affectedNodes.indexOf(potentialNode) < 0)
                        affectedNodes.push(potentialNode);
                }
            },
            erase: function(nodes) {
                var i, j, node, edge, affectedNodes = [], affectedEdges = [];
                for(i = 0; node = nodes[i]; i++) {
                    if(node instanceof Edge)
                        affectedEdges.push(node);
                    else
                        affectedNodes.push(node);
                }
                for(i = 0; node = affectedNodes[i]; i++)
                    this.walkFromNode(node, affectedNodes, affectedEdges);
                for(i = 0; edge = affectedEdges[i]; i++)
                    this.walkFromEdge(edge, affectedNodes, affectedEdges);
                // check for ties in violation
                var otherNode;
                for(i = 0; node = this.nodes[i]; i++) {
                    if(node instanceof Tie) {
                        var anchors = 0;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                            if(affectedNodes.indexOf(otherNode) < 0 && affectedEdges.indexOf(edge) < 0)
                                if(otherNode instanceof Anchor)
                                    anchors++;
                        }
                        if(anchors < 2 && affectedNodes.indexOf(node) < 0) {
                            affectedNodes.push(node);
                            this.walkFromNode(node, affectedNodes, affectedEdges);
                        }
                    }
                }
                // add any dangling edges
                for(i = 0; node = affectedNodes[i]; i++)
                    for(j = 0; edge = node.edges[j]; j++)
                        if(affectedEdges.indexOf(edge) < 0)
                            affectedEdges.push(edge);
                if(confirm("Are you sure you want to delete the following?\n--" +
                        affectedNodes.length + " nodes and " +
                        affectedEdges.length + " edges --\n" + affectedNodes.join('\n'))) {
                    for(i = 0; node = affectedNodes[i]; i++)
                        this.removeNode(node);
                    for(i = 0; edge = affectedEdges[i]; i++)
                        this.removeEdge(edge);
                    this.recordState();
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.start(true);
                }
            },
            connect: function(nodes) {
                var anchor, attribute, tie, knot;
                for(var i = 0; i < nodes.length; i++) {
                    if(nodes[i] instanceof Anchor)
                        anchor = nodes[i];
                    else if(nodes[i] instanceof Attribute)
                        attribute = nodes[i];
                    else if(nodes[i] instanceof Tie)
                        tie = nodes[i];
                    else if(nodes[i] instanceof Knot)
                        knot = nodes[i];
                }
                if(anchor && tie) {
                    this.addEdge(new Edge(tie, anchor, false));                    
                }
                else if (attribute && knot) {
                    attribute.setKnotted(true);
                    this.addEdge(new Edge(attribute, knot, false));
                }
                else if (tie && knot) {
                    tie.setKnotted(true);
                    this.addEdge(new Edge(tie, knot, false));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleKnotted: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot, edge;
                    if(nodes[i].getKnotted()) {
                        for(var j = 0; edge = nodes[i].edges[j]; j++) {
                            if(edge.otherNode instanceof Knot) {
                                if(edge.otherNode.edges.length == 1) {
                                    if(!confirm("This will also delete the knot: " + edge.otherNode +
                                            ".\nDo you still want to un-knot the attribute?"))
                                        break;
                                }
                                this.removeNode(edge.otherNode);
                                this.removeEdge(edge);
                                nodes[i].setKnotted(false);
                            }
                        }
                    }
                    else {
                        knot = new Knot(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 2 * LayoutEngine.normalDistance);
                        this.addNode(knot);
                        this.addEdge(new Edge(nodes[i], knot, true));
                        nodes[i].setKnotted(true);
                    }
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleHistorized: function(nodes) {
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].setHistorized(!nodes[i].getHistorized());
                this.recordState();
                DrawingEngine.start(false);
            },
            toggleIdentifier: function(nodes) {
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].identifier = !nodes[i].identifier;
                this.recordState();
                DrawingEngine.start(false);
            },
            addAttribute: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var attribute = new Attribute(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(attribute);
                    this.addEdge(new Edge(attribute, nodes[i], true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTie: function(nodes) {
                var tie;
                // multiple anchors selected
                if(nodes.length > 1) {
                    var i, xAverage = 0, yAverage = 0;
                    for(i = 0; i < nodes.length; i++) {
                        xAverage += nodes[i].xPosition;
                        yAverage += nodes[i].yPosition;
                    }
                    xAverage /= nodes.length;
                    yAverage /= nodes.length;
                    tie = new Tie(xAverage, yAverage, false);
                    this.addNode(tie);
                    for(i = 0; i < nodes.length; i++)
                        this.addEdge(new Edge(tie, nodes[i], true));
                }
                // single anchor selected
                else {
                    var anchor = nodes[0];
                    tie = new Tie(anchor.xPosition + 2 * LayoutEngine.normalDistance, anchor.yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    this.addEdge(new Edge(tie, anchor, true));
                    this.addEdge(new Edge(tie, anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var anchor = new Anchor(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    this.addEdge(new Edge(nodes[i], anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTieAndAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var tie = new Tie(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    this.addEdge(new Edge(tie, nodes[i], true));
                    var anchor = new Anchor(nodes[i].xPosition + 4 * LayoutEngine.normalDistance, nodes[i].yPosition - 6 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    this.addEdge(new Edge(tie, anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addKnot: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot = new Knot(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance);
                    this.addNode(knot);
                    this.addEdge(new Edge(nodes[i], knot, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            initialized: false,
            canvas: null,
            shadowCanvas: null,
            miniatureCanvas: null,
            context: null,
            shadowContext: null,
            miniatureContext: null,
            running: false,
            xyScale: 1,
            xTranslation: 0,
            yTranslation: 0,
            xVisible: 0,
            yVisible: 0,
            widthVisible: 0,
            heightVisible: 0,
            miniScale: 0.2, // one fifth of the large canvas
            miniPadding: 50,
            miniWidth: 0,
            miniHeight: 0,
            miniCounter: 0,
            miniature: null,
            showNames: false,
            drawShadows: false,
            newState: true,
            init: function(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext) {
                this.canvas = canvas;
                this.shadowCanvas = shadowCanvas;
                this.miniatureCanvas = miniatureCanvas;
                this.context = context;
                this.shadowContext = shadowContext;
                this.miniatureContext = miniatureContext;
                this.context.font = '10px sans-serif';
                this.initialized = true;
                this.refreshViewportCoordinates();
            },
            storeSettings: function(storage) {
                storage.setItem("xyScale", this.xyScale);
                storage.setItem("xTranslation", this.xTranslation);
                storage.setItem("yTranslation", this.yTranslation);
            },
            loadSettings: function(storage) {
                this.xyScale = 1 * storage.getItem("xyScale") || 1;
                this.xTranslation = 1 * storage.getItem("xTranslation") || 0;
                this.yTranslation = 1 * storage.getItem("yTranslation") || 0;
                ResizeHandler.resizeCanvas(this.canvas, this.context);
                ResizeHandler.resizeCanvas(this.shadowCanvas, this.shadowContext);
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            reset: function() {
                this.xyScale = 1;
                this.xTranslation = 0;
                this.yTranslation = 0;
                this.miniScale = 0.2;
                ResizeHandler.resizeCanvas(this.canvas, this.context);
                ResizeHandler.resizeCanvas(this.shadowCanvas, this.shadowContext);
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            scale: function(scale) {
                this.xyScale *= scale;
                this.context.scale(scale, scale);
                this.shadowContext.scale(scale, scale);
                this.refreshViewportCoordinates();
            },
            translate: function(x, y) {
                this.xTranslation += x * this.xyScale;
                this.yTranslation += y * this.xyScale;
                this.context.translate(x, y);
                this.shadowContext.translate(x, y);
                this.refreshViewportCoordinates();
            },
            refreshViewportCoordinates: function() {
                if(this.initialized) {
                    this.xVisible = -this.xTranslation/this.xyScale;
                    this.yVisible = -this.yTranslation/this.xyScale;
                    this.widthVisible = this.canvas.width/this.xyScale;
                    this.heightVisible = this.canvas.height/this.xyScale;                    
                }
            },
            xContext: function(xScreen) {
                return (xScreen - this.xTranslation) / this.xyScale;
            },
            yContext: function(yScreen) {
                return (yScreen - this.yTranslation) / this.xyScale;
            },
            xScreen: function(xContext) {
                return xContext * this.xyScale + this.xTranslation;
            },
            yScreen: function(yContext) {
                return yContext * this.xyScale + this.yTranslation;
            },
            setCursor: function(cursor) {
                this.canvas.style.cursor = cursor;
            },
            getNodeAt: function(x, y) {
                // clear the shadow context
                this.shadowContext.fillStyle = '#000000';
                this.shadowContext.fillRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);

                var i, node;
                // draw all nodes on the shadow context
                for(i = 0; node = Model.nodes[i]; i++)
                    node.drawShadow(this.shadowContext);

                var data = this.shadowContext.getImageData(x, y, 1, 1).data;
                return Model.getNodeFromShadow(UniqueColor.formatColor(data[0], data[1], data[2]));
            },
            start: function(layoutModel) {
                if(this.initialized) {
                    this.invalidateMiniature();
                    if(!this.running) {
                        this.running = true;
                        this.drawId = setInterval(function() { DrawingEngine.draw(layoutModel); }, 1000 / FPS);
                        if(layoutModel)
                            ControlButtons.setPauseState();
                    }
                }
            },
            stop: function() {
                if(this.running) {
                    clearInterval(this.drawId);
                    this.running = false;
                    ControlButtons.setPlayState();
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            draw: function(layoutModel) {
                // layout nodes
                if(layoutModel || !LayoutEngine.equilibrium) {
                    LayoutEngine.layout(Model);
                    this.newState = true;
                }
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    clearInterval(this.drawId);
                    this.running = false;
                    this.invalidateMiniature();
                    if(this.newState) {
                        this.newState = false;
                        Model.recordState();
                    }
                    ControlButtons.setPlayState();
                }

                // clear the visible context
                this.context.clearRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);

                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % MINIRATE;
                if(this.miniCounter == 1)
                    this.drawMiniature(Model);

                var i, node;
                // draw focus rings around hovered and selected nodes
                if(node = CanvasEventHandler.hoveredNode)
                    this.drawHovered(node.xPosition, node.yPosition);

                for(i = 0; node = CanvasEventHandler.selectedNodes[i]; i++)
                    this.drawSelected(node.xPosition, node.yPosition, node == CanvasEventHandler.hoveredNode);

                // cast all shadows first
                if(this.drawShadows)
                    for(i = 0; node = Model.nodes[i]; i++)
                        if(!Model.filtered[i])
                            node.drawMoving(this.context);

                // draw all nodes and edges on the visible context
                for(i = 0; node = Model.nodes[i]; i++) {
                    if(!Model.filtered[i])
                        node.draw(this.context);
                    if(this.miniCounter == 1) {
                        if(Model.filtered[i])
                            this.miniatureContext.globalAlpha = 0.25;
                        node.draw(this.miniatureContext);
                        this.miniatureContext.globalAlpha = 1.0;
                    }
                }
                if(this.showNames) {
                    for(i = 0; node = Model.nodes[i]; i++)
                        if(!(node instanceof Edge) && !Model.filtered[i])
                            node.drawName(this.context);
                }
                else if (node = CanvasEventHandler.hoveredNode)
                    node.drawName(this.context);
            },
            drawMiniature: function(model) {
                // check current size first and adjust scale accordingly
                if(!model.rightmostNode) return;
                
                do {
                    this.miniWidth = model.rightmostNode.xPosition - model.leftmostNode.xPosition + 2 * this.miniPadding;
                    this.miniHeight = model.bottommostNode.yPosition - model.topmostNode.yPosition + 2 * this.miniPadding;
                    this.miniatureCanvas.width = this.miniScale * this.miniWidth;
                    this.miniatureCanvas.height = this.miniScale * this.miniHeight;
                }
                while(this.resizeMiniature());

                this.miniatureCanvas.style.width = this.miniatureCanvas.width + 'px';
                this.miniatureCanvas.style.height = this.miniatureCanvas.height + 'px';
                this.miniatureContext.setTransform(this.miniScale, 0, 0, this.miniScale, this.miniScale * (this.miniPadding - model.leftmostNode.xPosition), this.miniScale * (this.miniPadding - model.topmostNode.yPosition));

                // show the viewport on the miniature
                this.miniatureContext.strokeStyle = '#bb5555';
                this.miniatureContext.lineWidth = 1/this.miniScale;
                this.miniatureContext.strokeRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);
            },
            resizeMiniature: function() {
                if(this.miniatureCanvas.width + this.miniatureCanvas.height < (window.innerWidth + window.innerHeight)/6) {
                    this.miniScale += 0.03;
                    return true;
                }
                if(this.miniatureCanvas.width + this.miniatureCanvas.height > (window.innerWidth + window.innerHeight)/4) {
                    this.miniScale -= 0.03;
                    return true;
                }
                return false;
            },
            drawHovered: function(x, y) {
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance + 5, 0, 2*Math.PI, false);
                this.context.fillStyle = '#ede5e5';
                this.context.fill();
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance - 5, 0, 2*Math.PI, false);
                this.context.fillStyle = '#fff';
                this.context.fill();
            },
            drawSelected: function(x, y, isHovered) {
                if(!isHovered) {
                    this.context.beginPath();
                    this.context.arc(x, y, LayoutEngine.normalDistance + 5, 0, 2*Math.PI, false);
                    this.context.fillStyle = '#ede5e5';
                    this.context.fill();
                }
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance, 0, 2*Math.PI, false);
                this.context.strokeStyle = '#b88';
                this.context.lineWidth = 1.0;
                this.context.stroke();
            }
        };

        var ResizeHandler = {
            resizeCanvas: function(canvas, context) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // apparently changing the canvas width or height resets the transform
                context.setTransform(DrawingEngine.xyScale, 0, 0, DrawingEngine.xyScale, DrawingEngine.xTranslation, DrawingEngine.yTranslation);
                DrawingEngine.refreshViewportCoordinates();
                DrawingEngine.start(false);
            }
        };

        var CanvasEventHandler = {
            dragging: false,
            hasMoved: false,
            contextMenu: null,
            focusedNode: null,
            xLastKnown: 0,
            yLastKnown: 0,
            hoveringPrepared: false,
            hoveringId: null,
            hoveredNode: null,
            selectedNodes: [],
            mousedown: function(event) {
                if(this.focusedNode = DrawingEngine.getNodeAt(event.xScreen, event.yScreen)) {
                    if(event.shiftKey) {
                        if(this.selectedNodes.indexOf(this.focusedNode) >= 0)
                            this.removeNodeFromSelection(this.focusedNode);
                        else
                            this.addNodeToSelection(this.focusedNode);
                    }
                }
                else if(event.shiftKey) {
                    // we are shift clicking the canvas background
                    this.clearSelection();
                }
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    this.hasMoved = true;
                    // if we are dragging a node, we must also be hovering over it
                    if(this.focusedNode) {
                        if(!(this.focusedNode instanceof Edge)) {
                            this.focusedNode.xPosition = DrawingEngine.xContext(event.xScreen);
                            this.focusedNode.yPosition = DrawingEngine.yContext(event.yScreen);
                            this.focusedNode.setFixed(true);
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;
                            }
                            Model.invalidateNode(this.focusedNode);
                            DrawingEngine.start(true);
                        }
                    }
                    // if the dragging started over an empty part of the canvas
                    else {
                        DrawingEngine.setCursor('move');
                        DrawingEngine.translate((event.xScreen - this.xLastKnown)/DrawingEngine.xyScale, (event.yScreen - this.yLastKnown)/DrawingEngine.xyScale);
                        DrawingEngine.start(false);
                    }
                }
                else {
                    // we are hovering, but not dragging
                    if(this.hoveredNode) {
                        var mouse = {
                            xPosition: DrawingEngine.xContext(event.xScreen),
                            yPosition: DrawingEngine.yContext(event.yScreen)
                        };
                        if(LayoutEngine.manhattanDistance(this.hoveredNode, mouse) > 1.5 * LayoutEngine.normalDistance) {
                            DrawingEngine.setCursor('default');
                            this.hoveredNode = null;
                            this.hoveringPrepared = false;
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;                                
                            }
                            DrawingEngine.start(false);
                        }
                    }
                    // if we are not hovering, set up a check in half a second
                    else if (!this.hoveringPrepared) {
                        this.hoveringPrepared = true;
                        this.hoveringId = setTimeout(function(self) { self.mousehover(event); }, 500, this);
                    }
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mousehover: function(event) {
                // mouse pointer over node
                if(this.hoveredNode = DrawingEngine.getNodeAt(this.xLastKnown, this.yLastKnown)) {
                    if(this.contextMenu == null)
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    else if (this.contextMenu.collapsed) {
                        this.contextMenu.close();
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    }
                    DrawingEngine.setCursor('pointer');
                    DrawingEngine.start(false);
                }
                // mouse pointer not over node, trigger a new check
                else {
                    this.hoveringPrepared = false;
                }
            },
            closeContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;                    
                }
            },
            keydown: function(event) {
                // not used at the moment
            },
            // this is special Firefox handling
            DOMMouseScroll: function(event) {
                event.wheelDelta = event.detail * -120;
                this.mousewheel(event);
            },
            // TODO: We need upper and lower bounds on the zoom            
            mousewheel: function(event) {
                var zoom = 1 + 10/event.wheelDelta;
                DrawingEngine.scale(zoom);
                DrawingEngine.translate(DrawingEngine.xContext(event.xScreen) - DrawingEngine.xContext(event.xScreen) * zoom, DrawingEngine.yContext(event.yScreen) - DrawingEngine.yContext(event.yScreen) * zoom);
                DrawingEngine.start(false);
            },
            mouseup: function(event) {
                var layout = false;
                // the dragging started over a node
                if(this.focusedNode && !this.hasMoved && !event.shiftKey) {
                    this.focusedNode.setFixed(!this.focusedNode.getFixed());
                    layout = true;
                }
                this.focusedNode = null;
                this.dragging = false;
                this.hasMoved = false;
                DrawingEngine.setCursor('default');
                DrawingEngine.start(layout);
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.CanvasEventHandler[event.type])
                    this.CanvasEventHandler[event.type](event);
            },
            addNodeToSelection: function(node) {
                if(this.selectedNodes.indexOf(node) < 0)
                    this.selectedNodes.push(node);
            },
            removeNodeFromSelection: function(node) {
                this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1);
            },
            clearSelection: function() {
                this.selectedNodes.length = 0;
            }
        };

        var MiniatureEventHandler = {
            dragging: false,
            xLastKnown: 0,
            yLastKnown: 0,
            mousedown: function(event) {
                var xCenter = DrawingEngine.xVisible + DrawingEngine.widthVisible/2;
                var yCenter = DrawingEngine.yVisible + DrawingEngine.heightVisible/2;
                // scale down
                xCenter = xCenter * DrawingEngine.miniScale + DrawingEngine.miniScale * (DrawingEngine.miniPadding - Model.leftmostNode.xPosition);
                yCenter = yCenter * DrawingEngine.miniScale + DrawingEngine.miniScale * (DrawingEngine.miniPadding - Model.topmostNode.yPosition);

                var xTranslate = xCenter - event.xScreen;
                var yTranslate = yCenter - event.yScreen;
                // scale up
                xTranslate /= DrawingEngine.miniScale;
                yTranslate /= DrawingEngine.miniScale;

                DrawingEngine.translate(xTranslate, yTranslate);
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    DrawingEngine.translate(
                            (this.xLastKnown - event.xScreen)/DrawingEngine.miniScale,
                            (this.yLastKnown - event.yScreen)/DrawingEngine.miniScale
                    );
                    DrawingEngine.start(false);
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mouseup: function(event) {
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.start(false);
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.MiniatureEventHandler[event.type])
                    this.MiniatureEventHandler[event.type](event);
            }
        };


        var UniqueIdentity = {
            lastId: 0,
            usedIds: [],
            nextId: function() {
                while(this.usedIds[++this.lastId]);
                this.usedIds[this.lastId] = true;
                return this.lastId;
            },
            takeId: function(id) {
                this.usedIds[id] = true;
                return id;
            }
        };

        var Editables = {
            descriptorEdit: {
                name: 'Descriptor',
                setMember: function (element, node) { node.descriptor = element.value; },
                getMember: function (node) { return node.descriptor },
                setElement: function (element, node) { element.value = node.descriptor },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '([A-Z][a-z]*)+',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Descriptive name', 'required', 'required']
            },
            twoMnemonicEdit: {
                name: 'Mnemonic',
                setMember: function (element, node) { node.mnemonic = element.value; },
                getMember: function (node) { return node.mnemonic },
                setElement: function (element, node) { element.value = node.mnemonic },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '[A-Z]{2}',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Two letter mnemonic (unique)', 'required', 'required']
            },
            threeMnemonicEdit: {
                name: 'Mnemonic',
                setMember: function (element, node) { node.mnemonic = element.value; },
                getMember: function (node) { return node.mnemonic },
                setElement: function (element, node) { element.value = node.mnemonic },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '[A-Z]{3}',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Three letter mnemonic (unique)', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                setMember: function (element, node) { node.dataRange = element.value; },
                getMember: function (node) { return node.dataRange },
                setElement: function (element, node) { element.value = node.dataRange },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Data type of stored value', 'required', 'required']
            },
            timeRangeEdit: {
                name: 'Time range',
                setMember: function (element, node) { node.timeRange = element.value; },
                getMember: function (node) { return node.timeRange },
                setElement: function (element, node) { element.value = node.timeRange },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Historization time type (expected update frequency)', 'required', 'required']
            },
            identityEdit: {
                name: 'Identity',
                setMember: function (element, node) { node.identity = element.value; },
                getMember: function (node) { return node.identity },
                setElement: function (element, node) { element.value = node.identity },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Identity data type', 'required', 'required']
            },
            generatorEdit: {
                name: 'Generator',
                setMember: function (element, node) { node.generator = element.checked; },
                getMember: function (node) { return node.generator },
                setElement: function (element, node) { element.checked = node.generator },
                getElement: function (element) { return element.checked },
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox', 'title', 'Identity generator (auto incremented sequence)']
            },
            roleEdit: {
                name: 'Role',
                setMember: function (element, node) { node.role = element.value; },
                getMember: function (node) { return node.role },
                setElement: function (element, node) { element.value = node.role },
                getElement: function (element) { return element.value },
                type: 'input',
                pattern: '([a-z][A-Z]*)+',
                event: 'blur',
                attributes: ['type', 'text', 'title', 'Role of the connected entity in the relationship', 'required', 'required']
            }
        };

        function AbstractNode(x, y) {
            this.xPosition = x;
            this.yPosition = y;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.velocity = 0;
            this.moving = true;
            this.fixed = false;
            this.shadowColor = UniqueColor.reserveUniqueColor();
            this.id = UniqueIdentity.nextId();
            this.edges = [];
            this.editables = [];
            // TODO: descriptions have to be handled separately
            //this.editables = [['Description','description','textarea','rows','5','cols','20']];
            this.operations = ['erase', 'connect'];
            this.incomplete = true;
        }
        AbstractNode.prototype = {
            description: '',
            xPosition: null,
            yPosition: null,
            xVelocity: null,
            yVelocity: null,
            velocity: null,
            edges: null,
            moving: true,
            shadowColor: '#ffffff',
            editables: null,
            incomplete: true,
            operations: null,
            type: 'Node',
            id: null,
            fixed: false,
            setId: function(id)  {
                if(id) {
                    UniqueIdentity.takeId(id);
                    this.id = id;
                }
            },
            getId: function() {
                if (!this.id)
                    this.id = UniqueIdentity.nextId();
                return this.id;
            },
            setFixed: function(fixed) {
                this.fixed = fixed;
            },
            getFixed: function() {
                return this.fixed;
            },
            getName: function() {
                return '';
            },
            // subclasses must override these
            getMass: function() {
                return null;
            },
            getCharge: function() {
                return null;
            },
            toString: function() {
                return this.getName().toString();
            },
            isEmpty: function(value) {
                return !value || value == null || value.toString().replace(/^[^\S]+/,'').replace(/[^\S]+$/,'') == '';
            },
            isIncomplete: function() {
                var editable;
                for(var i = 0; editable = this.editables[i]; i++) {
                    // only those that are supposed to contain text (i.e. not checkboxes, select lists, ...)
                    if(editable.pattern) {
                        if(this.isEmpty(editable.getMember(this)))
                            return true;
                        if(!editable.getMember(this).toString().match(new RegExp('^' + editable.pattern + '$')))
                            return true;
                    }
                }
                return false;
            },
            // override in order to check conditions under which the node breaks the model
            validate: function() {
                return true;
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            toSVG: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addLayoutXML: function(element, schema) {
                if(!this.isEmpty(this.description)) {
                    var description = schema.createElement("description");
                    description.innerHTML = this.description;
                    element.appendChild(description);
                }
                var layout = schema.createElement("layout");
                layout.setAttribute("x", this.xPosition.toFixed(2));
                layout.setAttribute("y", this.yPosition.toFixed(2));
                layout.setAttribute("fixed", this.getFixed());
                element.appendChild(layout);
            },
            stop: function() {
                this.moving = false;
            },
            // movement is propagated to the edges of a node
            start: function() {
                this.moving = true;
                for(var i = 0; i < this.edges.length; i++)
                    this.edges[i].start();
            },
            nameXOffset: function() {
                return 20;
            },
            toSVGName: function(svg, g) {
                var text = svg.createElementNS(SVGNS, 'text');
                text.setAttributeNS(null, 'font-size', 10);
                text.setAttributeNS(null, 'font-family', 'sans-serif');
                text.appendChild(svg.createTextNode(this.getName()));
                var i, edge, xAverage = 0;
                for(i = 0; edge = this.edges[i]; i++)
                    xAverage += edge.xPosition;
                xAverage /= this.edges.length;
                var currentDistance, smallestDistance, yClosest;
                for(i = 0; edge = this.edges[i]; i++) {
                    currentDistance = LayoutEngine.absolute(this.yPosition - edge.yPosition);
                    if(!i || ((this.xPosition < xAverage && edge.xPosition < this.xPosition) || (this.xPosition >= xAverage && edge.xPosition >= this.xPosition) && (currentDistance < smallestDistance))) {
                        smallestDistance = currentDistance;
                        yClosest = edge.yPosition;
                    }
                }
                var nameYOffset = -7 + (yClosest ? (this.yPosition < yClosest ? -3 : 3) : 0);
                if(this.xPosition < xAverage) {
                    text.setAttributeNS(null, 'x', (this.xPosition - this.nameXOffset()).toFixed(2));
                    text.setAttributeNS(null, 'text-anchor', 'end');
                }
                else {
                    text.setAttributeNS(null, 'text-anchor', 'start');
                    text.setAttributeNS(null, 'x', (this.xPosition + this.nameXOffset()).toFixed(2));
                }
                text.setAttributeNS(null, 'y', (this.yPosition - nameYOffset).toFixed(2));
                if(this.incomplete)
                    text.setAttributeNS(null, 'fill', '#e00');
                else
                    text.setAttributeNS(null, 'fill', '#000');
                g.appendChild(text);
            },
            drawName: function(context) {
                var i, edge, xAverage = 0;
                for(i = 0; edge = this.edges[i]; i++)
                    xAverage += edge.xPosition;
                xAverage /= this.edges.length;
                var currentDistance, smallestDistance, yClosest;
                for(i = 0; edge = this.edges[i]; i++) {
                    currentDistance = LayoutEngine.absolute(this.yPosition - edge.yPosition);
                    if(!i || ((this.xPosition < xAverage && edge.xPosition < this.xPosition) || (this.xPosition >= xAverage && edge.xPosition >= this.xPosition) && (currentDistance < smallestDistance))) {
                        smallestDistance = currentDistance;
                        yClosest = edge.yPosition;
                    }
                }
                var nameYOffset = -7 + (yClosest ? (this.yPosition < yClosest ? -3 : 3) : 0);
                context.save();
                var nameWidth = context.measureText(this.getName()).width;
                if(this.xPosition < xAverage)
                    context.translate(-nameWidth - this.nameXOffset(), nameYOffset);
                else
                    context.translate(this.nameXOffset(), nameYOffset);
                context.textBaseline = 'top';
                if(this.incomplete)
                    context.fillStyle = '#e00';
                else
                    context.fillStyle = '#000';
                context.fillText(this.getName(), this.xPosition, this.yPosition);
                context.restore();
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(context) {
                if(DEBUG) {
                    context.beginPath();
                    context.moveTo(this.xPosition, this.yPosition);
                    // draw an exaggerated velocity vector
                    context.lineTo(this.xPosition + LayoutEngine.normalDistance * this.xVelocity, this.yPosition + LayoutEngine.normalDistance * this.yVelocity);
                    context.strokeStyle = '#008800';
                    context.lineWidth = 0.5;
                    context.stroke();
                    context.fillStyle = '#ffffff';
                    context.fillRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                    context.strokeRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                }
            },
            // this is how a node draws itself on the shadow context
            drawShadow: function(context) {
                this.drawOutline(context);
                context.fillStyle = this.shadowColor;
                context.fill();
            },
            // this is used to draw the outline of a node, used in the shadow context
            drawOutline: function(context) {
                // subclasses implements this
            },
            // this is how to draw a graphical representation of the fact that a node is moving
            drawMoving: function(context) {
                if(this.moving && !this.getFixed()) {
                    var shadowOffsetX = 4 * ((this.velocity > 2) ? 2 : this.velocity);
                    var shadowOffsetY = 4 * ((this.velocity > 3) ? 3 : this.velocity);
                    context.save();
                    context.translate(-shadowOffsetX, shadowOffsetY);
                    this.drawOutline(context);
                    var color = Math.floor(96 + 128 * (1 - 1/(1 + this.velocity)));
                    // shift the color slightly towards red
                    context.fillStyle = 'rgb(' + (color + 8) + ',' + (color + 4) + ',' + color + ')';
                    context.fill();
                    context.restore();
                }
            },
            drawFixed: function(context) {
                if(this.getFixed()) {
                    context.fillStyle = '#000000';
                    context.fillRect(this.xPosition - 1, this.yPosition - 1, 2, 2);
                }
            }
        };

        function Attribute(x, y, historized) {
            // call the parent constructor
            AbstractNode.call(this, x, y);
            // set static variables
            Attribute.mass = 1;
            Attribute.charge = 1;
            // set members
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.knotted = false;
            this.historized = historized;
            this.operations.push('toggleKnotted','toggleHistorized');
            this.type = 'Attribute';
        }
        Attribute.prototype = {
            mnemonic: '',
            descriptor: '',
            dataRange: '',
            timeRange: '',
            historized: false,
            knotted: false,
            validate: function() {
                var i, edge, anchor, knot, otherNode;
                for(i = 0; edge = this.edges[i]; i++) {
                    otherNode = (edge.node == this ? edge.otherNode : edge.node);
                    if(otherNode instanceof Anchor)
                        anchor = otherNode;
                    else if (otherNode instanceof Knot)
                        knot = otherNode;
                }
                // there must be an anchor and if there is a knot the attribute must be knotted
                return !this.isIncomplete() && anchor && (knot ? this.getKnotted() : true);
            },
            getMass: function() {
                return Attribute.mass;
            },
            getCharge: function() {
                return Attribute.charge;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.timeRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.timeRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                var index = this.editables.indexOf(Editables.dataRangeEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.dataRangeEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || '???';
                var descriptor = element.getAttribute("descriptor") || '!Unnamed!';
                var timeRange = element.getAttribute("timeRange") || '';
                var historized = timeRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || '';
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || '';
                var parent = element.parentNode;
                var attribute = new Attribute(x, y, historized);
                attribute.setFixed(fixed);
                attribute.setKnotted(knotted);
                attribute.timeRange = timeRange;
                attribute.dataRange = dataRange;
                attribute.description = description ? description.firstChild.nodeValue : '';
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                var anchorLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Anchor)
                        anchorLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var knotLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Knot)
                        knotLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var anchor = anchorLookup[parent.getAttribute("mnemonic")];
                Model.addEdge(new Edge(attribute, anchor, true));
                if(knotted) {
                    var grandparent = parent.parentNode;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(i = 0; i < knots.length; i++) {
                        if(knots[i].getAttribute("mnemonic") == knotRange) {
                            var knot = knotLookup[knots[i].getAttribute("mnemonic")];
                            Model.addEdge(new Edge(attribute, knot, false));
                            break; // only one should match
                        }
                    }                    
                }
                attribute.incomplete = attribute.isIncomplete();
                return attribute;
            },
            getName: function() {
                var anchor, edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.otherNode instanceof Anchor)
                        anchor = edge.otherNode;
                return anchor.mnemonic + "_" + this.mnemonic + "_" + anchor.descriptor + "_" + this.descriptor;
            },
            nameXOffset: function() {
                if(this.historized)
                    return 22;
                else
                    return 20;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("mnemonic", this.mnemonic);
                attribute.setAttribute("descriptor", this.descriptor);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.timeRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.edges[i]; i++)
                        if(edge.otherNode instanceof Knot)
                            knot = edge.otherNode;
                    attribute.setAttribute("knotRange", knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.dataRange);
                }
                this.addLayoutXML(attribute, schema);
                element.appendChild(attribute);
            },
            drawOutline: function(context) {
                // the outermost path
                context.beginPath();
                if(this.historized)
                    context.arc(this.xPosition, this.yPosition, 12, 0, 2*Math.PI, false);
                else
                    context.arc(this.xPosition, this.yPosition, 10, 0, 2*Math.PI, false);
            },
            toSVG: function(svg, g) {
                var group = svg.createElementNS(SVGNS, 'g');
                var circle = svg.createElementNS(SVGNS, 'circle');
                circle.setAttributeNS(null, 'fill', '#fff');
                circle.setAttributeNS(null, 'stroke', '#f88');
                circle.setAttributeNS(null, 'stroke-width', 1.5);
                circle.setAttributeNS(null, 'cx', this.xPosition.toFixed(2));
                circle.setAttributeNS(null, 'cy', this.yPosition.toFixed(2));
                if(this.historized)
                    circle.setAttributeNS(null, 'r', 12);
                else
                    circle.setAttributeNS(null, 'r', 10);
                group.appendChild(circle);
                if(this.historized) {
                    circle = svg.createElementNS(SVGNS, 'circle');
                    circle.setAttributeNS(null, 'fill', '#fff');
                    circle.setAttributeNS(null, 'stroke', '#f88');
                    circle.setAttributeNS(null, 'stroke-width', 1.5);
                    circle.setAttributeNS(null, 'cx', this.xPosition.toFixed(2));
                    circle.setAttributeNS(null, 'cy', this.yPosition.toFixed(2));
                    circle.setAttributeNS(null, 'r', 7);
                    group.appendChild(circle);
                }
                g.appendChild(group);
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    // then we get back to drawing the actual symbol
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 7, 0, 2*Math.PI, false);
                    context.fill();
                    context.stroke();
                }
                else {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Attribute, AbstractNode);

        function Anchor(x, y) {
            AbstractNode.call(this, x, y);
            Anchor.mass = 1;
            Anchor.charge = 1;
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.twoMnemonicEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.operations.push('addAttribute','addTie','addTieAndAnchor');
            this.type = 'Anchor';
        }
        Anchor.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: '',
            generator: true,
            getMass: function() {
                return Anchor.mass;
            },
            getCharge: function() {
                return Anchor.charge;
            },
            getName: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            nameXOffset: function() {
                return 20;
            },
            validate: function() {
                var i, edge, otherNode, ties = 0, mnemonics = {};
                for(i = 0; edge = this.edges[i]; i++) {
                    otherNode = (edge.node == this ? edge.otherNode : edge.node);
                    if(otherNode instanceof Attribute) {
                        if(mnemonics[otherNode.mnemonic]) {
                            Model.tag(otherNode, 'The mnemonic ' + otherNode.mnemonic + ' is not unique among the other attributes on the same anchor');
                        }
                        mnemonics[otherNode.mnemonic] = otherNode;
                    }
                    else if (otherNode instanceof Tie)
                        ties++;
                }
                if(!ties)
                    Model.tag(this, 'This anchor has no ties');
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "??";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var idElement, generator = true;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") == 'true';
                var anchor = new Anchor(x, y);
                anchor.setFixed(fixed);
                anchor.description = description ? description.firstChild.nodeValue : '';
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                anchor.generator = generator;
                anchor.incomplete = anchor.isIncomplete();
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("mnemonic", this.mnemonic);
                anchor.setAttribute("descriptor", this.descriptor);
                anchor.setAttribute("identity", this.identity);

                var identity = schema.createElement("identity");
                identity.setAttribute("generator", this.generator);
                anchor.appendChild(identity);

                var edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.node instanceof Attribute)
                        edge.node.addXML(anchor, schema);
                this.addLayoutXML(anchor, schema);
                return anchor;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition - 10);
                context.closePath();
            },
            toSVG: function(svg, g) {
                var group = svg.createElementNS(SVGNS, 'g');
                var rect = svg.createElementNS(SVGNS, 'rect');
                rect.setAttributeNS(null, 'fill', '#b55');
                rect.setAttributeNS(null, 'x', (this.xPosition - 10).toFixed(2));
                rect.setAttributeNS(null, 'y', (this.yPosition - 10).toFixed(2));
                rect.setAttributeNS(null, 'width', 20);
                rect.setAttributeNS(null, 'height', 20);
                group.appendChild(rect);
                g.appendChild(group);
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#bb5555';
                context.fill();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Anchor, AbstractNode);

        function Knot(x, y) {
            AbstractNode.call(this, x, y);
            Knot.mass = 1;
            Knot.charge = 1;
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.type = 'Knot';            
        }
        Knot.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: '',
            dataRange: '',
            generator: false,
            getMass: function() {
                return Knot.mass;
            },
            getCharge: function() {
                return Knot.charge;
            },
            getName: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            nameXOffset: function() {
                return 18;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "???";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var dataRange = element.getAttribute("dataRange") || '';
                var idElement, generator = false;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") == 'true';
                var knot = new Knot(x, y);
                knot.setFixed(fixed);
                knot.description = description ? description.firstChild.nodeValue : '';
                knot.mnemonic = mnemonic;
                knot.descriptor = descriptor;
                knot.identity = identity;
                knot.dataRange = dataRange;
                knot.generator = generator;
                knot.incomplete = knot.isIncomplete();
                return knot;
            },
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("mnemonic", this.mnemonic);
                knot.setAttribute("descriptor", this.descriptor);
                knot.setAttribute("identity", this.identity);
                knot.setAttribute("dataRange", this.dataRange);

                var identity = schema.createElement("identity");
                identity.setAttribute("generator", this.generator);
                knot.appendChild(identity);                

                this.addLayoutXML(knot, schema);
                return knot;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 6, this.yPosition - 9);
                context.lineTo(this.xPosition + 6, this.yPosition - 9);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition - 9, this.xPosition + 9, this.yPosition - 6);
                context.lineTo(this.xPosition + 9, this.yPosition + 6);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition + 9, this.xPosition + 6, this.yPosition + 9);
                context.lineTo(this.xPosition - 6, this.yPosition + 9);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition + 9, this.xPosition - 9, this.yPosition + 6);
                context.lineTo(this.xPosition - 9, this.yPosition - 6);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition - 9, this.xPosition - 6, this.yPosition - 9);
            },
            toSVG: function(svg, g) {
                var group = svg.createElementNS(SVGNS, 'g');
                var rect = svg.createElementNS(SVGNS, 'rect');
                rect.setAttributeNS(null, 'fill', '#fff');
                rect.setAttributeNS(null, 'stroke', '#f88');
                rect.setAttributeNS(null, 'stroke-width', 1.5);
                rect.setAttributeNS(null, 'x', (this.xPosition - 9).toFixed(2));
                rect.setAttributeNS(null, 'y', (this.yPosition - 9).toFixed(2));
                rect.setAttributeNS(null, 'rx', 3);
                rect.setAttributeNS(null, 'ry', 3);
                rect.setAttributeNS(null, 'width', 18);
                rect.setAttributeNS(null, 'height', 18);
                group.appendChild(rect);
                g.appendChild(group);
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#ffffff';
                context.fill();
                context.strokeStyle = '#ff8888';
                context.lineWidth = 1.5;
                context.stroke();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Knot, AbstractNode);

        function Tie(x, y, historized) {
            AbstractNode.call(this, x, y);
            Tie.mass = 1;
            Tie.charge = 1;
            this.historized = historized;
            this.incomplete = this.isIncomplete();
            this.operations.push('toggleHistorized','addKnot','addAnchor');
            this.type = 'Tie';
        }
        Tie.prototype = {
            timeRange: '',
            historized: false,
            getMass: function() {
                return Tie.mass;
            },
            getCharge: function() {
                return Tie.charge;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.timeRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.timeRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            isIncomplete: function() {
                return AbstractNode.prototype.isIncomplete.apply(this, arguments) || !this.getName().match(/^(_?[A-Z]+_[a-zA-Z]+)+$/);
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var timeRange = element.getAttribute("timeRange") || '';
                var historized = timeRange ? true : false;
                var tie = new Tie(x, y, historized);
                tie.setFixed(fixed);
                tie.timeRange = timeRange;
                tie.description = description ? description.firstChild.nodeValue : '';
                var anchorLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Anchor)
                        anchorLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var knotLookup = {};
                for(i = 0; i < Model.nodes.length; i++)
                    if(Model.nodes[i] instanceof Knot)
                        knotLookup[Model.nodes[i].mnemonic] = Model.nodes[i];
                var grandparent = element.parentNode.parentNode;
                var j, type, edge, role, identifier, anchor, anchorRoles = element.getElementsByTagName("anchorRole");
                for(i = 0; i < anchorRoles.length; i++) {
                    type = anchorRoles[i].getAttribute("type") || "??";
                    role = anchorRoles[i].getAttribute("role") || "!unknown!";
                    identifier = anchorRoles[i].getAttribute("identifier") || false;
                    var anchors = grandparent.getElementsByTagName("anchor");
                    for(j = 0; j < anchors.length; j++) {
                        if(anchors[j].getAttribute("mnemonic") == type) {
                            anchor = anchorLookup[anchors[j].getAttribute("mnemonic")];
                            edge = new Edge(tie, anchor, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            break; // only one should match
                        }
                    }
                }
                var knot, knotRoles = element.getElementsByTagName("knotRole");
                for(i = 0; i < knotRoles.length; i++) {
                    type = knotRoles[i].getAttribute("type") || "???";
                    role = knotRoles[i].getAttribute("role") || "!unknown!";
                    identifier = knotRoles[i].getAttribute("identifier") || false;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(j = 0; i < knots.length; j++) {
                        if(knots[j].getAttribute("mnemonic") == type) {
                            knot = knotLookup[knots[j].getAttribute("mnemonic")];
                            edge = new Edge(tie, knot, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            break; // only one should match
                        }
                    }
                }
                tie.incomplete = tie.isIncomplete();
                return tie;
            },
            getName: function() {
                var i, edge, name="";
                for(i = 0; edge = this.edges[i]; i++) {
                    if(i > 0)
                        name += "_";
                    name += edge.otherNode.mnemonic + "_" + edge.role;
                }
                return name;
            },
            nameXOffset: function() {
                if(this.historized)
                    return 26;
                else
                    return 24;
            },
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                if(this.historized)
                    tie.setAttribute("timeRange", this.timeRange);
                for(var i = 0; i < this.edges.length; i++) {
                    var role;
                    var node = this.edges[i].otherNode;
                    if(this.edges[i].otherNode instanceof Anchor)
                        role = schema.createElement("anchorRole");
                    else if(this.edges[i].otherNode instanceof Knot)
                        role = schema.createElement("knotRole");
                    role.setAttribute("role", this.edges[i].role);
                    role.setAttribute("type", node.mnemonic);
                    role.setAttribute("identifier", this.edges[i].identifier);
                    tie.appendChild(role);
                }
                this.addLayoutXML(tie, schema);
                return tie;
            },
            drawOutline: function(context) {
                if(this.historized) {
                    context.beginPath();
                    context.moveTo(this.xPosition - 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 17);
                    context.lineTo(this.xPosition + 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 17);
                    context.lineTo(this.xPosition - 18, this.yPosition);
                    context.closePath();
                }
                else {
                    context.beginPath();
                    context.moveTo(this.xPosition - 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 14);
                    context.lineTo(this.xPosition + 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 14);
                    context.lineTo(this.xPosition - 15, this.yPosition);
                    context.closePath();
                }
            },
            toSVG: function(svg, g) {
                var group = svg.createElementNS(SVGNS, 'g');
                var path;
                if(this.historized) {
                    path = svg.createElementNS(SVGNS, 'path');
                    path.setAttributeNS(null, 'fill', '#fff');
                    path.setAttributeNS(null, 'stroke', '#a8a8a8');
                    path.setAttributeNS(null, 'stroke-width', 1.5);
                    path.setAttributeNS(null, 'd', 'M ' + (this.xPosition - 18).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' L ' + this.xPosition.toFixed(2) + ',' + (this.yPosition + 17).toFixed(2) +
                            ' ' + (this.xPosition + 18).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' ' + this.xPosition.toFixed(2) + ',' + (this.yPosition - 17).toFixed(2) +
                            ' ' + (this.xPosition - 18).toFixed(2) + ',' + this.yPosition.toFixed(2));
                    group.appendChild(path);
                    path = svg.createElementNS(SVGNS, 'path');
                    path.setAttributeNS(null, 'fill', '#a8a8a8');
                    path.setAttributeNS(null, 'd', 'M ' + (this.xPosition - 12).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' L ' + this.xPosition.toFixed(2) + ',' + (this.yPosition + 11).toFixed(2) +
                            ' ' + (this.xPosition + 12).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' ' + this.xPosition.toFixed(2) + ',' + (this.yPosition - 11).toFixed(2) +
                            ' ' + (this.xPosition - 12).toFixed(2) + ',' + this.yPosition.toFixed(2));
                    group.appendChild(path);
                }
                else {
                    path = svg.createElementNS(SVGNS, 'path');
                    path.setAttributeNS(null, 'fill', '#a8a8a8');
                    path.setAttributeNS(null, 'd', 'M ' + (this.xPosition - 15).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' L ' + this.xPosition.toFixed(2) + ',' + (this.yPosition + 14).toFixed(2) +
                            ' ' + (this.xPosition + 15).toFixed(2) + ',' + this.yPosition.toFixed(2) +
                            ' ' + this.xPosition.toFixed(2) + ',' + (this.yPosition - 14).toFixed(2) +
                            ' ' + (this.xPosition - 15).toFixed(2) + ',' + this.yPosition.toFixed(2));
                    group.appendChild(path);
                }
                g.appendChild(group);
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#a8a8a8';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.moveTo(this.xPosition - 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 11);
                    context.lineTo(this.xPosition + 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 11);
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                else {
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Tie, AbstractNode);

        function Edge(node, otherNode, identifier) {
            // assume that the control point and midway point coincide with the center point
            this.centerPoint = {
                xPosition: node.xPosition + (otherNode.xPosition - node.xPosition)/2,
                yPosition: node.yPosition + (otherNode.yPosition - node.yPosition)/2
            };
            this.controlPoint = {
                xPosition: this.centerPoint.xPosition,
                yPosition: this.centerPoint.yPosition
            };
            AbstractNode.call(this, this.controlPoint.xPosition, this.controlPoint.yPosition);
            Edge.mass = 1;
            Edge.charge = 1;
            this.role = '!unknown!';
            this.node = node;
            this.otherNode = otherNode;
            this.identifier = identifier;
            node.edges.push(this);
            otherNode.edges.push(this);
            this.edges.push(node);
            this.edges.push(otherNode);
            this.editables.push(Editables.roleEdit);
            this.operations.push('toggleIdentifier');
            this.incomplete = false;
            this.type = 'Edge';
        }
        Edge.prototype = {
            role: '',
            node: null,
            otherNode: null,
            controlPoint: { xPosition: null, yPosition: null },
            centerPoint: { xPosition: null, yPosition: null },
            identifier: true,
            getMass: function() {
                return Edge.mass;
            },
            getCharge: function() {
                return Edge.charge;
            },
            // overload to remove propagation of movement
            start: function() {
                this.moving = true;
            },
            // edges never fixate
            setFixed: function(fixed) {
                this.fixed = false;
            },
            getName: function() {
                return this.role;
            },
            toSVG: function(svg, g) {
                var group = svg.createElementNS(SVGNS, 'g');
                var path = svg.createElementNS(SVGNS, 'path');
                path.setAttributeNS(null, 'fill', 'none');
                path.setAttributeNS(null, 'stroke', '#000');
                path.setAttributeNS(null, 'd', 'M ' + this.node.xPosition.toFixed(2) + ',' + this.node.yPosition.toFixed(2) +
                        ' Q ' + this.controlPoint.xPosition.toFixed(2) + ',' + this.controlPoint.yPosition.toFixed(2) +
                        ' ' + this.otherNode.xPosition.toFixed(2) + ',' + this.otherNode.yPosition.toFixed(2));
                group.appendChild(path);
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    var circle = svg.createElementNS(SVGNS, 'circle');
                    if(this.identifier)
                        circle.setAttributeNS(null, 'fill', '#766');
                    else
                        circle.setAttributeNS(null, 'fill', '#fff');
                    circle.setAttributeNS(null, 'stroke', '#000');
                    circle.setAttributeNS(null, 'cx', this.xPosition.toFixed(2));
                    circle.setAttributeNS(null, 'cy', this.yPosition.toFixed(2));
                    circle.setAttributeNS(null, 'r', 6);
                    group.appendChild(circle);
                }
                g.appendChild(group);
            },
            drawMoving: function(context) {
                if((this.node.moving && !this.node.getFixed()) || (this.otherNode.moving && !this.otherNode.getFixed())) {
                    var nodeShadowOffsetX = 0;
                    var nodeShadowOffsetY = 0;
                    if(this.node.moving && !this.node.getFixed()) {
                        nodeShadowOffsetX = 4 * ((this.node.velocity > 2) ? 2 : this.node.velocity);
                        nodeShadowOffsetY = 4 * ((this.node.velocity > 3) ? 3 : this.node.velocity);
                    }
                    var otherNodeShadowOffsetX = 0;
                    var otherNodeShadowOffsetY = 0;
                    if(this.otherNode.moving && !this.otherNode.getFixed()) {
                        otherNodeShadowOffsetX = 4 * ((this.otherNode.velocity > 2) ? 2 : this.otherNode.velocity);
                        otherNodeShadowOffsetY = 4 * ((this.otherNode.velocity > 3) ? 3 : this.otherNode.velocity);
                    }
                    var averageVelocity = (this.node.velocity + this.otherNode.velocity)/2;
                    var controlOffsetX = (nodeShadowOffsetX + otherNodeShadowOffsetX)/2;
                    var controlOffsetY = (nodeShadowOffsetY + otherNodeShadowOffsetY)/2;
                    context.beginPath();
                    context.moveTo(this.node.xPosition - nodeShadowOffsetX, this.node.yPosition + nodeShadowOffsetY);
                    context.quadraticCurveTo(this.controlPoint.xPosition - controlOffsetX, this.controlPoint.yPosition + controlOffsetY,
                            this.otherNode.xPosition - otherNodeShadowOffsetX, this.otherNode.yPosition + otherNodeShadowOffsetY);
                    var color = Math.floor(96 + 128 * (1 - 1/(1 + averageVelocity)));
                    // shift the color slightly towards red
                    context.strokeStyle = 'rgb(' + (color + 8) + ',' + (color + 4) + ',' + color + ')';
                    context.lineWidth = 1.0;
                    context.stroke();
                }
            },
            draw: function(context) {
                context.beginPath();
                context.moveTo(this.node.xPosition, this.node.yPosition);
                context.quadraticCurveTo(this.controlPoint.xPosition, this.controlPoint.yPosition, this.otherNode.xPosition, this.otherNode.yPosition);
                context.strokeStyle = '#000000';
                context.lineWidth = 1.0;
                context.stroke();
                if(DEBUG) {
                    context.beginPath();
                    context.arc(this.controlPoint.xPosition, this.controlPoint.yPosition, 4, 0, 2*Math.PI, false);
                    context.fillStyle = '#00bb00';
                    context.fill();
                    context.stroke();
                }
                // show if edges on ties are identifiers or not by drawing a filled or empty circle
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 6, 0, 2*Math.PI, false);
                    context.stroke();
                    if(this.identifier)
                        context.fillStyle = '#766';
                    else
                        context.fillStyle = '#fff';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
            },
            drawShadow: function(context) {
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 6, 0, 2*Math.PI, false);
                    context.fillStyle = this.shadowColor;
                    context.fill();
                }
            }
        };

        // inheritance
        extend(Edge, AbstractNode);


        // global function providing inheritance
        function extend(child, supertype){
            child.prototype.supertype = {};
            for(var member in supertype.prototype)
                if(!child.prototype[member])
                    child.prototype[member] = supertype.prototype[member];
                else
                    child.prototype.supertype[member] = supertype.prototype[member];
            /* moving away from this type of inheritance, as it has worse performance, and not supported in IE9 */
            //child.prototype.__proto__ = supertype.prototype;
        }

        function ModalBackground() {
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
            }
        };

        function URLPopover(url) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "urlPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('iframe');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.src = url;

            popover.appendChild(content);
            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        URLPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CodePopover(documentFragment, preformatted) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "codePopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            if(preformatted)
                content.setAttribute("class", "preformatted");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.appendChild(documentFragment);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CodePopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CloudBrowserPopover(modelList) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudBrowserPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';

            var models = modelList.getElementsByTagName('Model');
            var model, modelContainer;
            for(var i = 0; i < models.length; i++) {
                model = models.item(i);
                modelContainer = document.createElement('div');
                modelContainer.modelId = model.getAttribute("modelId");
                modelContainer.modelName = model.getAttribute("modelName");
                modelContainer.modelScope = model.getAttribute("scope") || "private";
                modelContainer.modelKeywords = model.getAttribute("keywords");
                modelContainer.addEventListener('click', function(e) {
                    Actions.loadModelFromCloud(this.modelId, this.modelName, this.modelScope, this.modelKeywords);
                    self.close(e); 
                }, false);
                var icon = document.createElement('img');
                icon.setAttribute("src", model.getAttribute("icon"));
                var name = document.createElement("p");
                name.appendChild(document.createTextNode(model.getAttribute("modelName")));
                name.className = 'modelName';
                var keywords = document.createElement("p");
                keywords.className = 'modelKeywords';
                keywords.appendChild(document.createTextNode(model.getAttribute("keywords")));
                modelContainer.appendChild(icon);
                modelContainer.appendChild(name);
                modelContainer.appendChild(keywords);
                content.appendChild(modelContainer);
            }

            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudBrowserPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CloudSaverPopover() {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudSaverPopover");
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");

            var icon = document.createElement('img');
            icon.setAttribute('src', DrawingEngine.miniatureCanvas.toDataURL());
            content.appendChild(icon);

            var table = document.createElement('table');
            var tr = document.createElement('tr');
            var td = document.createElement('td');
            td.appendChild(document.createTextNode('Model name: '));
            tr.appendChild(td);
            td = document.createElement('td');
            var modelName = document.createElement('input');
            modelName.setAttribute('type', 'text');
            if(Model.name && Model.name != null)
                modelName.value = Model.name;
            modelName.addEventListener('change', function() { Model.name = this.value; }, false);
            td.appendChild(modelName);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelScope = document.createElement('select');
            var privateOption = document.createElement('option');
            privateOption.setAttribute('value', 'private');
            privateOption.appendChild(document.createTextNode('Private'));
            modelScope.appendChild(privateOption);
            var publicOption = document.createElement('option');
            publicOption.setAttribute('value', 'public');
            publicOption.appendChild(document.createTextNode('Public'));
            modelScope.appendChild(publicOption);
            if(Model.scope && Model.scope != null)
                modelScope.value = Model.scope;
            modelScope.addEventListener('change', function() { Model.scope = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Scope: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelScope);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelKeywords = document.createElement('input');
            modelKeywords.setAttribute('type', 'text');
            modelKeywords.setAttribute('placeholder', 'comma separated list');
            if(Model.keywords && Model.keywords != null)
                modelKeywords.value = Model.keywords;
            modelKeywords.addEventListener('change', function() { Model.keywords = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Keywords: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelKeywords);
            tr.appendChild(td);
            table.appendChild(tr);
            content.appendChild(table);

            if(Model.id) {
                var overwriteButton = document.createElement('input');
                overwriteButton.setAttribute('type', 'button');
                overwriteButton.className = 'overwriteButton';
                overwriteButton.value = 'Overwrite';
                overwriteButton.addEventListener('click', function(e) {
                    Actions.saveModelInCloud(false);
                    self.close(e);
                }, false);
                content.appendChild(overwriteButton);
            }
            var saveButton = document.createElement('input');
            saveButton.setAttribute('type', 'button');
            saveButton.className = 'saveButton';
            saveButton.value = 'Save New';
            saveButton.addEventListener('click', function(e) {
                Model.id = null;
                Actions.saveModelInCloud(false);
                self.close(e);
            }, false);
            content.appendChild(saveButton);

            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudSaverPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };        

        function ContextMenu(hoveredNode, selectedNodes) {
            var self = this;

            this.hoveredNode = hoveredNode;
            this.selectedNodes = selectedNodes;
            var contextMenu = document.createElement('div');
            contextMenu.setAttribute('id', 'contextMenu');
            this.toggler = document.createElement('div');
            this.toggler.setAttribute('class', 'toggler collapsed');
            this.toggler.addEventListener('click', function(event) { self.toggle() }, false);
            contextMenu.appendChild(this.toggler);
            this.contextMenu = contextMenu;

            this.topper = document.createElement('div');
            this.topper.setAttribute('class', 'topper unselectable');
            this.topper.addEventListener('mousedown', function(event) { self.mousedown(event); }, false);
            this.divider = document.createElement('div');
            this.divider.setAttribute('class', 'divider');
            
            var editable;
            this.editsHaveBeenMade = false;
            this.editables = document.createElement('table');
            this.editables.setAttribute('class', 'items');
            this.showEditables = false;

            var i, j, tr;
            // if we are operating a single node, show its editable fields
            if(selectedNodes.length == 0 || (selectedNodes.length == 1 && selectedNodes[0] == hoveredNode)) {
                this.topper.appendChild(document.createTextNode("Edit " + hoveredNode.type));
                for(i = 0; editable = hoveredNode.editables[i]; i++) {
                    this.showEditables = true;
                    var element = document.createElement(editable.type);
                    element.className = 'editable';
                    if(editable.pattern)
                        element.setAttribute('pattern', editable.pattern);
                    for(j = 0; j < editable.attributes.length;) {
                        var attribute = editable.attributes[j++];
                        var value = editable.attributes[j++];
                        element.setAttribute(attribute, value);
                    }
                    editable.setElement(element, hoveredNode);
                    element.editable = editable;
                    element.addEventListener(editable.event, function() { self.edit(this, hoveredNode); }, false);
                    element.addEventListener('change', function() { self.editsHaveBeenMade = true; }, false);
                    if(editable.pattern)
                        element.addEventListener('invalid', function() { self.invalid(this, hoveredNode); }, false);
                    tr = document.createElement('tr');
                    tr.setAttribute('valign', 'top');
                    var td1 = document.createElement('td');
                    td1.appendChild(document.createTextNode(editable.name + ":"));
                    tr.appendChild(td1);
                    var td2 = document.createElement('td');
                    td2.appendChild(element);
                    tr.appendChild(td2);
                    this.editables.appendChild(tr);
                }
            }
            else {
                this.topper.appendChild(document.createTextNode("Edit selection"));
            }
            // operations are defined as 'method', 'display name', 'optional rule'
            var allOperations = [
                ['erase', 'Delete selected...'],
                ['toggleKnotted', 'Toggle Knotted'], // TODO: only remove knot if it is the last attribute
                ['toggleHistorized', 'Toggle Historized'],
                ['addAttribute', 'Add Attribute'],
                ['addTie', 'Add Tie'],
                ['addAnchor', 'Add Anchor'],
                ['addKnot', 'Add Knot'],    
                ['addTieAndAnchor', 'Add tied Anchor'],
                ['toggleIdentifier', 'Toggle Identifier'],
                ['connect', 'Connect', function(allNodes) {
                    if(allNodes.length != 2)
                        return false;
                    var node, anchors = 0, ties = 0, knots = 0, knotted, attributes = 0;
                    for(var i = 0; node = allNodes[i]; i++) {
                        if(node instanceof Anchor)
                            anchors++;
                        else if(node instanceof Tie)
                            ties++;
                        else if(node instanceof Knot)
                            knots++;
                        else if(node instanceof Attribute) {
                            attributes++;
                            knotted = node.getKnotted();
                        }
                    }
                    return anchors && ties || knots && ties || attributes && knots && !knotted;
                }]
            ];
            var supportedOperations = [];

            var allNodes = selectedNodes.slice(0);
            if(allNodes.indexOf(hoveredNode) < 0)
                allNodes.push(hoveredNode);

            var validator;
            for(i = 0; i < allOperations.length; i++) {
                if(this.isSupported(allOperations[i][0], allNodes)) {
                    if(validator = allOperations[i][2]) {
                        if(validator(allNodes))
                            supportedOperations.push(allOperations[i]);
                    }
                    else
                        supportedOperations.push(allOperations[i]);
                }
            }

            this.operators = document.createElement('div');
            this.operators.setAttribute('class', 'operators');
            for(i = 0; i < supportedOperations.length; i++) {
                var operator = document.createElement('div');
                operator.setAttribute('class', 'operator');
                operator.appendChild(document.createTextNode(supportedOperations[i][1]));
                operator.method = supportedOperations[i][0];
                operator.addEventListener('click', function() { self.operate(this, allNodes); }, false);
                this.operators.appendChild(operator);
            }

            this.updatePosition();
            document.body.appendChild(contextMenu);
            return this;
        }
        ContextMenu.prototype = {
            contextMenu: null,
            hoveredNode: null,
            selectedNodes: null,
            showEditables: false,
            editables: null,
            operators: null,
            divider: null,
            topper: null,
            toggler: null,
            collapsed: true,
            modalBackground: null,
            editsHaveBeenMade: false,
            dragging: false,
            operate: function(button, nodes) {
                Model[button.method](nodes);
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].incomplete = nodes[i].isIncomplete();
                CanvasEventHandler.closeContextMenu();
            },
            edit: function(element, node) {
                if(element && node) {
                    element.editable.setMember(element, node);
                    if(node.node instanceof Tie)
                        node.node.incomplete = node.node.isIncomplete();
                    for(var i = 0; node.edges.length; i++)
                        if(node.edges[i].node instanceof Tie)
                            node.edges[i].node.incomplete = node.edges[i].node.isIncomplete();
                    element.checkValidity();                    
                }
            },
            invalid: function(element, node) {
                node.incomplete = true;
            },
            isSupported: function(operation, nodes) {
                for(var i = 0; i < nodes.length; i++)
                    if(nodes[i].operations.indexOf(operation) < 0)
                        return false;
                return true;
            },
            mousedown: function(event) {
                var self = this;
                window.addEventListener('mousemove', function(event) { self.mousemove(self, event); }, false);
                window.addEventListener('mouseup', function(event) { self.mouseup(self, event); }, false);
                this.dragging = true;
            },
            mousemove: function(self, event) {
                if(self.dragging) {
                    var xScreen, yScreen;
                    xScreen = event.clientX
                            + document.body.scrollLeft
                            + document.documentElement.scrollLeft
                            - self.contextMenu.offsetWidth / 2;
                    yScreen = event.clientY
                            + document.body.scrollTop
                            + document.documentElement.scrollTop
                            - self.topper.offsetHeight / 2;
                    this.updatePosition(xScreen, yScreen);
                }
            },
            mouseup: function(self, event) {
                this.dragging = false;
                window.removeEventListener('mousemove', function(event) { self.mousemove(self, event); }, false);
                window.removeEventListener('mouseup', function(event) { self.mouseup(self, event); }, false);
            },
            updatePosition: function(x, y) {
                x = x ? x : DrawingEngine.xScreen(this.hoveredNode.xPosition + LayoutEngine.normalDistance/2);
                y = y ? y : DrawingEngine.yScreen(this.hoveredNode.yPosition + LayoutEngine.normalDistance/2);

                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
            },
            toggle: function(node) {
                if(this.collapsed) {
                    this.toggler.className = 'toggler expanded';
                    this.collapsed = false;
                    this.modalBackground = new ModalBackground();
                    this.contextMenu.appendChild(this.topper);
                    if(this.showEditables) {
                        this.contextMenu.appendChild(this.editables);
                        this.contextMenu.appendChild(this.divider);
                    }
                    this.contextMenu.appendChild(this.operators);
                }
                else {
                    this.toggler.className = 'toggler collapsed';
                    this.collapsed = true;
                    this.contextMenu.removeChild(this.operators);
                    if(this.showEditables) {
                        this.contextMenu.removeChild(this.divider);
                        this.contextMenu.removeChild(this.editables);
                    }
                    this.contextMenu.removeChild(this.topper);
                    this.unmodal();
                    DrawingEngine.start(false);
                }
            },
            unmodal: function() {
                if(this.modalBackground) {
                    this.modalBackground.close();
                    this.modalBackground = null;
                }
                this.hoveredNode.incomplete = this.hoveredNode.isIncomplete();
            },
            close: function() {
                this.unmodal();
                if(this.editsHaveBeenMade)
                    Model.recordState();
                document.body.removeChild(this.contextMenu);
            }
        };

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                // does not work in Safari, but works in Firefox 3.6 and Chrome 6.
                this.reader = new FileReader();
                this.reader.onload = function() { FileHandler.fileLoaded() };
                this.reader.readAsText(files[0]);
            },
            replaceInput: function(parent, input) {
                var newInput = document.createElement('input');
                newInput.className = 'invisible';
                newInput.setAttribute('type', 'file');
                newInput.addEventListener('change', function() { FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this); }, false);
                parent.replaceChild(newInput, input)
            },
            fileLoaded: function() {
                try {
                    var parser = new DOMParser();
                    var xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                }
                CanvasEventHandler.clearSelection();
                DrawingEngine.reset();
                Model.fromXML(xml);
                DrawingEngine.start(false);
            }
        };

        var Actions = {
            isFiltering: false,
            filter: function(node) {
                return node instanceof Attribute || node instanceof Knot;
            },
            transform: function (xmlDocument, transformationURL, ownerDocument) {
                var result;
                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET", transformationURL, false);
                    xmlhttp.send(null);
                    var processor = new XSLTProcessor();
                    processor.importStylesheet(xmlhttp.responseXML.documentElement);
                    result = processor.transformToFragment(xmlDocument, ownerDocument);
                }
                catch(exception){
                    alert(exception);
                }
                return result;
            },
            loadFromURL: function (url) {
                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET", url, false);
                    xmlhttp.send(null);
                    Model.uncloud();
                    Model.fromXML(xmlhttp.responseXML);
                    Actions.setModelStatus();
                    Model.recordState();
                    DrawingEngine.reset();
                    DrawingEngine.start(true);
                }
                catch(exception){
                    alert(exception);
                }
            },
            modelStatusText: null,
            setModelStatus: function() {
                var statusElement = document.getElementById("model");
                var status = "Local editing mode";
                if(Model.name && Model.id)
                    status = "Cloud mode, editing " + Model.scope + " model: " + Model.name;
                if(Actions.modelStatusText)
                    statusElement.removeChild(Actions.modelStatusText);
                Actions.modelStatusText = document.createTextNode(status);
                statusElement.appendChild(Actions.modelStatusText);
            },
            cloudStatusText: null,
            checkCloudConnectionStatus: function(redirect) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                xmlhttp.open("POST", url, true);
                xmlhttp.withCredentials = 'true';

                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var statusElement = document.getElementById("cloud");
                        if(Actions.cloudStatusText)
                            statusElement.removeChild(Actions.cloudStatusText);
                        var lines, response = xmlhttp.responseText;
                        if(response.match(/^OK:/) && !redirect) {
                            lines = response.split(/[\r\n]/);
                            var login = lines[0].replace(/^OK:/, '').replace(/^[^\S]+/,'');
                            Actions.cloudStatusText = document.createTextNode(login);
                            statusElement.appendChild(Actions.cloudStatusText);
                        }
                        else if(response.match(/^LOGIN:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging in...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            window.location = response.replace(/^LOGIN:/, '').replace(/^[^\S]+/,'');
                        }
                        else if(response.match(/^OK:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging out...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            lines = response.split(/[\r\n]/);
                            window.location = lines[1];
                        }
                        else {
                            Actions.cloudStatusText = document.createTextNode("Not logged in");
                            statusElement.appendChild(Actions.cloudStatusText);
                        }
                        Actions.setModelStatus();
                    }
                };

                if(window.FormData) {
                    var formData = new FormData();
                    formData.append("action", "status");
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    var params = {};
                    params.action = 'status';
                    this.sendMultiPart(xmlhttp, params);
                }
                else {
                    alert("Cloud connection not supported by your browser");
                }
            },
            listModelsInCloud: function(scope) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                xmlhttp.open("POST", url, true);
                xmlhttp.withCredentials = 'true';
                
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var modelList = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        new CloudBrowserPopover(modelList);
                    }
                };

                if(window.FormData) {
                    var formData = new FormData();
                    formData.append("action", "list");
                    formData.append("scope", scope);
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    var params = {};
                    params.action = 'list';
                    params.scope = scope;
                    this.sendMultiPart(xmlhttp, params);
                }
                else {
                    alert("Cloud connection not supported by your browser");
                }
            },
            loadModelFromCloud: function(modelId, modelName, modelScope, modelKeywords) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                xmlhttp.open("POST", url, true);
                // this is needed in order for cookies to be sent with the request
                xmlhttp.withCredentials = 'true';

                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState == 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var model = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        Model.uncloud();
                        Model.fromXML(model);
                        Model.id = modelId;
                        Model.name = modelName;
                        Model.scope = modelScope;
                        Model.keywords = modelKeywords;
                        Actions.setModelStatus();
                        Actions.resetZoom();
                        Actions.centerModel();
                        Model.recordState();
                        DrawingEngine.start(false);
                    }
                };

                if(window.FormData) {
                    var formData = new FormData();
                    formData.append("action", "load");
                    formData.append("modelId", modelId);
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    var params = {};
                    params.action = 'load';
                    params.modelId = modelId;
                    this.sendMultiPart(xmlhttp, params);
                }
                else {
                    alert("Cloud connection not supported by your browser");
                }
            },
            saveModelInCloud: function(popover) {
                if(popover) {
                    new CloudSaverPopover();
                }
                else {
                    var xmlhttp = new window.XMLHttpRequest();
                    var url = "http://anchormodeler.appspot.com/anchormodeler";
                    xmlhttp.open("POST", url, true);
                    xmlhttp.withCredentials = 'true';

                    xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                        if(xmlhttp.readyState == 4) {
                            var response = xmlhttp.responseText;
                            if(response.match(/^LOGIN:/)) {
                                alert("You need to log in before saving. Try to save again after loggin in!");
                                ASKBEFOREUNLOAD = false;
                                window.location = response.replace(/^LOGIN:/, '');
                            }
                            else if(response.match(/^OK:/)) {
                                var modelId = response.replace(/^OK:/, '').replace(/^[^\S]+/,'').replace(/[^\S]+$/,'');
                                Model.id = modelId;
                                Actions.setModelStatus();
                                alert("Model saved in cloud as: " + Model.name);
                            }
                            else {
                                // this is probably an error msg from the server
                                alert(response);
                            }
                        }
                    };

                    if(window.FormData) {
                        var formData = new FormData();
                        formData.append("action", "save");
                        formData.append("modelName", Model.name);
                        formData.append("modelXml", new XMLSerializer().serializeToString(Model.toXML()));
                        formData.append("icon", DrawingEngine.miniatureCanvas.toDataURL());
                        formData.append("scope", Model.scope || "private");
                        formData.append("keywords", Model.keywords);
                        if(Model.id)
                            formData.append("modelId", Model.id);
                        xmlhttp.send(formData);
                    }
                    else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                        var params = {};
                        params.action = 'save';
                        params.modelName = Model.name;
                        params.modelXml = new XMLSerializer().serializeToString(Model.toXML());
                        params.icon = DrawingEngine.miniatureCanvas.toDataURL();
                        params.scope = Model.scope || "private";
                        params.keywords = Model.keywords;
                        if(Model.id)
                            params.modelId = Model.id;
                        this.sendMultiPart(xmlhttp, params);
                    }
                    else {
                        alert("Cloud connection not supported by your browser");
                    }                    
                }
            },
            sendMultiPart: function(xmlhttp, params) {
              var BOUNDARY = "---------------------------1966284435497298061834782736";
              var rn = "\r\n";
              var req = "--" + BOUNDARY;
              for (var i in params) {
                req += rn + "Content-Disposition: form-data; name=\"" + i + "\"";
                req += rn + rn + params[i] + rn + "--" + BOUNDARY;
              }
              req += "--";
              xmlhttp.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
              xmlhttp.sendAsBinary(req);
            },
            resetZoom: function() {
                ControlButtons.doZoom(1/DrawingEngine.xyScale);
                DrawingEngine.start(false);
            },
            centerModel: function() {
                var xCenter = Model.leftmostNode.xPosition + (Model.rightmostNode.xPosition - Model.leftmostNode.xPosition)/2;
                var yCenter = Model.topmostNode.yPosition + (Model.bottommostNode.yPosition - Model.topmostNode.yPosition)/2;
                var xAdjust = DrawingEngine.xContext(DrawingEngine.canvas.width/2) - xCenter;
                var yAdjust = DrawingEngine.yContext(DrawingEngine.canvas.height/2) - yCenter;
                DrawingEngine.translate(xAdjust, yAdjust);
                DrawingEngine.start(false);
            },
            randomizeLayout: function () {
                for(var i = 0; i < Model.nodes.length; i++) {
                    if(!Model.nodes[i].getFixed()) {
                        Model.nodes[i].xPosition = Math.random() * window.innerWidth;
                        Model.nodes[i].yPosition = Math.random() * window.innerHeight;
                    }
                }
                DrawingEngine.start(true);
            },
            toggleFixation: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].setFixed(!Model.nodes[i].getFixed());
                DrawingEngine.start(true);
            },
            releaseAll: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].setFixed(false);
                DrawingEngine.start(true);
            },
            toggleNames: function () {
                DrawingEngine.showNames = !DrawingEngine.showNames;
                DrawingEngine.start(false);
            },
            toggleShadows: function() {
                DrawingEngine.drawShadows = !DrawingEngine.drawShadows;
            },
            changeDetailLevel: function() {
                if(this.isFiltering)
                    Model.removeFilter();
                else
                    Model.applyFilter(this.filter);
                this.isFiltering = !this.isFiltering;
                DrawingEngine.start(false);
            },
            generatePNG: function() {
                var scale = 5;
                var padding = 50;
                var maxiatureCanvas = document.getElementById('maxiature');
                var maxiatureContext = maxiatureCanvas.getContext('2d');
                var padding = DrawingEngine.showNames ? scale * padding : padding;
                var maxiWidth = Model.rightmostNode.xPosition - Model.leftmostNode.xPosition + 2 * padding;
                var maxiHeight = Model.bottommostNode.yPosition - Model.topmostNode.yPosition + 2 * padding;

                maxiatureCanvas.width = scale * maxiWidth;
                maxiatureCanvas.height = scale * maxiHeight;
                maxiatureCanvas.style.width = maxiatureCanvas.width + 'px';
                maxiatureCanvas.style.height = maxiatureCanvas.height + 'px';

                maxiatureContext.setTransform(scale, 0, 0, scale, scale * (padding - Model.leftmostNode.xPosition), scale * (padding - Model.topmostNode.yPosition));

                var i, node;
                for(i = 0; node = Model.nodes[i]; i++) {
                    if(!Model.filtered[i])
                        node.draw(maxiatureContext);
                }
                if(DrawingEngine.showNames) {
                    for(i = 0; node = Model.nodes[i]; i++)
                        if(!(node instanceof Edge) && !Model.filtered[i])
                            node.drawName(maxiatureContext);
                }
                
                window.open(maxiatureCanvas.toDataURL('image/png'), '_newtab');
                // release memory
                maxiatureCanvas.width = 0;
                maxiatureCanvas.height = 0;
                maxiatureCanvas.style.width = maxiatureCanvas.width + 'px';
                maxiatureCanvas.style.height = maxiatureCanvas.height + 'px';
            },
            generateHTML: function() {
                var html = window.open('', '_newtab').document;
                html.open();
                html.write(
                    '<!DOCTYPE HTML>'+
                    '<html><head>'+
                    '  <title>Anchor Model</title>' +
                    '  <link rel="stylesheet" type="text/css" href="documentation.css">'+
                    '</head><body>'+
                    '</body></html>'
                );
                html.close();
                var fragment = this.transform(Model.toXML(), 'xml2documentation.xsl', html);
                // alert(new XMLSerializer().serializeToString(fragment));
                html.body.appendChild(fragment);
            }
        };

        var Settings = {
            init: function() {
                document.getElementById('damping').value = ((1 - LayoutEngine.damping) * 100).toFixed(0);
                document.getElementById('normalDistance').value = LayoutEngine.normalDistance.toFixed(0);
                document.getElementById('stoppingVelocity').value = LayoutEngine.stoppingVelocity.toFixed(1);
                document.getElementById('minimumStartingVelocity').value = LayoutEngine.minimumStartingVelocity.toFixed(1);
                document.getElementById('maximumStartingVelocity').value = LayoutEngine.maximumStartingVelocity.toFixed(1);
                document.getElementById('influenceConstant').value = LayoutEngine.influenceConstant.toFixed(0);
                document.getElementById('stiffness').value = LayoutEngine.stiffness.toFixed(1);
                document.getElementById('database').value = DATABASE_TRANSFORM;
                document.getElementById('FPS').value = FPS;
                document.getElementById('MINIRATE').value = MINIRATE;
                document.getElementById('CALCS').value = CALCS;
            },
            resetSettings: function() {
                this.setDamping(4);
                this.setNormalDistance(30);
                this.setStoppingVelocity(0.1);
                this.setMinimumStartingVelocity(1);
                this.setMaximumStartingVelocity(5);
                this.setInfluenceConstant(4);
                this.setStiffness(3);
                this.setDatabase('SQLServer.xsl');
                this.setFPS(100);
                this.setMiniRate(50);
                this.setCalculations('simple');
                Knot.mass = 1;
                Knot.charge = 1;
                Anchor.mass = 1;
                Anchor.charge = 1;
                Attribute.mass = 1;
                Attribute.charge = 1;
                Tie.mass = 1;
                Tie.charge = 1;
                Edge.mass = 1;
                Edge.charge = 1;
                this.init();
            },
            storeSettings: function(storage) {
                storage.setItem("damping", (1 - LayoutEngine.damping) * 100);
                storage.setItem("normalDistance", LayoutEngine.normalDistance);
                storage.setItem("stoppingVelocity", LayoutEngine.stoppingVelocity);
                storage.setItem("minimumStartingVelocity", LayoutEngine.minimumStartingVelocity);
                storage.setItem("maximumStartingVelocity", LayoutEngine.maximumStartingVelocity);
                storage.setItem("influenceConstant", LayoutEngine.influenceConstant);
                storage.setItem("stiffness", LayoutEngine.stiffness);
                storage.setItem("database", DATABASE_TRANSFORM);
                storage.setItem("FPS", FPS);
                storage.setItem("MINIRATE", MINIRATE);
                storage.setItem("CALCS", CALCS);
                storage.setItem("knotMass", Knot.mass);
                storage.setItem("knotCharge", Knot.charge);
                storage.setItem("anchorMass", Anchor.mass);
                storage.setItem("anchorCharge", Anchor.charge);
                storage.setItem("attributeMass", Attribute.mass);
                storage.setItem("attributeCharge", Attribute.charge);
                storage.setItem("tieMass", Tie.mass);
                storage.setItem("tieCharge", Tie.charge);
                storage.setItem("edgeMass", Edge.mass);
                storage.setItem("edgeCharge", Edge.charge);
            },
            loadSettings: function(storage) {
                this.setDamping(storage.getItem('damping') || 4);
                this.setNormalDistance(storage.getItem('normalDistance') || 30);
                this.setStoppingVelocity(storage.getItem('stoppingVelocity') || 0.1);
                this.setMinimumStartingVelocity(storage.getItem('minimumStartingVelocity') || 1);
                this.setMaximumStartingVelocity(storage.getItem('maximumStartingVelocity') || 5);
                this.setInfluenceConstant(storage.getItem('influenceConstant') || 4);
                this.setStiffness(storage.getItem('stiffness') || 3);
                this.setDatabase(storage.getItem('database') || 'SQLServer.xsl');
                this.setFPS(storage.getItem('FPS') || 100);
                this.setMiniRate(storage.getItem('MINIRATE') || 50);
                this.setCalculations(storage.getItem('CALCS') || 'simple');
                Knot.mass = 1 * storage.getItem('knotMass') || 1;
                Knot.charge = 1 * storage.getItem('knotCharge') || 1;
                Anchor.mass = 1 * storage.getItem('anchorMass') || 1;
                Anchor.charge = 1 * storage.getItem('anchorCharge') || 1;
                Attribute.mass = 1 * storage.getItem('attributeMass') || 1;
                Attribute.charge = 1 * storage.getItem('attributeCharge') || 1;
                Tie.mass = 1 * storage.getItem('tieMass') || 1;
                Tie.charge = 1 * storage.getItem('tieCharge') || 1;
                Edge.mass = 1 * storage.getItem('edgeMass') || 1;
                Edge.charge = 1 * storage.getItem('edgeCharge') || 1;
                this.init();
            },
            setDamping: function(value) {
                LayoutEngine.damping = (100 - value)/100;
            },
            setNormalDistance: function(value) {
                LayoutEngine.normalDistance = 1 * value;
                LayoutEngine.attractionConstant = 1/value/value/value;
            },
            setStoppingVelocity: function(value) {
                LayoutEngine.stoppingVelocity = 1 * value;
            },
            setMinimumStartingVelocity: function(value) {
                LayoutEngine.minimumStartingVelocity = 1 * value;
            },
            setMaximumStartingVelocity: function(value) {
                LayoutEngine.maximumStartingVelocity = 1 * value;
            },
            setInfluenceConstant: function(value) {
                LayoutEngine.influenceConstant = 1 * value;
            },
            setStiffness: function(value) {
                LayoutEngine.stiffness = 1 * value;
                LayoutEngine.stiffnessBound = value * value;
            },
            setDatabase: function(value) {
                DATABASE_TRANSFORM = value;
            },
            setFPS: function(value) {
                FPS = 1 * value;
            },
            setMiniRate: function(value) {
                MINIRATE = 1 * value;
            },
            toggleDebug: function () {
                DEBUG = !DEBUG;
                DrawingEngine.start(false);
            },
            knotMass: null,
            knotCharge: null,
            anchorMass: null,
            anchorCharge: null,
            attributeMass: null,
            attributeCharge: null,
            tieMass: null,
            tieCharge: null,
            edgeMass: null,
            edgeCharge: null,
            setCalculations: function(value) {
                var listOfSettings = document.getElementById('listOfSettings');
                var calcsItem = document.getElementById('calcsItem');
                if(value == 'simple') {
                    LayoutEngine.layout = LayoutEngine.simpleLayout;
                    if(this.knotMass) listOfSettings.removeChild(this.knotMass);
                    if(this.knotCharge) listOfSettings.removeChild(this.knotCharge);
                    if(this.anchorMass) listOfSettings.removeChild(this.anchorMass);
                    if(this.anchorCharge) listOfSettings.removeChild(this.anchorCharge);
                    if(this.attributeMass) listOfSettings.removeChild(this.attributeMass);
                    if(this.attributeCharge) listOfSettings.removeChild(this.attributeCharge);
                    if(this.tieMass) listOfSettings.removeChild(this.tieMass);
                    if(this.tieCharge) listOfSettings.removeChild(this.tieCharge);
                    if(this.edgeMass) listOfSettings.removeChild(this.edgeMass);
                    if(this.edgeCharge) listOfSettings.removeChild(this.edgeCharge);
                    this.knotMass = null;
                    this.knotCharge = null;
                    this.anchorMass = null;
                    this.anchorCharge = null;
                    this.attributeMass = null;
                    this.attributeCharge = null;
                    this.tieMass = null;
                    this.tieCharge = null;
                    this.edgeMass = null;
                    this.edgeCharge = null;
                }
                else if (value == 'complex') {
                    LayoutEngine.layout = LayoutEngine.complexLayout;
                    this.knotMass = document.createElement('li');
                    this.knotCharge = document.createElement('li');
                    this.anchorMass = document.createElement('li');
                    this.anchorCharge = document.createElement('li');
                    this.attributeMass = document.createElement('li');
                    this.attributeCharge = document.createElement('li');
                    this.tieMass = document.createElement('li');
                    this.tieCharge = document.createElement('li');
                    this.edgeMass = document.createElement('li');
                    this.edgeCharge = document.createElement('li');
                    var knotMassInput = document.createElement('input');
                    var knotChargeInput = document.createElement('input');
                    var anchorMassInput = document.createElement('input');
                    var anchorChargeInput = document.createElement('input');
                    var attributeMassInput = document.createElement('input');
                    var attributeChargeInput = document.createElement('input');
                    var tieMassInput = document.createElement('input');
                    var tieChargeInput = document.createElement('input');
                    var edgeMassInput = document.createElement('input');
                    var edgeChargeInput = document.createElement('input');
                    knotMassInput.setAttribute('type', 'number');
                    knotChargeInput.setAttribute('type', 'number');
                    anchorMassInput.setAttribute('type', 'number');
                    anchorChargeInput.setAttribute('type', 'number');
                    attributeMassInput.setAttribute('type', 'number');
                    attributeChargeInput.setAttribute('type', 'number');
                    tieMassInput.setAttribute('type', 'number');
                    tieChargeInput.setAttribute('type', 'number');
                    edgeMassInput.setAttribute('type', 'number');
                    edgeChargeInput.setAttribute('type', 'number');
                    knotMassInput.setAttribute('step', '0.1');
                    knotChargeInput.setAttribute('step', '0.1');
                    anchorMassInput.setAttribute('step', '0.1');
                    anchorChargeInput.setAttribute('step', '0.1');
                    attributeMassInput.setAttribute('step', '0.1');
                    attributeChargeInput.setAttribute('step', '0.1');
                    tieMassInput.setAttribute('step', '0.1');
                    tieChargeInput.setAttribute('step', '0.1');
                    edgeMassInput.setAttribute('step', '0.1');
                    edgeChargeInput.setAttribute('step', '0.1');
                    knotMassInput.value = Knot.mass;
                    knotChargeInput.value = Knot.charge;
                    anchorMassInput.value = Anchor.mass;
                    anchorChargeInput.value = Anchor.charge;
                    attributeMassInput.value = Attribute.mass;
                    attributeChargeInput.value = Attribute.charge;
                    tieMassInput.value = Tie.mass;
                    tieChargeInput.value = Tie.charge;
                    edgeMassInput.value = Edge.mass;
                    edgeChargeInput.value = Edge.charge;
                    knotMassInput.addEventListener('blur', function() { Knot.mass = 1 * this.value; }, false);
                    knotChargeInput.addEventListener('blur', function() { Knot.charge = 1 * this.value; }, false);
                    anchorMassInput.addEventListener('blur', function() { Anchor.mass = 1 * this.value; }, false);
                    anchorChargeInput.addEventListener('blur', function() { Anchor.charge = 1 * this.value; }, false);
                    attributeMassInput.addEventListener('blur', function() { Attribute.mass = 1 * this.value; }, false);
                    attributeChargeInput.addEventListener('blur', function() { Attribute.charge = 1 * this.value; }, false);
                    tieMassInput.addEventListener('blur', function() { Tie.mass = 1 * this.value; }, false);
                    tieChargeInput.addEventListener('blur', function() { Tie.charge = 1 * this.value; }, false);
                    edgeMassInput.addEventListener('blur', function() { Edge.mass = 1 * this.value; }, false);
                    edgeChargeInput.addEventListener('blur', function() { Edge.charge = 1 * this.value; }, false);
                    this.knotMass.appendChild(knotMassInput);
                    this.knotCharge.appendChild(knotChargeInput);
                    this.anchorMass.appendChild(anchorMassInput);
                    this.anchorCharge.appendChild(anchorChargeInput);
                    this.attributeMass.appendChild(attributeMassInput);
                    this.attributeCharge.appendChild(attributeChargeInput);
                    this.tieMass.appendChild(tieMassInput);
                    this.tieCharge.appendChild(tieChargeInput);
                    this.edgeMass.appendChild(edgeMassInput);
                    this.edgeCharge.appendChild(edgeChargeInput);
                    this.knotMass.appendChild(document.createTextNode(' Knot mass'));
                    this.knotCharge.appendChild(document.createTextNode(' Knot charge'));
                    this.anchorMass.appendChild(document.createTextNode(' Anchor mass'));
                    this.anchorCharge.appendChild(document.createTextNode(' Anchor charge'));
                    this.attributeMass.appendChild(document.createTextNode(' Attribute mass'));
                    this.attributeCharge.appendChild(document.createTextNode(' Attribute charge'));
                    this.tieMass.appendChild(document.createTextNode(' Tie mass'));
                    this.tieCharge.appendChild(document.createTextNode(' Tie charge'));
                    this.edgeMass.appendChild(document.createTextNode(' Edge mass'));
                    this.edgeCharge.appendChild(document.createTextNode(' Edge charge'));
                    listOfSettings.insertBefore(this.edgeCharge, calcsItem);
                    listOfSettings.insertBefore(this.edgeMass, calcsItem);
                    listOfSettings.insertBefore(this.tieCharge, calcsItem);
                    listOfSettings.insertBefore(this.tieMass, calcsItem);
                    listOfSettings.insertBefore(this.attributeCharge, calcsItem);
                    listOfSettings.insertBefore(this.attributeMass, calcsItem);
                    listOfSettings.insertBefore(this.anchorCharge, calcsItem);
                    listOfSettings.insertBefore(this.anchorMass, calcsItem);
                    listOfSettings.insertBefore(this.knotCharge, calcsItem);
                    listOfSettings.insertBefore(this.knotMass, calcsItem);
                }
            }
        };

        var ControlButtons = {
            playPauseButton: null,
            nudgeButton: null,
            undoButton: null,
            redoButton: null,
            zoomInButton: null,
            zoomOutButton: null,
            zoomFactor: 1.75,
            init: function() {
                this.playPauseButton = document.getElementById('playpause');
                this.undoButton = document.getElementById('undo');
                this.redoButton = document.getElementById('redo');
                this.zoomInButton = document.getElementById('zoomin');
                this.zoomOutButton = document.getElementById('zoomout');

                // voodoo
                var self = this;

                this.playPauseButton.addEventListener('click', function(event) { return self.togglePlayPause(event) },  false);
                this.undoButton.addEventListener('click', function(event) { return self.undo(event) }, false);
                this.redoButton.addEventListener('click', function(event) { return self.redo(event) }, false);
                this.zoomInButton.addEventListener('click', function(event) { return self.zoomIn(event) }, false);
                this.zoomOutButton.addEventListener('click', function(event) { return self.zoomOut(event) }, false);
            },
            togglePlayPause: function (event) {
                if(DrawingEngine.running) {
                    DrawingEngine.stop();
                }
                else if (LayoutEngine.equilibrium) {
                    this.invalidateLayout();
                }
                else {
                    DrawingEngine.start(false);
                }
            },
            setUndoLevels: function(numberOfLevels) {
                var undos = '';
                if(numberOfLevels)
                    undos = ' (' + numberOfLevels + ')';
                this.undoButton.firstChild.nodeValue = 'Undo' + undos;
            },
            setRedoLevels: function(numberOfLevels) {
                var redos = '';
                if(numberOfLevels)
                    redos = ' (' + numberOfLevels + ')';
                this.redoButton.firstChild.nodeValue = 'Redo' + redos;
            },
            undo: function() {
                Model.undoState();
                DrawingEngine.start(false);
            },
            redo: function() {
                Model.redoState();
                DrawingEngine.start(false);
            },
            setPlayState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Play';
                this.playPauseButton.className = 'pausing';
            },
            setPauseState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Pause';
                this.playPauseButton.className = 'playing';
            },
            invalidateLayout: function () {
                for(var i = 0; i < Model.nodes.length; i++) {
                    Model.nodes[i].start();
                }
                DrawingEngine.start(true);
            },
            doZoom: function (zoom) {
                DrawingEngine.scale(zoom);
                var xx = window.innerWidth/2;
                var yy = window.innerHeight/2;
                DrawingEngine.translate(DrawingEngine.xContext(xx) - DrawingEngine.xContext(xx) * zoom,
                        DrawingEngine.yContext(yy) - DrawingEngine.yContext(yy) * zoom);
                DrawingEngine.start(false);
            },
            zoomIn: function (event) {
                this.doZoom(this.zoomFactor);
            },
            zoomOut: function (event) {
                this.doZoom(1/this.zoomFactor);
            }
        };        

        // make sure our init function is called when the page is loaded
        window.onload = function() { try { init(this); } catch(e) { alert(e); } };

        // implementation of our init function
        function init(window) {
            // assign event handlers to buttons
            ControlButtons.init();
            LayoutEngine.init();

            var canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext;

            // get the canvas element
            canvas = document.getElementById('canvas');
            if (!canvas || !canvas.getContext)
                unsupported("Cannot find the canvas!");
            // get the canvas 2d context
            context = canvas.getContext('2d');
            if (!context)
                unsupported("The canvas has no 2d context!");
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(canvas, context);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(canvas, context) }, false);

            shadowCanvas = document.getElementById('shadow');
            if (!shadowCanvas || !shadowCanvas.getContext)
                unsupported("Cannot find the shadow canvas!");
            // get the shadow canvas 2d context
            shadowContext = shadowCanvas.getContext('2d');
            if (!shadowContext)
                unsupported("The shadow canvas has no 2d context!");
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(shadowCanvas, shadowContext);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(shadowCanvas, shadowContext) }, false);

            miniatureCanvas = document.getElementById('miniature');
            if (!miniatureCanvas || !miniatureCanvas.getContext)
                unsupported("Cannot find the miniature canvas!");
            // get the shadow canvas 2d context
            miniatureContext = miniatureCanvas.getContext('2d');
            if (!miniatureContext)
                unsupported("The miniature canvas has no 2d context!");

            DrawingEngine.init(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext);

            canvas.CanvasEventHandler = CanvasEventHandler;
            // attach the mousedown, mousemove and mouseup event listeners to the visible canvas
            canvas.addEventListener('mousedown', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousemove', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mouseup', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousewheel', CanvasEventHandler.handleEvent, false); // Safari and Chrome
            canvas.addEventListener('DOMMouseScroll', CanvasEventHandler.handleEvent, false); // Firefox

            // setting a listener on the canvas did not work, so this is a workaround
            // we are currently not listening to keyboard events
            // window.onkeydown = CanvasEventHandler.handleEvent;

            miniatureCanvas.MiniatureEventHandler = MiniatureEventHandler;
            miniatureCanvas.addEventListener('mousedown', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mousemove', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mouseup', MiniatureEventHandler.handleEvent, false);

            // load previous model, if any
            var model;
            if(model = window.localStorage.getItem("model")) {
                Model.fromXML(new DOMParser().parseFromString(model, 'text/xml'));
                Model.id = window.localStorage.getItem("modelId");
                Model.name = window.localStorage.getItem("modelName");
                Model.scope = window.localStorage.getItem("modelScope");
                Model.keywords = window.localStorage.getItem("modelKeywords");
            }
            else
                Actions.loadFromURL('example.xml');

            Actions.checkCloudConnectionStatus(false);

            // set values in the settings input fields
            Settings.loadSettings(window.localStorage);

            // load previous scale and transform
            DrawingEngine.loadSettings(window.localStorage);
            DrawingEngine.start(true);

            // TODO: testing to see that we redirect ok
            // unsupported("This is just a test");
        }

        // make sure our exit function is called when the page is unloaded
        window.onbeforeunload = function() {
            if(ASKBEFOREUNLOAD)
                return "Are you absolutely sure you want to leave?\nAny unsaved changes will be lost!";
            else
                ASKBEFOREUNLOAD = true;
        };

        window.onunload = function() { try { exit(this); } catch(e) { alert(e); } };
        
        function exit(window) {
            window.localStorage.clear();
            if(Model.nodes.length)
                window.localStorage.setItem("model", new XMLSerializer().serializeToString(Model.toXML()));
            if(Model.id)
                window.localStorage.setItem("modelId", Model.id);
            if(Model.name)
                window.localStorage.setItem("modelName", Model.name);
            if(Model.scope)
                window.localStorage.setItem("modelScope", Model.scope);
            if(Model.keywords)
                window.localStorage.setItem("modelKeywords", Model.keywords);
            Settings.storeSettings(window.localStorage);
            DrawingEngine.storeSettings(window.localStorage);
        }

        function unsupported(reason) {
            // disable handlers and leave
            window.init = null;
            window.onbeforeunload = null;
            window.onunload = null;
            window.location = "http://www.anchormodeler.com/modeler/unsupported.html";
        }

        // -->
    </script>
</head>
<body>
    <canvas id="canvas" class="unselectable">
        <!-- this is the main drawing area -->
    </canvas>
    <canvas id="shadow" class="unselectable">
        <!-- we paint objects in "false" colors on this canvas and use that to identify them with mouse clicks -->
    </canvas>

    <div id="header" class="unselectable">
        <div id="file">
            <ul class="menu">
                <li>File
                    <ul class="submenu">
                        <li onclick="Model.setupMinimal()">New model...</li>
                        <li onclick="Actions.listModelsInCloud('public')">Load public model from cloud...</li>
                        <li onclick="Actions.listModelsInCloud('private')">Load private model from cloud...</li>
                        <li onclick="Actions.saveModelInCloud(true)">Save model in cloud...</li>
                        <li>Load model from local file...<input class="invisible" type="file" onchange="FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this);"/></li>
                        <li onclick="Actions.loadFromURL('example.xml')">Load example model</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="actions">
            <ul class="menu">
                <li>Layout
                    <ul class="submenu">
                        <li onclick="Actions.toggleNames()">Toggle names</li>
                        <li onclick="Actions.toggleShadows()">Toggle shadows</li>
                        <li onclick="Actions.changeDetailLevel()">Change detail level</li>
                        <li onclick="Actions.toggleFixation()">Toggle fixation</li>
                        <li onclick="Actions.releaseAll()">Release all fixed</li>
                        <li onclick="Actions.resetZoom();Actions.centerModel()">Reset view</li>
                        <li onclick="Actions.randomizeLayout()">Randomize layout</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="generate">
            <ul class="menu">
                <li>Generate
                    <ul class="submenu">
                        <li onclick="new CodePopover(Actions.transform(Model.toXML(), 'xml2html.xsl', document), false)">XML code</li>
                        <li onclick="Actions.generateHTML()">HTML documentation</li>
                        <li onclick="new CodePopover(Actions.transform(Model.toXML(), DATABASE_TRANSFORM, document), true)">SQL code</li>
                        <li onclick="window.open(DrawingEngine.canvas.toDataURL('image/png'), '_newtab')">PNG screenshot</li>
                        <li onclick="Actions.generatePNG()">PNG hi-res model</li>
                        <li onclick="window.open(Model.toSVGURL(), '_newtab')">SVG graphics</li>
                        <li onclick="new CodePopover(Actions.transform(Model.toSVG(), 'xml2html.xsl', document), false)">SVG code</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="controls">
            <div id="playpause">Pause</div>
            <div id="undo">Undo</div>
            <div id="redo">Redo</div>
            <div id="zoomin">Zoom In</div>
            <div id="zoomout">Zoom Out</div>
        </div>

        <div id="about">
            <ul class="menu">
                <li>Help
                    <ul class="submenu">
                        <li onclick="new URLPopover('http://www.anchormodeling.com/?page_id=186')">Tutorials</li>
                        <li onclick="new URLPopover('http://www.anchormodeling.com/modeler/about.html')">About</li>
                    </ul>
                </li>
            </ul>
        </div>

        <!-- TODO: focus gets "stuck" on the input fields below sometimes, annoying! -->
        <div id="settings" class="unselectable" title="Expert settings">
            <ul class="menu">
                <li>Settings
                    <ul id="listOfSettings" class="submenu">
                        <li><input id="damping" type="number" min="0" max="99" step="1" onblur="Settings.setDamping(this.value)"/> % Damping</li>
                        <li><input id="normalDistance" type="number" min="10" max="90" step="5" onblur="Settings.setNormalDistance(this.value)"/> px Normal distance</li>
                        <li><input id="stoppingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setStoppingVelocity(this.value)"/> px/s Stopping velocity</li>
                        <li><input id="minimumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMinimumStartingVelocity(this.value)"/> px/s Minimum starting velocity</li>
                        <li><input id="maximumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMaximumStartingVelocity(this.value)"/> px/s Maximum starting velocity</li>
                        <li><input id="influenceConstant" type="number" min="0" max="10" step="1" onblur="Settings.setInfluenceConstant(this.value)"/> Node influence factor</li>
                        <li><input id="stiffness" type="number" min="1" max="9" step="0.5" onblur="Settings.setStiffness(this.value)"/> Edge stiffness factor</li>
                        <li><input id="FPS" type="number" min="10" max="1000" step="10" onblur="Settings.setFPS(this.value)"/> fps Target frame rate</li>
                        <li><input id="MINIRATE" type="number" min="1" max="99" step="1" onblur="Settings.setMiniRate(this.value)"/> Miniature refresh interval</li>
                        <li id="calcsItem"><select id="CALCS" onchange="Settings.setCalculations(this.value)"><option value="simple" selected="selected">Simplified</option><option value="complex">Adjustable</option></select> &nbsp;Calculations</li>
                        <li><select id="database" onchange="Settings.setDatabase(this.value)"><option value="SQLServer.xsl" selected="selected">Microsoft SQL Server</option></select> &nbsp;Target database</li>
                        <li onclick="Settings.resetSettings()">Reset settings to default values</li>
                        <li onclick="Settings.toggleDebug()">Toggle debug</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>


    <canvas id="maxiature" class="unselectable">
        <!-- we use this when generating high resolution images -->
    </canvas>
    <canvas id="miniature" class="unselectable" title="This is the Navigation Window.&#10;It will always show the whole model&#10;with the current viewport shown by&#10;a red outline. Click and drag to&#10;move the viewport.">
        <!-- shows a navigatable miniature of the model -->
    </canvas>

    <div id="cloud" class="unselectable" onclick="Actions.checkCloudConnectionStatus(true)">
        <!-- filled dynamically -->
    </div>
    <div id="model" class="unselectable">
        <!-- filled dynamically -->
    </div>
</body>
</html>