<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Anchor Modeler</title>
    <!-- web fonts -->
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/>
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>
    <!-- styling -->
    <link href='application.css' rel='stylesheet' type='text/css'/>

    <!-- run some checks first -->
    <script type="text/javascript">
        <!--
        // check low level management SVG support
        var testElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        if (!testElement || !testElement.viewBox || !testElement.viewBox.baseVal)
            unsupported();

        // check binding support
        if(!Function.prototype.bind)
            unsupported();

        var browser = window.navigator.userAgent;
        // check that it's not IE
        if(browser.indexOf('MSIE ') >= 0 || browser.indexOf('Trident/') >= 0)
            unsupported();

        function unsupported() {
            // disable handlers and leave
            window.init = null;
            window.onbeforeunload = null;
            window.onunload = null;
            window.location = "unsupported.html";
        }
        // -->
    </script>

    <script type="text/javascript">
        <!--
        "use strict"; // be safe!

        var VERSION = 0.98;

        // change to false in beta
        var RELEASE = false;

        // set to true to show debugging information
        var DEBUG = false;

        // used when creating svg elements
        var SVGNS = "http://www.w3.org/2000/svg";
        var XLINKNS = "http://www.w3.org/1999/xlink";
        // the svg root and graph elements
        var SVG, SVGLayer;
        // the navigation miniature
        var NAV, NAVLayer;

        // global variables for the cloud stuff
        var ASKBEFOREUNLOAD = true;
        var LOGGED_IN = false;
        var PARAMETERS = {};
        var USER_ID = "";

        // latin-1 encoding
        var LOWER = '[a-z0-9\u00E0-\u00F6\u00F8-\u00FF]';
        var UPPER = '[A-Z\u00C0-\u00D6\u00D8-\u00DF]';

        var Defaults = {
            changingRange: 'datetime',
            encapsulation: 'dbo',
            identity: 'int',
            metadataPrefix: 'Metadata',
            metadataType: 'int',
            metadataUsage: 'true',
            changingSuffix: 'ChangedAt',
            identitySuffix: 'ID',
            positIdentity: 'int',
            positGenerator: 'true',
            positingRange: 'datetime',
            positingSuffix: 'PositedAt',
            positorRange: 'tinyint',
            positorSuffix: 'Positor',
            reliabilityRange: 'tinyint',
            reliabilitySuffix: 'Reliability',
            reliableCutoff: '1', // inclusive, smallest reliability considered reliable
            deleteReliability: '0', // default reliability value for deletes
            reliableSuffix: 'Reliable',
            partitioning: 'false',
            entityIntegrity: 'true',
            restatability: 'true',
            idempotency: 'false',
            assertiveness: 'true',
            naming: 'improved',
            positSuffix: 'Posit',
            annexSuffix: 'Annex',
            chronon: 'datetime2(7)',
            now: 'sysdatetime()',
            dummySuffix: 'Dummy',
            versionSuffix: 'Version',
            statementTypeSuffix: 'StatementType',
            checksumSuffix: 'Checksum',
            businessViews: 'false',
            equivalence: 'false',
            equivalentSuffix: 'EQ',
            equivalentRange: 'tinyint',
            databaseTarget: 'SQLServer',
            temporalization: 'uni'
        };

        // global function providing inheritance
        function extend(type, supertype){
            for(var member in supertype.prototype)
                if(!type.prototype[member])
                    type.prototype[member] = supertype.prototype[member];
        }

        // available node types enumeration with textual representation
        var NodeType = {
            UNKNOWN:    0, '0': "Unknown",
            ANCHOR:     1, '1': "Anchor",
            ATTRIBUTE:  2, '2': "Attribute",
            TIE:        3, '3': "Tie",
            KNOT:       4, '4': "Knot",
            EDGE:       5, '5': "Edge",
            PARTITION:  6, '6': "Partition",
            // "static variables" masses and charges, for example NodeType.mass[NodeType.ANCHOR];
            mass:       [1, 1, 1, 1, 1, 1, 0],
            charge:     [1, 1, 1, 1, 1, 1, 0]
        };

        // the node type that the layout algorithm expects
        function Node(id, x, y, type) {
            this.id = id;
            this.type = NodeType[type] ? type : 0; // check that the type is defined in NodeType
            this.xPosition = x;
            this.yPosition = y;
            this.edges = [];
        }
        Node.prototype = {
            id: null,
            type: null,
            xPosition: null,
            yPosition: null,
            xVelocity: 0,
            yVelocity: 0,
            velocity: 0,
            moving: true,
            fixed: false,
            visible: true,
            edges: null,
            stop: function() {
                this.moving = false;
            },
            // movement is propagated to the edges of a node
            start: function() {
                this.moving = true;
                var i = this.edges.length;
                while(i--) this.edges[i].start();
            },
            // "static variables"
            getMass: function() {
                return NodeType.mass[this.type];
            },
            getCharge: function() {
                return NodeType.charge[this.type];
            }
        };

        // an edge connects two nodes
        function Edge(id, node, otherNode) {
            // assume that the control point coincide with the center point
            this.controlPoint = new Node(
                id,
                node.xPosition + (otherNode.xPosition - node.xPosition) / 2,
                node.yPosition + (otherNode.yPosition - node.yPosition) / 2
            );
            Node.call(this, id, this.controlPoint.xPosition, this.controlPoint.yPosition, NodeType.EDGE);
            this.node = node;
            this.otherNode = otherNode;
            if(node.edges.indexOf(this) < 0) node.edges.push(this);
            if(otherNode.edges.indexOf(this) < 0) otherNode.edges.push(this);
            this.edges.push(node);
            this.edges.push(otherNode);
        }
        Edge.prototype = {
            node: null,
            otherNode: null,
            // overload
            start: function() {
                this.moving = true;
            }
        };

        // let the edge inherit from Node
        extend(Edge, Node);

        // a partition is a collection of nodes that itself behaves like a node
        function Partition(node, complex) {
            this.nodes = [node];
            Node.call(this, 0, node.xPosition, node.yPosition, NodeType.PARTITION);
            this.xMin = node.xPosition;
            this.yMin = node.yPosition;
            this.xMax = node.xPosition;
            this.yMax = node.yPosition;
            if(complex) {
                this.totalMass = node.getMass();
                this.totalCharge = node.getCharge();
                this.addNode = this.addComplexNode;
            }
            else
                this.addNode = this.addSimpleNode;
        }
        Partition.prototype = {
            nodes: null,
            xMin: 0,
            yMin: 0,
            xMax: 0,
            yMax: 0,
            totalMass: 0,
            totalCharge: 0,
            getMass: function() {
                return this.totalMass;
            },
            getCharge: function() {
                return this.totalCharge;
            },
            addNode: null,
            addSimpleNode: function(node) {
                // find the center of mass in the partition
                this.xPosition =
                        (this.xPosition * this.nodes.length + node.xPosition) /
                        (this.nodes.length + 1);
                this.yPosition =
                        (this.yPosition * this.nodes.length + node.yPosition) /
                        (this.nodes.length + 1);
                if(node.xPosition < this.xMin)
                    this.xMin = node.xPosition;
                else if(node.xPosition > this.xMax)
                    this.xMax = node.xPosition;
                if(node.yPosition < this.yMin)
                    this.yMin = node.yPosition;
                else if(node.yPosition > this.yMax)
                    this.yMax = node.yPosition;
                this.nodes.push(node);
            },
            addComplexNode: function(node) {
                // find the center of mass in the partition
                this.xPosition =
                        (this.xPosition * this.totalMass + node.xPosition * node.getMass()) /
                        (this.totalMass + node.getMass());
                this.yPosition =
                        (this.yPosition * this.totalMass + node.yPosition * node.getMass()) /
                        (this.totalMass + node.getMass());
                if(node.xPosition < this.xMin)
                    this.xMin = node.xPosition;
                else if(node.xPosition > this.xMax)
                    this.xMax = node.xPosition;
                if(node.yPosition < this.yMin)
                    this.yMin = node.yPosition;
                else if(node.yPosition > this.yMax)
                    this.yMax = node.yPosition;
                this.totalMass += node.getMass();
                this.totalCharge += node.getCharge();
                this.nodes.push(node);
            }
        };

        // let the partition inherit from Node
        extend(Partition, Node);

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 30,
            // 4 percent damping (simulated friction)
            damping: 0.96,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // minimum starting velocity is a whole pixel
            minimumStartingVelocity: 1,
            // maximum starting velocity is higher (to remove "twitching" when few nodes are moving)
            maximumStartingVelocity: 5,
            // maximum - minimum starting velocity [set by init]
            startingVelocityDelta: 4,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1 [set by init]
            attractionConstant: 0.00003703703704,
            // size of partitions in number of normal distances
            partitionFactor: 15,
            // the stiffness of the edges
            stiffness: 1,
            // when the layout has reached equilibrium
            equilibrium: true,
            // which layout function to use
            layout: null,
            // holds space partitions
            partitions: null,
            // size of partitions [set by init]
            partitionSize: 120,
            // the effect of the long range force
            longRangeEffect: 0.25,
            // fuzziness of the partition size (ranges between +/- fuzziness percentage of partition size)
            fuzziness: 0.1,
            // amount of fuzz [set by init]
            fuzz: 24,
            // current fuzz-operation, 0 for subtract, 1 for nothing, 2 for add [changes every iteration]
            fuzzing: 0,
            init: function() {
                this.layout = this.simpleLayout;
                this.attractionConstant = 1/this.normalDistance/this.normalDistance/this.normalDistance;
                this.partitionSize = this.partitionFactor * this.normalDistance;
                this.startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;
                this.fuzz = this.partitionSize * this.fuzziness;
            },
            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },
            // measures distance between two nodes
            manhattanDistance: function(node, otherNode) {
                var d = Math.abs(otherNode.xPosition - node.xPosition) +
                        Math.abs(otherNode.yPosition - node.yPosition);
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            euclideanDistance: function(node, otherNode) {
                var d = Math.sqrt(this.square(otherNode.xPosition - node.xPosition) +
                        this.square(otherNode.yPosition - node.yPosition));
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },

            xStiffness: function(node, otherNode, multiplier) {
                return multiplier * (otherNode.xPosition - node.xPosition);
            },

            yStiffness: function(node, otherNode, multiplier) {
                return multiplier * (otherNode.yPosition - node.yPosition);
            },

            // x component of the repelling force formula
            xSimpleRepelling: function(node, otherNode) {
                return (node.xPosition - otherNode.xPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            ySimpleRepelling: function(node, otherNode) {
                return (node.yPosition - otherNode.yPosition) / this.square(this.manhattanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xSimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPosition - node.xPosition) *
                        this.manhattanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            ySimpleAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPosition - node.yPosition) *
                        this.manhattanDistance(node, otherNode);
            },
            // x component of the repelling force formula
            xComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.xPosition - otherNode.xPosition) /
                        this.square(this.euclideanDistance(node, otherNode));
            },

            // y component of the repelling force formula
            yComplexRepelling: function(node, otherNode) {
                return (node.getCharge() + otherNode.getCharge())/2 * (node.yPosition - otherNode.yPosition) /
                        this.square(this.euclideanDistance(node, otherNode));
            },

            // x component of the attracting force formula
            xComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant *
                        (otherNode.xPosition - node.xPosition) * this.euclideanDistance(node, otherNode);
            },

            // y component of the attracting force formula
            yComplexAttracting: function (node, otherNode) {
                return (node.getMass() + otherNode.getMass())/2 * this.attractionConstant *
                        (otherNode.yPosition - node.yPosition) * this.euclideanDistance(node, otherNode);
            },
            // create the square of influence
            createSquare: function(node, offset) {
                return {
                    xMin: node.xPosition - offset,
                    xMax: node.xPosition + offset,
                    yMin: node.yPosition - offset,
                    yMax: node.yPosition + offset
                };
            },
            // check if a node falls within the square of influence
            withinSquare: function(otherNode, square) {
                return  otherNode.xPosition >= square.xMin &&
                        otherNode.xPosition <= square.xMax &&
                        otherNode.yPosition >= square.yMin &&
                        otherNode.yPosition <= square.yMax;
            },

            // calculate all forces and change the velocity and position of the nodes in the array
            simpleLayout: function(nodes) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, k, node, otherNode, edge, curvature;
                var numberOfNodes = nodes.length;
                var numberOfStoppedNodes = 0;

                // set up partitions
                this.partitions = {}; // faster than Object.create(null) for some reason
                this.fuzzing = (this.fuzzing + 1) % 3;
                var key, otherKey, partition, otherPartition, xPosition, yPosition, size;
                size = this.partitionSize - this.fuzz + this.fuzzing * this.fuzz;
                i = numberOfNodes;
                while(i--) {
                    node = nodes[i];
                    // count the number of stopped nodes
                    if(!node.moving || node.fixed)
                        numberOfStoppedNodes++;
                    xPosition = Math.floor(node.xPosition / size);
                    yPosition = Math.floor(node.yPosition / size);
                    key = xPosition.toString();
                    key += '|';
                    key += yPosition.toString();
                    partition = this.partitions[key];
                    if(!partition) {
                        partition = new Partition(node, false);
                        this.partitions[key] = partition;
                    }
                    else {
                        partition.addNode(node);
                    }
                }
                var keys = Object.keys(this.partitions);
                k = keys.length;
                // calculate the velocity of the partitions
                while(k--) {
                    key = keys[k];
                    partition = this.partitions[key];
                    j = keys.length;
                    while(j--) {
                        otherKey = keys[j];
                        if(key !== otherKey) {
                            otherPartition = this.partitions[otherKey];
                            partition.xVelocity +=
                                    otherPartition.nodes.length *
                                            this.xSimpleRepelling(partition, otherPartition);
                            partition.yVelocity +=
                                    otherPartition.nodes.length *
                                            this.ySimpleRepelling(partition, otherPartition);
                        }
                    }
                }
                k = keys.length;
                while(k--) {
                    key = keys[k];
                    partition = this.partitions[key];
                    i = partition.nodes.length;
                    while(i--) {
                        node = partition.nodes[i];
                        // add the long range effect from other partitions, somewhat weakened
                        node.xVelocity += this.longRangeEffect * partition.xVelocity;
                        node.yVelocity += this.longRangeEffect * partition.yVelocity;
                        j = partition.nodes.length;
                        while(j--) {
                            if(i !== j) {
                                otherNode = partition.nodes[j];
                                // for nodes in the same partition add the repelling velocity
                                node.xVelocity += this.xSimpleRepelling(node, otherNode);
                                node.yVelocity += this.ySimpleRepelling(node, otherNode);
                            }
                        }
                        // for edges apply bending force (straightens out edges)
                        if(node.type === NodeType.EDGE && node.otherNode.visible && node.node.visible) {
                            // update the control point
                            node.controlPoint.xPosition = 2 * node.xPosition -
                                    node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                            node.controlPoint.yPosition = 2 * node.yPosition -
                                    node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                            // curvature is higher for a very bent edge (nodes close together)
                            curvature = this.stiffness / this.manhattanDistance(node.node, node.otherNode);
                            // attract the edge mid point to the control point
                            node.xVelocity -= this.xStiffness(node, node.controlPoint, curvature);
                            node.yVelocity -= this.yStiffness(node, node.controlPoint, curvature);
                        }
                        // for nodes, add the attracting velocity from all edges
                        j = node.edges.length;
                        while (j--) {
                            edge = node.edges[j];
                            if (edge.visible) {
                                node.xVelocity += this.xSimpleAttracting(node, edge) / node.edges.length;
                                node.yVelocity += this.ySimpleAttracting(node, edge) / node.edges.length;
                            }
                        }
                        // apply damping
                        node.xVelocity *= this.damping;
                        node.yVelocity *= this.damping;
                        node.velocity = Math.abs(node.xVelocity) + Math.abs(node.yVelocity);
                        // check to see if the node has stopped moving
                        if(node.velocity <= this.stoppingVelocity) {
                            node.stop();
                            node.velocity = node.xVelocity = node.yVelocity = 0; // zero velocity
                        }
                        // the more nodes that have stopped, the larger the starting velocity must be
                        else if(node.velocity >= this.minimumStartingVelocity +
                                this.startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                            node.start();
                        // if the node is moving and not fixed then calculate the new position
                        if(node.moving && !node.fixed) {
                            this.equilibrium = false;
                            node.xPosition += node.xVelocity;
                            node.yPosition += node.yVelocity;
                        }
                    }
                }
            },
            complexLayout: function(nodes) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, k, node, otherNode, edge, curvature;
                var numberOfNodes = nodes.length;
                var numberOfStoppedNodes = 0;

                // set up partitions
                this.partitions = {}; // faster than Object.create(null) for some reason
                this.fuzzing = (this.fuzzing + 1) % 3;
                var key, otherKey, partition, otherPartition, xPosition, yPosition, size;
                size = this.partitionSize - this.fuzz + this.fuzzing * this.fuzz;
                i = numberOfNodes;
                while(i--) {
                    node = nodes[i];
                    // count the number of stopped nodes
                    if(!node.moving || node.fixed)
                        numberOfStoppedNodes++;
                    xPosition = Math.floor(node.xPosition / size);
                    yPosition = Math.floor(node.yPosition / size);
                    key = xPosition.toString();
                    key += '|';
                    key += yPosition.toString();
                    partition = this.partitions[key];
                    if(!partition) {
                        partition = new Partition(node, true); // complex version
                        this.partitions[key] = partition;
                    }
                    else {
                        partition.addNode(node);
                    }
                }
                var keys = Object.keys(this.partitions);
                k = keys.length;
                // calculate the velocity of the partitions
                while(k--) {
                    key = keys[k];
                    partition = this.partitions[key];
                    j = keys.length;
                    while(j--) {
                        otherKey = keys[j];
                        if(key !== otherKey) {
                            otherPartition = this.partitions[otherKey];
                            partition.xVelocity += this.xComplexRepelling(partition, otherPartition);
                            partition.yVelocity += this.yComplexRepelling(partition, otherPartition);
                        }
                    }
                }
                k = keys.length;
                while(k--) {
                    key = keys[k];
                    partition = this.partitions[key];
                    i = partition.nodes.length;
                    while(i--) {
                        node = partition.nodes[i];
                        // add the long range effect from other partitions, somewhat weakened
                        node.xVelocity += this.longRangeEffect * partition.xVelocity;
                        node.yVelocity += this.longRangeEffect * partition.yVelocity;
                        j = partition.nodes.length;
                        while(j--) {
                            if(i !== j) {
                                otherNode = partition.nodes[j];
                                // for nodes in the same partition add the repelling velocity
                                node.xVelocity += this.xComplexRepelling(node, otherNode);
                                node.yVelocity += this.yComplexRepelling(node, otherNode);
                            }
                        }
                        // for edges apply bending force (straightens out edges)
                        if(node.type === NodeType.EDGE && node.otherNode.visible && node.node.visible) {
                            // update the control point
                            node.controlPoint.xPosition = 2 * node.xPosition -
                                    node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                            node.controlPoint.yPosition = 2 * node.yPosition -
                                    node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                            // curvature is higher for a very bent edge (nodes close together)
                            curvature = this.stiffness / this.euclideanDistance(node.node, node.otherNode);
                            // attract the edge mid point to the control point
                            node.xVelocity -= this.xStiffness(node, node.controlPoint, curvature);
                            node.yVelocity -= this.yStiffness(node, node.controlPoint, curvature);
                        }
                        // for nodes, add the attracting velocity from all edges
                        j = node.edges.length;
                        while (j--) {
                            edge = node.edges[j];
                            if (edge.visible) {
                                node.xVelocity += this.xComplexAttracting(node, edge) / node.edges.length;
                                node.yVelocity += this.yComplexAttracting(node, edge) / node.edges.length;
                            }
                        }
                        // apply damping
                        node.xVelocity *= this.damping;
                        node.yVelocity *= this.damping;
                        node.velocity = Math.abs(node.xVelocity) + Math.abs(node.yVelocity);
                        // check to see if the node has stopped moving
                        if(node.velocity <= this.stoppingVelocity) {
                            node.stop();
                            node.velocity = node.xVelocity = node.yVelocity = 0; // zero velocity
                        }
                        // the more nodes that have stopped, the larger the starting velocity must be
                        else if(node.velocity >= this.minimumStartingVelocity +
                                this.startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                            node.start();
                        // if the node is moving and not fixed then calculate the new position
                        if(node.moving && !node.fixed) {
                            this.equilibrium = false;
                            node.xPosition += node.xVelocity;
                            node.yPosition += node.yVelocity;
                        }
                    }
                }
            }
        };

        var Model = {
            // these are used in the cloud
            name: null,
            scope: 'private',
            keywords: null,
            id: null,
            description:null,
            // other members
            components: [],
            visibleNodes: [],
            idToComponent: {}, 
            version: -1,
            versions: [],
            getAnchorLookup: function() {
                var anchorLookup = Object.create(null);
                var component;
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component instanceof Anchor)
                        anchorLookup[component.mnemonic] = component;
                }
                return anchorLookup;
            },
            getKnotLookup: function() {
                var knotLookup = Object.create(null);
                var component;
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component instanceof Knot)
                        knotLookup[component.mnemonic] = component;
                }
                return knotLookup;
            },
            nodeToComponent: function(node) {
                return this.idToComponent[node.id];
            },
            uncloud: function() {
                this.name = null;
                this.scope = 'private';
                this.keywords = null;
                this.id = null;
            },
            isEmpty: function() {
                return this.components.length === 0;
            },
            empty: function() {
                this.components = [];
                this.visibleNodes = [];
                this.idToComponent = Object.create(null);
                SVGLayer.clearAll();
                NAVLayer.clearAll();
            },
            refresh: function() {
                // create a new visibleNodes
                this.visibleNodes = [];
                var component;
                for(var i = 0; component = this.components[i]; i++) {
                    // reset all incompleteness
                    component.updateIncompleteness();
                    if(component.node.visible)
                        this.visibleNodes.push(component.node);
                }
            },
            // TODO: We probably should have a maximum number of versions
            recordState: function() {
                this.refresh();
                // only record if there is something to record
                if(this.components.length) {
                    this.version++;
                    this.versions[this.version] = this.toXML(false);
                    ControlButtons.setUndoLevels(this.version);
                    ControlButtons.setRedoLevels(0);
                }
            },
            clearStates: function() {
                this.version = -1;
                this.versions = [];
                ControlButtons.setUndoLevels(0);
                ControlButtons.setRedoLevels(0);
            },
            undoState: function() {
                this.version -= (this.version === 0 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            redoState: function() {
                this.version += (this.version === this.versions.length - 1 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            setupMinimal: function(ask) {
                var go = ask ? confirm("Are you sure you want to clear the current model?\n" +
                                       "Any unsaved changes will be lost!") : true;
                if(go) {
                    this.uncloud();
                    this.empty();
                    this.addComponent(new Anchor(window.innerWidth/2, window.innerHeight/2));
                    this.refresh();
                    EventHandler.clearSelection();
                    Actions.setModelStatus();
                    Actions.resetZoom();
                    Actions.centerModel();
                    DrawingEngine.start(false);
                }
            },
            isConforming: function() {
                var i, component;
                for(i = 0; component = Model.components[i]; i++)
                    if(!component.isConforming())
                        return false;
                return true;
            },
            /*
            sort: function() {
                this.nodes.sort(function(a, b) {
                    if (a.type === NodeType.EDGE)
                        return -1;
                    if (a.type === NodeType.KNOT &&
                            !(b.type === NodeType.EDGE))
                        return -1;
                    if (a.type === NodeType.ANCHOR &&
                            !(b.type === NodeType.EDGE) &&
                            !(b.type === NodeType.KNOT))
                        return -1;
                    if (a.type === NodeType.ATTRIBUTE &&
                            !(b.type === NodeType.ANCHOR) &&
                            !(b.type === NodeType.EDGE) &&
                            !(b.type === NodeType.KNOT))
                        return -1;
                    return 1;
                });
            },
            */
            addComponent: function(component) {
                // add node at the end of the array
                if(component) {
                    this.components.push(component);
                    this.idToComponent[component.id] = component;
                    // this.sort();
                    this.invalidateComponent(component);
                    this.refresh();
                }
            },
            removeComponent: function(component) {
                if(component.node.type === NodeType.KNOT) {
                    var edge = component.node.edges[0];
                    var otherNode = edge.node === this ? edge.otherNode : edge.node;
                    if(otherNode.type === NodeType.ATTRIBUTE) {
                        var attribute = this.nodeToComponent(otherNode);
                        attribute.setKnotted(false);
                    }
                }
                else if (component.node.type === NodeType.EDGE) {
                    var edge = component.node;
                    this.deleteElementFromArray(edge.node.edges, edge);
                    this.deleteElementFromArray(edge.otherNode.edges, edge);
                }
                delete this.idToComponent[component.id];
                component.hide();
                this.deleteElementFromArray(this.components, component);
                this.refresh();
            },
            deleteElementFromArray: function(array, element) {
                array.splice(array.indexOf(element), 1);
            },
            invalidateComponent: function(component) {
                var square = LayoutEngine.createSquare(component.node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.visibleNodes.length; i++)
                    if(LayoutEngine.withinSquare(this.visibleNodes[i], square))
                        this.visibleNodes[i].start();
            },
            formatDate: function(date, dateOrTime) {
                function z(str) {
                    return ('0' + str).substr(-2, 2);
                }
                var theDate = date.getFullYear() + '-' + z(date.getMonth() + 1) + '-' + z(date.getDate());
                var theTime = z(date.getHours()) + ':' + z(date.getMinutes()) + ':' + z(date.getSeconds());
                if(dateOrTime.toLowerCase() === 'd')
                    return theDate;
                if(dateOrTime.toLowerCase() === 't')
                    return theTime;
                return theDate + ' ' + theTime;
            },
            toXML: function(serialize) {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                var schemaElement = schema.documentElement;
                schemaElement.setAttribute('format', VERSION);
                schemaElement.setAttribute('date', this.formatDate(new Date(), 'd'));
                schemaElement.setAttribute('time', this.formatDate(new Date(), 't'));
                var metadata = schema.createElement('metadata');
                for(var def in Defaults)
                    if(Defaults.hasOwnProperty(def) && Defaults[def])
                        metadata.setAttribute(def, Defaults[def]);
                schemaElement.appendChild(metadata);
                for(var i = 0; i < this.components.length; i++) {
                    var componentElement = this.components[i].toXML(schema);
                    if(componentElement !== null)
                        schemaElement.appendChild(componentElement);
                }
                if(serialize) {
                    var serializationElement = schema.createElement('serialization');
                    var serialization = schema.createTextNode(new XMLSerializer().serializeToString(schema));
                    serializationElement.appendChild(serialization);
                    schemaElement.appendChild(serializationElement);
                }
                return schema;
            },
            fromXML: function(xml) {
                if(xml) {
                    this.empty();
                    var schemaElement = xml.documentElement;
                    var metadata = schemaElement.getElementsByTagName('metadata');
                    var i, def, val, defaults, listOfChanges = [];
                    if(metadata && metadata.length > 0) {
                        metadata = metadata[0]; // from NodeList to Node
                        if(metadata && metadata.hasAttributes && metadata.hasAttributes()) {
                            defaults = metadata.attributes;
                            for(i = 0; i < defaults.length; i++) {
                                def = defaults[i].name;
                                val = defaults[i].value;
                                if(Defaults.hasOwnProperty(def) && Defaults[def] != val)
                                    listOfChanges.push(def + ': ' + Defaults[def] + ' -> ' + val);
                            }
                            if(listOfChanges.length > 0) {
                                if(confirm(
                                    "The loaded model wants to change these defaults:\n\n" +
                                    listOfChanges.join('\n') + '\n\n' +
                                    "Would you like to accept these changes?\n" +
                                    "Accepting overwrites your current settings!"
                                )) {
                                    for(i = 0; i < defaults.length; i++) {
                                        def = defaults[i].name;
                                        val = defaults[i].value;
                                        if(Defaults.hasOwnProperty(def) && Defaults[def] != val)
                                            Defaults[def] = val;
                                    }
                                    // backwards compatibility
                                    switch (Defaults.temporalization) {
                                        case "mono":
                                            Defaults.temporalization = "uni";
                                            break;
                                        case "bi":
                                            Defaults.temporalization = "crt";
                                            break;
                                    }
                                    Settings.storeSettings(window.localStorage);
                                    Settings.loadSettings(window.localStorage);
                                }
                            }
                        }
                    }
                    // the order in which we add these are important (attributes create edges to anchors)
                    var knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addComponent(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addComponent(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addComponent(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addComponent(Tie.prototype.fromXML(ties[i]));
                    // implode nodes
                    var component, allComponents = [];
                    for(i = 0; component = this.components[i]; i++) {
                        if(component.imploded) {
                            component.imploded = false;
                            allComponents.push(component);
                        }
                    }
                    this.explode(allComponents, false);
                    this.refresh();
                }
            },
            erase: function(components) {
                DrawingEngine.stop();
                var i, j, component, role, node, otherNode, otherComponent, edge, affectedComponents = [];
                for(i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.EDGE && affectedComponents.indexOf(component) < 0)
                        affectedComponents.push(component);
                    else if (node.type === NodeType.ANCHOR && affectedComponents.indexOf(component) < 0) {
                        affectedComponents.push(component);
                        for(j = 0; edge = node.edges[j]; j++) {
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(role) < 0)
                                affectedComponents.push(role);
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            if(otherNode.type === NodeType.ATTRIBUTE && affectedComponents.indexOf(otherComponent) < 0)
                                affectedComponents.push(otherComponent);
                        }
                    }
                    else if ((node.type === NodeType.TIE ||
                            node.type === NodeType.ATTRIBUTE ||
                            node.type === NodeType.KNOT) &&
                            affectedComponents.indexOf(component) < 0) {
                        affectedComponents.push(component);
                        for(j = 0; edge = node.edges[j]; j++) {
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(role) < 0)
                                affectedComponents.push(role);
                        }
                    }
                }
                // check for ties in violation
                for(i = 0; component = this.components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.TIE) {
                        var anchors = 0;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(otherComponent) < 0 && affectedComponents.indexOf(role) < 0)
                                if(otherNode.type === NodeType.ANCHOR)
                                    anchors++;
                        }
                        if(anchors < 2 && affectedComponents.indexOf(component) < 0) {
                            affectedComponents.push(component);
                            for(j = 0; edge = node.edges[j]; j++) {
                                role = this.nodeToComponent(edge);
                                if(affectedComponents.indexOf(role) < 0)
                                    affectedComponents.push(role);
                            }
                        }
                    }
                }
                // check for dangling knots
                for(i = 0; component = this.components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.KNOT) {
                        var dangling = true;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            if(affectedComponents.indexOf(otherComponent) < 0)
                                dangling = false;
                        }
                        if(dangling) {
                            affectedComponents.push(component);
                            for(j = 0; edge = node.edges[j]; j++) {
                                role = this.nodeToComponent(edge);
                                if(affectedComponents.indexOf(role) < 0)
                                    affectedComponents.push(role);
                            }
                        }
                    }
                }
                if(confirm("Are you sure you want to delete the following?\n-- " +
                        affectedComponents.length + " nodes and  edges --\n" + affectedComponents.join('\n'))) {
                    for(i = 0; component = affectedComponents[i]; i++)
                        this.removeComponent(component);
                    this.recordState();
                    this.refresh();
                    DrawingEngine.start(true);
                }
            },
            connect: function(components) {
                var node, anchor, attribute, tie, knot;
                for(var i = 0; i < components.length; i++) {
                    node = components[i].node;
                    if(node.type === NodeType.ANCHOR)
                        anchor = components[i];
                    else if(node.type === NodeType.ATTRIBUTE)
                        attribute = components[i];
                    else if(node.type === NodeType.TIE)
                        tie = components[i];
                    else if(node.type === NodeType.KNOT)
                        knot = components[i];
                }
                if(anchor && tie) {
                    this.addComponent(new Role(tie, anchor, false));
                }
                else if (attribute && knot) {
                    attribute.setKnotted(true);
                    this.addComponent(new Role(attribute, knot, false));
                }
                else if (tie && knot) {
                    tie.setKnotted(true);
                    this.addComponent(new Role(tie, knot, false));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleKnotted: function(components) {
                var dx, dy;
                for(var i = 0; i < components.length; i++) {
                    var knot, role, edge;
                    var component = components[i];
                    var node = component.node;
                    if(component.getKnotted()) {
                        for(var j = 0; edge = node.edges[j]; j++) {
                            if(edge.otherNode.type === NodeType.KNOT) {
                                knot = this.nodeToComponent(edge.otherNode);
                                if(edge.otherNode.edges.length === 1) {
                                    if(!confirm("This will also delete the knot: " + knot +
                                            ".\nDo you still want to un-knot the attribute?"))
                                        break;
                                }
                                this.removeComponent(knot);
                                role = this.nodeToComponent(edge);
                                this.removeComponent(role);
                                if(knot.dataRange)
                                    component.dataRange = knot.dataRange;
                                component.setKnotted(false);
                            }
                        }
                    }
                    else {
                        this.lastAngle = (this.lastAngle + 0.5) % 14;
                        dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                        dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                        knot = new Knot(node.xPosition + dx, node.yPosition + dy);
                        if(component.dataRange)
                            knot.dataRange = component.dataRange;
                        this.addComponent(knot);
                        this.addComponent(new Role(component, knot, true));
                        component.setKnotted(true);
                    }
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            toggleHistorized: function(components) {
                var component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    component.setHistorized(!component.getHistorized());
                    node = component.node;
                    if(node.type === NodeType.TIE)
                        component.checkIdentifiers();
                }
                this.recordState();
                DrawingEngine.start(false);
            },
            toggleIdentifier: function(components) {
                var ties = [], component, node, edge;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    if(node.type === NodeType.EDGE) {
                        edge = node;
                        component.setIdentifier(!component.identifier);
                        if(edge.node.type === NodeType.TIE && ties.indexOf(edge.node) < 0)
                            ties.push(this.nodeToComponent(edge.node));
                        if(edge.otherNode.type === NodeType.TIE && ties.indexOf(edge.otherNode) < 0)
                            ties.push(this.nodeToComponent(edge.otherNode));
                    }
                }
                for(i = 0; i < ties.length; i++)
                    ties[i].checkIdentifiers();
                this.recordState();
                DrawingEngine.start(false);
            },
            makeFirstRole: function(components) {
                var tie, component, node, edge;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    if(node.type === NodeType.EDGE) {
                        edge = node;
                        if(tie = edge.node.type === NodeType.TIE ? edge.node :
                                        edge.otherNode.type === NodeType.TIE ? edge.otherNode : null) {
                            tie.setFirstRole(component);
                        }
                    }
                }
                this.recordState();
                DrawingEngine.start(false);
            },
            lastAngle: 0,
            addAttribute: function(components) {
                var dx, dy, node, component;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var attribute = new Attribute(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(attribute);
                    this.addComponent(new Role(attribute, component, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            addTie: function(components) {
                var tie, component, node;
                // multiple anchors selected
                if(components.length > 1) {
                    var i, xAverage = 0, yAverage = 0;
                    for(i = 0; i < components.length; i++) {
                        node = components[i].node;
                        xAverage += node.xPosition;
                        yAverage += node.yPosition;
                    }
                    xAverage /= components.length;
                    yAverage /= components.length;
                    tie = new Tie(xAverage, yAverage, false);
                    this.addComponent(tie);
                    for(i = 0; i < components.length; i++)
                        this.addComponent(new Role(tie, components[i], true));
                }
                // single anchor selected
                else {
                    var anchor = components[0];
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    var dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    var dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    tie = new Tie(anchor.node.xPosition + dx, anchor.node.yPosition + dy, false);
                    this.addComponent(tie);
                    var role = new Role(tie, anchor, true);
                    this.addComponent(role);
                    role = new Role(tie, anchor, true);
                    this.addComponent(role);
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            addAnchor: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var anchor = new Anchor(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(anchor);
                    this.addComponent(new Edge(component, anchor, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            addTieAndAnchor: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var tie = new Tie(node.xPosition + dx, node.yPosition + dy, false);
                    this.addComponent(tie);
                    var role = new Role(tie, component, true);
                    this.addComponent(role);
                    var anchor = new Anchor(node.xPosition + 2*dx, node.yPosition + 2*dy);
                    this.addComponent(anchor);
                    role = new Role(tie, anchor, true);
                    this.addComponent(role);
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            addKnot: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var knot = new Knot(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(knot);
                    this.addComponent(new Edge(component, knot, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
            },
            explode: function(components, startEngine) {
                var node, component, i, j, k, edge, otherNode, otherComponent;
                var role, knot, knotComponent, knotEdge, knotEdgeComponent, visibleEdges;
                for(i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.ANCHOR) {
                        if(component.imploded) {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node === node ? edge.otherNode : edge.node;
                                if(otherNode.type === NodeType.ATTRIBUTE) {
                                    var dx = 2 * LayoutEngine.normalDistance * Math.cos(j);
                                    var dy = 2 * LayoutEngine.normalDistance * Math.sin(j);
                                    otherComponent = this.nodeToComponent(otherNode);
                                    if(otherComponent.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node === otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot.type === NodeType.KNOT) {
                                                break;
                                            }
                                        }
                                        knotComponent = this.nodeToComponent(knot);
                                        if(!knot.visible) {
                                            knot.xPosition = node.xPosition + 2*dx;
                                            knot.yPosition = node.yPosition + 2*dy;
                                            knot.start();
                                            knot.visible = true;
                                            knotComponent.setFixed(false);
                                            knotComponent.show();
                                        }
                                        knotEdgeComponent = this.nodeToComponent(knotEdge);
                                        knotEdge.start();
                                        knotEdge.visible = true;
                                        knotEdgeComponent.show();
                                    }
                                    otherComponent = this.nodeToComponent(otherNode);
                                    otherNode.xPosition = node.xPosition + dx;
                                    otherNode.yPosition = node.yPosition + dy;
                                    otherNode.start();
                                    otherComponent.setFixed(false);
                                    otherComponent.show();
                                    otherNode.visible = true;
                                    role = this.nodeToComponent(edge);
                                    edge.start();
                                    role.show();
                                    edge.visible = true;
                                }
                            }
                        }
                        else {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node === node ? edge.otherNode : edge.node;
                                if(otherNode.type === NodeType.ATTRIBUTE) {
                                    otherComponent = this.nodeToComponent(otherNode);
                                    if(otherComponent.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node === otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot.type === NodeType.KNOT) {
                                                break;
                                            }
                                        }
                                        knotEdgeComponent = this.nodeToComponent(knotEdge);
                                        knotEdgeComponent.hide();
                                        knotEdge.stop();
                                        knotEdge.visible = false;
                                        visibleEdges = 0;
                                        for(k = 0; knotEdge = knot.edges[k]; k++)
                                            if(knotEdge.visible)
                                                visibleEdges++;
                                        if(visibleEdges === 0) {
                                            knotEdgeComponent.hide();
                                            knot.stop();
                                            knot.visible = false;
                                        }
                                    }
                                    otherComponent.hide();
                                    otherNode.stop();
                                    otherNode.visible = false;
                                    role = this.nodeToComponent(edge);
                                    role.hide();
                                    edge.stop();
                                    edge.visible = false;
                                }
                            }
                        }
                        component.setImploded(!component.imploded);
                    }
                }
                this.refresh();
                if(startEngine == null || startEngine)
                    DrawingEngine.start(true);
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            initialized: false,
            running: false,
            miniCounter: 0,
            miniature: null,
            showNames: false,
            coloring: true,
            newState: true,
            miniatureFramesBetweenRefresh: 50,
            layout: false,
            viewport: null,
            screenCircumference: 0,
            partitionElements: [],
            init: function() {
                var requestAnimationFrame =
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        window.oRequestAnimationFrame;
                window.requestAnimationFrame = requestAnimationFrame;
                if(!window.requestAnimationFrame) {
                    window.requestAnimationFrame = function(callback, image) {
                        return setTimeout(callback, 10);
                    };
                }
                var cancelRequestAnimationFrame =
                        window.cancelRequestAnimationFrame ||
                        window.webkitCancelRequestAnimationFrame ||
                        window.mozCancelRequestAnimationFrame ||
                        window.msCancelRequestAnimationFrame ||
                        window.oCancelRequestAnimationFrame;
                window.cancelRequestAnimationFrame = cancelRequestAnimationFrame;
                if(!window.cancelRequestAnimationFrame) {
                    window.cancelRequestAnimationFrame = function(id) {
                        return clearTimeout(id);
                    };
                }
                this.viewport = document.createElementNS(SVGNS, 'rect');
                this.viewport.setAttributeNS(null, 'id', 'viewport');
                this.viewport.setAttributeNS(null, 'x', SVG.viewBox.baseVal.x);
                this.viewport.setAttributeNS(null, 'y', SVG.viewBox.baseVal.y);
                this.viewport.setAttributeNS(null, 'width', SVG.viewBox.baseVal.width);
                this.viewport.setAttributeNS(null, 'height', SVG.viewBox.baseVal.height);
                this.viewport.setAttributeNS(null, 'style', 'stroke: red; stroke-width: 2px; fill: none;');
                this.initialized = true;
            },
            taint: function() {
                this.partitionElements = [];
            },
            storeSettings: function(storage) {
                storage.setItem("viewportX", SVG.viewBox.baseVal.x);
                storage.setItem("viewportY", SVG.viewBox.baseVal.y);
                storage.setItem("viewportWidth", SVG.viewBox.baseVal.width);
                storage.setItem("viewportHeight", SVG.viewBox.baseVal.height);
            },
            loadSettings: function(storage) {
                SVG.viewBox.baseVal.x = 1 * storage.getItem("viewportX") || 0;
                SVG.viewBox.baseVal.y = 1 * storage.getItem("viewportY") || 0;
                SVG.viewBox.baseVal.width = 1 * storage.getItem("viewportWidth") || window.innerWidth;
                SVG.viewBox.baseVal.height = 1 * storage.getItem("viewportHeight") || window.innerHeight;
                this.invalidateMiniature();
                this.start(false);
            },
            setCursor: function(cursor) {
                document.body.style.cursor = cursor;
            },
            start: function(layoutModel) {
                if(this.initialized) {
                    this.layout = layoutModel;
                    if(!this.running) {
                        this.running = true;
                        this.drawId = window.requestAnimationFrame(DrawingEngine.engine, SVG);
                        if(this.layout)
                            ControlButtons.setPauseState();
                    }
                }
            },
            stop: function() {
                if(this.running) {
                    window.cancelRequestAnimationFrame(this.drawId);
                    this.running = false;
                    ControlButtons.setPlayState();
                }
            },
            engine: function() {
                // layout nodes
                if(DrawingEngine.layout || !LayoutEngine.equilibrium) {
                    LayoutEngine.layout(Model.visibleNodes);
                    DrawingEngine.newState = true;
                }
                DrawingEngine.draw();
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    DrawingEngine.stop();
                    DrawingEngine.invalidateMiniature();
                    if(DrawingEngine.newState) {
                        DrawingEngine.newState = false;
                        Model.recordState();
                    }
                    DrawingEngine.layout = false;
                    ControlButtons.setPlayState();
                }
                else if(DrawingEngine.running) {
                    window.requestAnimationFrame(DrawingEngine.engine, SVG);
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            drawPartitions: function() {
                var partition, partitionElement, centerElement, k, key;
                var keys = Object.keys(LayoutEngine.partitions);
                var lost = this.partitionElements.filter(function(i) {return !(keys.indexOf(i) > -1);});
                k = lost.length;
                while(k--) {
                    key = lost[k];
                    partitionElement = document.getElementById(key);
                    SVGLayer.debugPartitions.removeChild(partitionElement);
                    this.partitionElements.splice(this.partitionElements.indexOf(key),1);
                    centerElement = document.getElementById('c' + key);
                    SVGLayer.debugPartitions.removeChild(centerElement);
                }
                k = keys.length;
                while(k--) {
                    key = keys[k];
                    partition = LayoutEngine.partitions[key];
                    partitionElement = document.getElementById(key);
                    centerElement = document.getElementById('c' + key);
                    if(!partitionElement) {
                        partitionElement = document.createElementNS(SVGNS, 'rect');
                        partitionElement.setAttributeNS(null, 'id', key);
                        SVGLayer.debugPartitions.appendChild(partitionElement);
                        this.partitionElements.push(key);
                        centerElement = document.createElementNS(SVGNS, 'circle');
                        centerElement.setAttributeNS(null, 'id', 'c' + key);
                        centerElement.style.strokeWidth = 2;
                        SVGLayer.debugPartitions.appendChild(centerElement);
                    }
                    partitionElement.x.baseVal.value = partition.xMin;
                    partitionElement.y.baseVal.value = partition.yMin;
                    partitionElement.width.baseVal.value = partition.xMax - partition.xMin;
                    partitionElement.height.baseVal.value = partition.yMax - partition.yMin;
                    centerElement.cx.baseVal.value = partition.xPosition;
                    centerElement.cy.baseVal.value = partition.yPosition;
                    centerElement.r.baseVal.value = 100*(Math.abs(partition.xVelocity) + Math.abs(partition.yVelocity));
                }
            },
            draw: function() {
                if(DEBUG) this.drawPartitions();
                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % this.miniatureFramesBetweenRefresh;
                var i, component;
                i = Model.components.length;
                while(i--) {
                    component = Model.components[i];
                    if(component.node.visible) {
                        component.draw(component.svg);
                        if(this.miniCounter === 1)
                            component.draw(component.nav);
                        if(this.showNames)
                            component.drawName(component.node.xPosition, component.node.yPosition);
                    }
                }
                if(this.miniCounter === 1)
                    this.updateMiniature();
            },
            updateMiniature: function() {
                if(!NAVLayer.viewport.contains(this.viewport))
                    NAVLayer.viewport.appendChild(this.viewport);
                this.viewport.x.baseVal.value = SVG.viewBox.baseVal.x;
                this.viewport.y.baseVal.value = SVG.viewBox.baseVal.y;
                this.viewport.width.baseVal.value = SVG.viewBox.baseVal.width || window.innerWidth;
                this.viewport.height.baseVal.value = SVG.viewBox.baseVal.height || window.innerHeight;
                var nodeBox = NAV.getElementById('nodes').getBBox();
                var pad = 50;
                var width = nodeBox.width + 2 * pad;
                var height = nodeBox.height + 2 * pad;
                var screenCircumference = window.innerWidth + window.innerHeight;
                var viewportCircumference = width + height;
                var scale;
                if(viewportCircumference < screenCircumference/6) {
                    scale = screenCircumference/6/viewportCircumference;
                    width *= scale;
                    height *= scale;
                }
                else if(viewportCircumference > screenCircumference/4) {
                    scale = screenCircumference/4/viewportCircumference;
                    height *= scale;
                    width *= scale;
                }
                NAV.style.width = width + 'px';
                NAV.style.height = height + 'px';
                NAV.viewBox.baseVal.x = nodeBox.x - pad;
                NAV.viewBox.baseVal.y = nodeBox.y - pad;
                NAV.viewBox.baseVal.width = nodeBox.width + 2 * pad;
                NAV.viewBox.baseVal.height = nodeBox.height + 2 * pad;
            }
        };

        var UniqueIdentity = {
            lastId: 0,
            usedIds: [],
            nextId: function() {
                while(this.usedIds[++this.lastId]);
                this.usedIds[this.lastId] = true;
                return this.lastId;
            },
            takeId: function(id) {
                this.usedIds[id] = true;
                return id;
            }
        };

        var Editables = {
            setEditability: function(edit, isEditable) { edit.editable = isEditable; },
            descriptorEdit: {
                name: 'Descriptor',
                description:
                       'Should be a descriptive name of that which you are creating. ' +
                       'An understandable description of something found in the domain ' +
                       'you are modeling, for example "CoffeeMachine".',
                setMember: function (element, component) { component.descriptor = element.value; },
                getMember: function (component) { return component.descriptor; },
                setElement: function (element, component) { element.value = component.descriptor; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '(' + UPPER + LOWER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            twoMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A two letter mnemonic, that needs to be unique within the entire ' +
                       'model. If an anchor is named "CoffeeMachine" for example, then ' +
                       '"CM" is a suitable mnemonic.',
                setMember: function (element, component) { component.mnemonic = element.value; },
                getMember: function (component) { return component.mnemonic; },
                setElement: function (element, component) { element.value = component.mnemonic; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: UPPER + '{2}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            threeMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A three letter mnemonic, that needs to be unique within the entire ' +
                       'model for knots, but only within the anchor for attributes. If an ' +
                       'attribute is named "Capacity" for example, then "CAP" is a ' +
                       'suitable mnemonic.',
                setMember: function (element, component) { component.mnemonic = element.value; },
                getMember: function (component) { return component.mnemonic; },
                setElement: function (element, component) { element.value = component.mnemonic; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: UPPER + '{3}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                description: 'The data type of the column in the resulting implementation.',
                setMember: function (element, component) { component.dataRange = element.value; },
                getMember: function (component) { return component.dataRange; },
                setElement: function (element, component) { element.value = component.dataRange; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            changingRangeEdit: {
                name: 'Time range',
                description:
                       'Changing time data type. Versions of data are stored over changing time ' +
                       'and this data type should be granular enough to handle the expected ' +
                       'update frequency.',
                setMember: function (element, component) { component.changingRange = element.value; },
                getMember: function (component) { return component.changingRange; },
                setElement: function (element, component) { element.value = component.changingRange; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            positIdentityEdit: {
                name: 'Posit identity',
                description:
                        'Posit identity data type. This should be at large enough to be able to give ' +
                        'identities to all posits that will be stored. With rapidly changing ' +
                        'data this may be much larger than the other involved identities.',
                setMember: function (element, component) { component.positIdentity = element.value; },
                getMember: function (component) { return component.positIdentity; },
                setElement: function (element, component) { element.value = component.positIdentity; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            identityEdit: {
                name: 'Identity',
                description:
                       'Identity data type. The identity is an abstract and immutable property ' +
                       'that uniquely identifies an entity. If you expect to store very many ' +
                       'entities you also need an appropriately large data type.',
                setMember: function (element, component) { component.identity = element.value; },
                getMember: function (component) { return component.identity; },
                setElement: function (element, component) { element.value = component.identity; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            positGeneratorEdit: {
                name: 'Posit generator',
                description:
                        'Posit identity generator. Check this if you would like the database to generate ' +
                        ' posit identities for you through some auto incremented sequence. Uncheck if you ' +
                        'intend to manage your identities somewhere else.',
                setMember: function (element, component) { component.positGenerator = element.checked; },
                getMember: function (component) { return component.positGenerator; },
                setElement: function (element, component) { element.checked = component.positGenerator; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            generatorEdit: {
                name: 'Generator',
                description:
                       'Identity generator. Check this if you would like the database to generate ' +
                       'identities for you through some auto incremented sequence. Uncheck if you ' +
                       'intend to manage your identities somewhere else.',
                setMember: function (element, component) { component.generator = element.checked; },
                getMember: function (component) { return component.generator; },
                setElement: function (element, component) { element.checked = component.generator; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            restatabilityEdit: {
                name: 'Restatable',
                description:
                       'Check this if you want to allow temporal restatements. A temporal restatement ' +
                       'is when two consecutive values over changing time are identical. Uncheck this ' +
                       'to introduce a constraint preventing restatements from being made.',
                setMember: function (element, component) { component.restatable = element.checked; },
                getMember: function (component) { return component.restatable; },
                setElement: function (element, component) { element.checked = component.restatable; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            idempotencyEdit: {
                name: 'Idempotent',
                description:
                       'Checking this modifies the insert and update triggers such that changed values ' +
                       'must be different in order to be recorded. Idempotency is not recommended when ' +
                       'data can arrive asynchronously with respect to changing time.',
                setMember: function (element, component) { component.idempotent = element.checked; },
                getMember: function (component) { return component.idempotent; },
                setElement: function (element, component) { element.checked = component.idempotent; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            assertivenessEdit: {
                name: 'Assertive',
                description:
                       'Checking this modifies the insert and update triggers such that the annex will ' +
                       'get new rows everytime a posit is made with a different positing time. Otherwise ' +
                       'the annex will only get new rows if the reliability changes as well.',
                setMember: function (element, component) { component.assertive = element.checked; },
                getMember: function (component) { return component.assertive; },
                setElement: function (element, component) { element.checked = component.assertive; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            equivalenceEdit: {
                name: 'Equivalent',
                description:
                        'Checking this makes it possible to store several equivalent values, ' +
                        'which for example is useful when multilingualism or multitenancy is desired.',
                setMember: function (element, component) { component.equivalent = element.checked; },
                getMember: function (component) { return component.equivalent; },
                setElement: function (element, component) { element.checked = component.equivalent; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            checksumEdit: {
                name: 'Checksum',
                description:
                        'Checking this indicates that your data type is too large to fit in ' +
                        'indexes, and a calculated checksum column will be added that can be  ' +
                        'used instead.',
                setMember: function (element, component) { component.checksum = element.checked; },
                getMember: function (component) { return component.checksum; },
                setElement: function (element, component) { element.checked = component.checksum; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            roleEdit: {
                name: 'Role',
                description:
                       'The role of the connected entity in the relationship. The same entity may, for example ' +
                       'participate more than once in the same relationship and must therefore be distinguished ' +
                       'through which role it plays. Because of this, roles must be unique within a tie.',
                setMember: function (element, component) { component.role = element.value; },
                getMember: function (component) { return component.role; },
                setElement: function (element, component) { element.value = component.role; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '(' + LOWER + UPPER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            coloringEdit: {
                name: 'Coloring',
                description:
                        'Coloring can be used to create your own visual separation of the components in a model. It ' +
                        'has no effect on the implementation.',
                setMember: function (element, component) { component.setColoring(element.value); },
                getMember: function (component) { return component.coloring; },
                setElement: function (element, component) { element.value = component.coloring; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '#[0-9A-Fa-f]{6}',
                event: 'change',
                attributes: ['type', 'color', 'required', 'required']
            },
            encapsulationEdit: {
                name: 'Capsule',
                description:
                       'In order to achieve separation of concerns, different parts of the model can be encapsulated ' +
                       'in different "capsules", which translate to schemas in the relational database implementation.',
                setMember: function (element, component) { component.encapsulation = element.value; },
                getMember: function (component) { return component.encapsulation; },
                setElement: function (element, component) { element.value = component.encapsulation; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: LOWER + '*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            descriptionEdit: {
                name: 'Description',
                description:
                        'A textual description of this item.',
                setMember: function (element, component) { component.description = element.value; },
                getMember: function (component) { return component.description; },
                setElement: function (element, component) { element.value = component.description; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'textarea',
                pattern: null, // anything and nothing are all fine
                event: 'blur',
                attributes: ['rows', '3', 'cols', '16']
            }
        };

        var EventHandler = {
            selectedComponents: [], // may be larger than interacted with SHIFT clicks
            interactedComponents: [], // currently "touched" components
            interaction: null,
            previousInteraction: null,
            lastX: null,
            lastY: null,
            scaleX: null,
            scaleY: null,
            addComponentToSelection: function(component) {
                if(this.selectedComponents.indexOf(component) < 0)
                    this.selectedComponents.push(component);
                component.setSelection(true);
            },
            removeComponentFromSelection: function(component) {
                if(this.selectedComponents.indexOf(component) >= 0)
                    this.selectedComponents.splice(this.selectedComponents.indexOf(component), 1);
                component.setSelection(false);
            },
            clearSelection: function() {
                var component;
                while(component = this.selectedComponents.pop()) {
                    this.removeComponentFromSelection(component);
                }
                this.setInteraction(null);
            },
            isSelected: function(component) {
                return this.selectedComponents.indexOf(component) >= 0;
            },
            setInteraction: function(interaction) {
                if(this.interaction) this.previousInteraction = this.interaction;
                this.interaction = interaction;
            },
            getInteraction: function() {
                return this.interaction;
            },
            getPreviousInteraction: function() {
                return this.previousInteraction;
            },
            addComponentToInteraction: function(component) {
                if(this.interactedComponents.indexOf(component) < 0)
                    this.interactedComponents.push(component);
                component.setHighlight(true);
            },
            removeComponentFromInteraction: function(component) {
                if(this.interactedComponents.indexOf(component) >= 0)
                    this.interactedComponents.splice(this.interactedComponents.indexOf(component), 1);
                component.setHighlight(false);
            },
            clearInteraction: function() {
                var component;
                while(component = this.interactedComponents.pop()) {
                    this.removeComponentFromInteraction(component);
                }
                this.setInteraction(null);
            },
            isInteracted: function(component) {
                return this.interactedComponents.indexOf(component) >= 0;
            },
            hasOngoingInteractions: function() {
                return this.interaction != null;
            },
            beginInteraction: function(event) {
                event.preventDefault();
                var component = this.component; // note that _this_ refers to the SVG element here
                if(!EventHandler.hasOngoingInteractions() && component.isInteractive()) {
                    EventHandler.setInteraction("beginInteraction");
                    if(!EventHandler.isInteracted(component))
                        EventHandler.addComponentToInteraction(component);
                    window.addEventListener('keypress', EventHandler.keypress, false);
                    SVG.addEventListener('mouseover', EventHandler.endInteraction, false);
                    component.svg.graphicsElement.addEventListener('mousedown', EventHandler.prepareDragging, false);
                    component.svg.graphicsElement.addEventListener('click', EventHandler.clickComponent, false);
                    component.showContextMenu(component, EventHandler.selectedComponents);
                    DrawingEngine.setCursor('pointer');
                }
                event.stopPropagation();
            },
            prepareDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "beginInteraction") {
                    EventHandler.setInteraction("prepareDragging");
                    var component, i;
                    for(i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        if(event.shiftKey) {
                            if(EventHandler.isSelected(component)) {
                                EventHandler.removeComponentFromSelection(component);
                                component.setHighlight(true);
                            }
                            else {
                                EventHandler.addComponentToSelection(component);
                                component.setHighlight(false);
                            }
                        }
                        component.hideContextMenu();
                        component.svg.graphicsElement.removeEventListener('mousedown', EventHandler.prepareDragging, false);
                    }
                    SVG.addEventListener('mousemove', EventHandler.whileDragging, false);
                }
                event.stopPropagation();
            },
            whileDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileDragging" ||
                        EventHandler.getInteraction() === "prepareDragging") {
                    var component, i, svgPoint;
                    for(i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        if(component.isInteractive() && component.isDraggable()) {
                            svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY)
                            if(EventHandler.getInteraction() === "whileDragging") {
                                component.node.xPosition = svgPoint.x;
                                component.node.yPosition = svgPoint.y;
                                component.setFixed(true);
                                Model.invalidateComponent(component);
                                DrawingEngine.start(true);
                            }
                            else if(EventHandler.getInteraction() === "prepareDragging") {
                                if(LayoutEngine.manhattanDistance(component.node, {
                                    xPosition: svgPoint.x,
                                    yPosition: svgPoint.y
                                }) > 10) {
                                    EventHandler.setInteraction("whileDragging");
                                    DrawingEngine.setCursor('move');
                                }
                            } // switch behavior if we actually move the thing a fair distance
                        }
                    }
                }
                event.stopPropagation();
            },
            clickComponent: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() !== "whileDragging" && !event.shiftKey) {
                    var component, i = EventHandler.interactedComponents.length;
                    while(i--) {
                        component = EventHandler.interactedComponents[i];
                        component.setFixed(!component.getFixed());
                    }
                    EventHandler.setInteraction("toggledFixation");
                }
                else {
                    EventHandler.setInteraction("completeDragging");
                }
                event.stopPropagation();
            },
            clickHighlight: function(event) {
                // nothing assigned to this action right now
            },
            clickSelection: this.clickHighlight,
            endInteraction: function(event) {
                event.preventDefault();
                var component = EventHandler.interactedComponents[EventHandler.interactedComponents.length - 1];
                if(event.toElement !== component.svg.graphicsElement &&
                        EventHandler.getInteraction() !== "whileDragging") {
                    for(var i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        component.hideContextMenu();
                        component.svg.graphicsElement.removeEventListener('click', EventHandler.clickComponent, false);
                    }
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whileDragging, false);
                    SVG.removeEventListener('mouseover', EventHandler.endInteraction, false);
                    window.removeEventListener('keypress', EventHandler.keypress, false);
                    DrawingEngine.setCursor('default');
                }
                event.stopPropagation();
            },
            preparePanning: function(event) {
                event.preventDefault();
                if(event.shiftKey) {
                    // we are shift clicking the background
                    EventHandler.clearSelection();
                }
                else if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("preparePanning");
                    var screenWidth = window.innerWidth;
                    var screenHeight = window.innerHeight;
                    var viewBoxWidth = SVG.viewBox.baseVal.width || screenWidth;
                    var viewBoxHeight = SVG.viewBox.baseVal.height || screenHeight;
                    EventHandler.scaleX = viewBoxWidth / screenWidth;
                    EventHandler.scaleY = viewBoxHeight / screenHeight;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                    SVG.addEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.addEventListener('mouseup', EventHandler.completePanning, false);
                    DrawingEngine.setCursor('move');
                }
                event.stopPropagation();
            },
            whilePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning" ||
                        EventHandler.getInteraction() === "preparePanning") {
                    EventHandler.setInteraction("whilePanning");
                    SVG.viewBox.baseVal.x -= (event.clientX - EventHandler.lastX) * EventHandler.scaleX;
                    SVG.viewBox.baseVal.y -= (event.clientY - EventHandler.lastY) * EventHandler.scaleY;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                }
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            completePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning") {
                    EventHandler.setInteraction("completePanning");
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.removeEventListener('mouseup', EventHandler.completePanning, false);
                    DrawingEngine.setCursor('default');
                }
                event.stopPropagation();
            },
            scaling: 0.03,
            zoom: function(event) {
                event.preventDefault();
                var zoom = 1 + ((event.detail<0 || event.wheelDelta>0) ? 1 : -1) * EventHandler.scaling;
                var width = SVG.viewBox.baseVal.width || SVG.width.baseVal.value;
                var height = SVG.viewBox.baseVal.height || SVG.height.baseVal.value;
                var x = SVG.viewBox.baseVal.x;
                var y = SVG.viewBox.baseVal.y;
                var svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY);
                SVG.viewBox.baseVal.width = width * zoom;
                SVG.viewBox.baseVal.height = height * zoom;
                SVG.viewBox.baseVal.x = x + (1 - zoom) * (svgPoint.x - x);
                SVG.viewBox.baseVal.y = y + (1 - zoom) * (svgPoint.y - y);
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            resize: function(event) {
                var northwest = EventHandler.screenToSVG(0, 0);
                var southeast = EventHandler.screenToSVG(window.innerWidth, window.innerHeight);
                SVG.viewBox.baseVal.x = northwest.x;
                SVG.viewBox.baseVal.y = northwest.y;
                SVG.viewBox.baseVal.width = southeast.x - northwest.x;
                SVG.viewBox.baseVal.height = southeast.y - northwest.y;
            },
            screenToSVG: function(x, y) {
                var screenPoint = SVG.createSVGPoint();
                screenPoint.x = x;
                screenPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return screenPoint.matrixTransform( matrix.inverse() );
            },
            svgToScreen: function(x, y) {
                var svgPoint = SVG.createSVGPoint();
                svgPoint.x = x;
                svgPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return svgPoint.matrixTransform( matrix );
            },
            screenToMiniature: function(x, y) {
                var screenPoint = NAV.createSVGPoint();
                screenPoint.x = x;
                screenPoint.y = y;
                var matrix = NAV.getScreenCTM();
                return screenPoint.matrixTransform( matrix.inverse() );
            },
            miniatureToScreen: function(x, y) {
                var svgPoint = NAV.createSVGPoint();
                svgPoint.x = x;
                svgPoint.y = y;
                var matrix = NAV.getScreenCTM();
                return svgPoint.matrixTransform( matrix );
            },
            prepareNavigation: function(event) {
                event.preventDefault();
                if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("prepareNavigation");
                    var miniature = document.getElementById("miniature");
                    var miniatureWidth = miniature.offsetWidth;
                    var miniatureHeight = miniature.offsetHeight;
                    var viewBoxWidth = NAV.viewBox.baseVal.width || miniatureWidth;
                    var viewBoxHeight = NAV.viewBox.baseVal.height || miniatureHeight;
                    EventHandler.scaleX = viewBoxWidth / miniatureWidth;
                    EventHandler.scaleY = viewBoxHeight / miniatureHeight;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                    // move to the clicked point
                    var svgPoint = EventHandler.screenToMiniature(event.clientX, event.clientY);
                    Actions.centerModelAt(svgPoint.x, svgPoint.y);
                    NAV.addEventListener('mousemove', EventHandler.whileNavigating, false);
                    NAV.addEventListener('mouseup', EventHandler.completeNavigation, false);
                    SVG.addEventListener('mouseover', EventHandler.completeNavigation, false);
                    DrawingEngine.setCursor('move');
                }
                event.stopPropagation();
            },
            whileNavigating: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileNavigating" ||
                        EventHandler.getInteraction() === "prepareNavigation") {
                    EventHandler.setInteraction("whileNavigating");
                    SVG.viewBox.baseVal.x += (event.clientX - EventHandler.lastX) * EventHandler.scaleX;
                    SVG.viewBox.baseVal.y += (event.clientY - EventHandler.lastY) * EventHandler.scaleY;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                }
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            completeNavigation: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileNavigating" ||
                        EventHandler.getInteraction() === "prepareNavigation") {
                    EventHandler.setInteraction("completeNavigation");
                    EventHandler.clearInteraction();
                    NAV.removeEventListener('mousemove', EventHandler.whileNavigating, false);
                    NAV.removeEventListener('mouseup', EventHandler.completeNavigation, false);
                    SVG.removeEventListener('mouseover', EventHandler.completeNavigation, false);
                    DrawingEngine.setCursor('default');
                }
                event.stopPropagation();
            },
            reduce: function(array, fromArray) {
                var i = array.length, reduced = [];
                while(i--) {
                    if(fromArray.indexOf(array[i]) < 0) {
                        reduced.push(array[i]);
                    }
                }
                return reduced;
            },
            keypress: function(event) {
                event.preventDefault();
                var allComponents = EventHandler.selectedComponents.concat(
                        EventHandler.reduce(
                                EventHandler.interactedComponents,
                                EventHandler.selectedComponents
                        ));
                var component = EventHandler.interactedComponents.pop();
                switch(String.fromCharCode(event.charCode || event.which)) {
                    case "e":
                        component.showContextMenu(component, allComponents);
                        component.contextMenu.toggle();
                        break;
                    case "a":
                        if(Operations.isSupported("addAttribute", allComponents))
                            Model.addAttribute(allComponents);
                        else if(Operations.isSupported("addAnchor", allComponents))
                            Model.addAnchor(allComponents);
                        break;
                    case "t":
                        if(Operations.isSupported("addTie", allComponents) && allComponents.length > 1)
                            Model.addTie(allComponents);
                        else if(Operations.isSupported("addTieAndAnchor", allComponents))
                            Model.addTieAndAnchor(allComponents);
                        break;
                    case "c":
                        if(Operations.isSupported("connect", allComponents)) {
                            var i, operation, validator;
                            for(i = 0; operation = Operations.list[i]; i++)
                                if(operation[0] == "connect")
                                    validator = operation[3];
                            if(validator(allComponents))
                                Model.connect(allComponents);
                        }
                        break;
                    case "h":
                        if(Operations.isSupported("toggleHistorized", allComponents))
                            Model.toggleHistorized(allComponents);
                        break;
                    case "k":
                        if(Operations.isSupported("toggleKnotted", allComponents))
                            Model.toggleKnotted(allComponents);
                        else if(Operations.isSupported("addKnot", allComponents))
                            Model.addKnot(allComponents);
                        break;
                    case "i":
                        if(Operations.isSupported("toggleIdentifier", allComponents))
                            Model.toggleIdentifier(allComponents);
                        break;
                    case "f":
                        if(Operations.isSupported("makeFirstRole", allComponents))
                            Model.makeFirstRole(allComponents);
                        break;
                    case "x":
                        if(Operations.isSupported("explode", allComponents))
                            Model.explode(allComponents);
                        break;
                    case "d":
                        if(Operations.isSupported("erase", allComponents))
                            Model.erase(allComponents);
                        break;
                    case "p":
                        component.setFixed(!component.fixed);
                        DrawingEngine.start(false);
                        break;
                }
                EventHandler.interactedComponents.push(component);
                event.stopPropagation();
            }
        };

        function Symbol(component) {
            this.component = component;
        }
        Symbol.prototype = {
            component: null,
            interactive: null,
            graphicsElement: null,
            useElement: null,
            boundingBox: null,
            xOffset: null,
            yOffset: null,
            control: null,
            nameElement: null,
            nameText: null,
            nameControl: null,
            highlightElement: null,
            selectionElement: null,
            fixationElement: null,
            pathElement: null,
            pathControl: null,
            forceElement: null,
            makeInteractive: function() {
                this.highlightElement = document.createElementNS(SVGNS, 'use');
                this.highlightElement.setAttributeNS(XLINKNS, 'xlink:href', '#highlight');
                this.highlightElement.component = this.component;
                this.selectionElement = document.createElementNS(SVGNS, 'use');
                this.selectionElement.setAttributeNS(XLINKNS, 'xlink:href', '#selection');
                this.selectionElement.component = this.component;
                this.fixationElement = document.createElementNS(SVGNS, 'use');
                this.fixationElement.setAttributeNS(XLINKNS, 'xlink:href', '#fixation');
            },
            addDebug: function(imageLayer) {
                this.forceElement = document.createElementNS(SVGNS, 'line');
                this.forceElement.setAttributeNS(null, 'marker-end', 'url(#arrowhead)');
                imageLayer.appendChild(this.forceElement);
            },
            hideGraphics: function(imageLayer) {
                if(this.graphicsElement && imageLayer.contains(this.graphicsElement))
                    imageLayer.removeChild(this.graphicsElement);
            },
            showGraphics: function(imageLayer) {
                if(this.graphicsElement)
                    imageLayer.appendChild(this.graphicsElement);
            },
            hidePath: function(imageLayer) {
                if(this.pathElement && imageLayer.contains(this.pathElement))
                    imageLayer.removeChild(this.pathElement);
            },
            showPath: function(imageLayer) {
                if(this.pathElement)
                    imageLayer.appendChild(this.pathElement);
            },
            hideName: function(imageLayer) {
                if(this.nameElement && imageLayer.contains(this.nameElement))
                    imageLayer.removeChild(this.nameElement);
            },
            showName: function(imageLayer) {
                if(this.nameElement)
                    imageLayer.appendChild(this.nameElement);
            }
        };

        // "Abstract" type that other components subclass
        function Component(node) {
            this.node = node;
            this.editables = [];
            this.operations = ['erase', 'connect'];
            this.svg = new Symbol(this);
            this.svg.makeInteractive();
            this.svg.addDebug(SVGLayer.debug);
            this.nav = new Symbol(this);
        }
        Component.prototype = {
            node: null,
            description: '',
            editables: null,
            operations: null,
            id: null,
            incomplete: true,
            svg: null,
            nav: null,
            nameable: false,
            hasHighlight: false,
            isSelected: false,
            lastName: null,
            imploded: false,
            // can be overridden by subclasses
            hide: function() {
                this.svg.hideGraphics(SVGLayer.nodes);
                this.nav.hideGraphics(NAVLayer.nodes);
                this.svg.hidePath(SVGLayer.edges);
                this.nav.hidePath(NAVLayer.edges);
                this.svg.hideName(SVGLayer.names);
            },
            show: function() {
                this.svg.showGraphics(SVGLayer.nodes);
                this.nav.showGraphics(NAVLayer.nodes);
                this.svg.showPath(SVGLayer.edges);
                this.nav.showPath(NAVLayer.edges);
                this.svg.showName(SVGLayer.names);
            },
            postCreationInitialization: function() {
                this.editables.push(Editables.descriptionEdit);
            },
            setId: function(id)  {
                if(id) {
                    UniqueIdentity.takeId(id);
                    this.id = id;
                }
            },
            getId: function() {
                if (!this.id)
                    this.id = UniqueIdentity.nextId();
                return this.id;
            },
            setNameable: function(nameable) {
                if(nameable && !this.svg.nameElement) {
                    this.svg.nameElement = document.createElementNS(SVGNS, 'text');
                    this.svg.nameElement.setAttributeNS(null, 'x', 0);
                    this.svg.nameElement.setAttributeNS(null, 'y', 0);
                    this.svg.nameText = document.createTextNode('I am a placeholder');
                    this.svg.nameElement.appendChild(this.svg.nameText);
                    SVGLayer.names.appendChild(this.svg.nameElement);
                    this.svg.nameControl = {
                        x: this.svg.nameElement.x.baseVal.getItem(0),
                        y: this.svg.nameElement.y.baseVal.getItem(0)
                    };
                }
                this.nameable = nameable;
            },
            updateName: function() {
                if(this.nameable) {
                    var name = this.contextualName();
                    if(!name || this.isEmpty(name)) {
                        this.svg.hideName(SVGLayer.names);
                        this.lastName = null;
                    }
                    else if(name !== this.lastName) {
                        if(!this.lastName) this.svg.showName(SVGLayer.names);
                        this.lastName = name;
                        this.svg.nameText.nodeValue = name;
                    }
                }
            },
            // override to change behavior
            isInteractive: function() {
                return false;
            },
            isDraggable: function() {
                return false;
            },
            // this should always return the name according to the naming conventions
            toString: function() {
                return null;
            },
            // this should return the name depending on the visual context
            contextualName: function() {
                return this.toString();
            },
            isEmpty: function(value) {
                return typeof value === "undefined" || value == null ||
                        value.toString().replace(/^[^\S]+/,'').replace(/[^\S]+$/,'') === '';
            },
            updateIncompleteness: function() {
                this.incomplete = false;
                var editable;
                for(var i = 0; editable = this.editables[i]; i++) {
                    // only those that are supposed to contain text (i.e. not checkboxes, select lists, ...)
                    // and is not switched off from editing
                    if(editable.pattern && editable.editable) {
                        if(this.isEmpty(editable.getMember(this)))
                            this.incomplete =  true;
                        if(!editable.getMember(this).toString().match(new RegExp('^' + editable.pattern + '$')))
                            this.incomplete =  true;
                    }
                }
            },
            // override in order to check conditions under which the node breaks the model
            isConforming: function() {
                return true;
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            toSVG: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addDescriptionXML: function(element, schema, description) {
                if(!this.isEmpty(description)) {
                    var descriptionElement = schema.createElement("description");
                    descriptionElement.innerHTML = description;
                    element.appendChild(descriptionElement);
                }
            },
            addLayoutXML: function(element, schema) {
                var node = this.node;
                var layout = schema.createElement("layout");
                layout.setAttribute("x", node.xPosition.toFixed(2));
                layout.setAttribute("y", node.yPosition.toFixed(2));
                layout.setAttribute("fixed", node.fixed);
                if(this.imploded)
                    layout.setAttribute("imploded", this.imploded);
                element.appendChild(layout);
            },
            bad: false,
            end: false,
            drawName: function(x, y) {
                var svg = this.svg;
                if(svg.nameElement) {
                    var node = this.node;
                    this.updateName();
                    var i, xAverage = 0, closestEdge = node.edges[0] || node;
                    i = node.edges.length;
                    while(i--) {
                        xAverage += node.edges[i].xPosition;
                        if(LayoutEngine.manhattanDistance(node, node.edges[i]) <
                                LayoutEngine.manhattanDistance(node, closestEdge)) {
                            closestEdge = node.edges[i];
                        }
                    }
                    xAverage /= node.edges.length;
                    var quarter = svg.yOffset + svg.boundingBox.height / 4;
                    var nameYOffset = svg.yPosition < closestEdge.yPosition ? -quarter : quarter;
                    var nameXOffset = svg.xOffset + svg.boundingBox.width / 2;
                    if(node.xPosition < xAverage) {
                        if(!this.end) {
                            svg.nameElement.classList.add('end');
                        }
                        nameXOffset = -nameXOffset;
                        this.end = true;
                    }
                    else {
                        if(this.end) {
                            svg.nameElement.classList.remove('end');
                        }
                        this.end = false;
                    }
                    if(this.incomplete) {
                        if(!this.bad) {
                            svg.nameElement.classList.add('bad');
                        }
                        this.bad = true;
                    }
                    else {
                        if(this.bad) {
                            svg.nameElement.classList.remove('bad');
                        }
                        this.bad = false;
                    }
                    svg.nameControl.x.value = x + nameXOffset;
                    svg.nameControl.y.value = y + nameYOffset;
                }
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(image) {
                // draw debug stuff
                if(DEBUG) {
                    var node = this.node;
                    var element = this.svg.forceElement;
                    // draw forces
                    element.x1.baseVal.value = node.xPosition;
                    element.y1.baseVal.value = node.yPosition;
                    // exaggerate the velocity so that forces become visible
                    var e = 10*Math.log(1 + 10/(1 + node.velocity));
                    element.x2.baseVal.value = node.xPosition + node.xVelocity *e;
                    element.y2.baseVal.value = node.yPosition + node.yVelocity *e;
                }
            },
            setFixed: function(fixed) {
                this.node.fixed = fixed;
                if(fixed && !this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.appendChild(this.svg.fixationElement);
                }
                else if (!fixed && this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.fixationElement);
                }
            },
            getFixed: function() {
                return this.node.fixed;
            },
            setSelection: function(selected) {
                this.isSelected = selected;
                if(selected && !this.svg.graphicsElement.contains(this.svg.selectionElement)) {
                    this.svg.selectionElement.addEventListener('click', EventHandler.clickSelection, false);
                    this.svg.graphicsElement.insertBefore(
                            this.svg.selectionElement,
                            this.svg.graphicsElement.firstChild
                    );
                }
                else if (!selected && this.svg.graphicsElement.contains(this.svg.selectionElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.selectionElement);
                    this.svg.selectionElement.removeEventListener('click', EventHandler.clickSelection, false);
                }
            },
            setHighlight: function(highlight) {
                this.hasHighlight = highlight;
                if(highlight && !this.svg.graphicsElement.contains(this.svg.highlightElement)) {
                    this.svg.highlightElement.addEventListener('click', EventHandler.clickHighlight, false);
                    this.svg.graphicsElement.insertBefore(
                            this.svg.highlightElement,
                            this.svg.graphicsElement.firstChild
                    );
                    if(!SVGLayer.isShowing('names')) {
                        this.svg.hideName(SVGLayer.names);
                        this.drawName(0, 0);
                        this.svg.showName(this.svg.graphicsElement);
                    }
                }
                else if (!highlight && this.svg.graphicsElement.contains(this.svg.highlightElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.highlightElement);
                    this.svg.highlightElement.removeEventListener('click', EventHandler.clickHighlight, false);
                    this.svg.hideName(this.svg.graphicsElement);
                    this.drawName(this.node.xPosition, this.node.yPosition);
                    this.svg.showName(SVGLayer.names);
                }
            },
            contextMenu: null,
            showContextMenu: function(hoveredComponent, selectedComponents) {
                if(!this.contextMenu)
                    this.contextMenu = new ContextMenu(hoveredComponent, selectedComponents);
            },
            hideContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;
                }
            }
        };

        function Attribute(x, y, historized) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.ATTRIBUTE));
            // set members
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.positIdentityEdit);
            this.editables.push(Editables.positGeneratorEdit);
            this.editables.push(Editables.assertivenessEdit);
            this.editables.push(Editables.checksumEdit);
            this.editables.push(Editables.equivalenceEdit);
            this.knotted = false;
            this.historized = historized;
            this.restatable = Defaults.restatability === 'true';
            this.idempotent = Defaults.idempotency === 'true';
            this.assertive = Defaults.assertiveness === 'true';
            this.equivalent = Defaults.equivalence === 'true';
            this.checksum = false;
            this.encapsulation = Defaults.encapsulation;
            this.positIdentity = Defaults.positIdentity;
            this.positGenerator = Defaults.positGenerator === 'true';
            this.operations.push('toggleKnotted','toggleHistorized');
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            // expando property as a reference back to the underlying component for use in event handlers
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#attribute_historized' : '#attribute';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 5;
            this.svg.yOffset = 2;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Attribute.prototype = {
            mnemonic: '',
            descriptor: '',
            dataRange: '',
            changingRange: '',
            positIdentity: '',
            positGenerator: true,
            historized: false,
            restatable: true,
            idempotent: false,
            assertive: true,
            equivalent: false,
            checksum: false,
            knotted: false,
            encapsulation: Defaults.encapsulation,
            keys: [
                {stop: "1", route: "N", of: "PE"},
                {stop: "3", route: "A", of: "PE"}
            ], // TODO: this is just a test
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            isConforming: function() {
                var i, edge, anchor, otherNode, otherComponent;
                // first find the anchor
                for(i = 0; edge = this.node.edges[i]; i++) {
                    otherNode = (edge.node === this.node ? edge.otherNode : edge.node);
                    if(otherNode.type === NodeType.ANCHOR) {
                        anchor = Model.nodeToComponent(otherNode);
                        break;
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; edge = anchor.node.edges[i]; i++) {
                    otherNode = (edge.node === anchor.node ? edge.otherNode : edge.node);
                    otherComponent = Model.nodeToComponent(otherNode);
                    if(otherNode.type === NodeType.ATTRIBUTE && otherNode !== this.node && otherComponent.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other attributes on the '" + anchor +
                                "' anchor. Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) {
                    this.editables.push(Editables.restatabilityEdit);
                    this.editables.push(Editables.idempotencyEdit);
                }
                else if (!historized && index >= 0)
                    this.editables.splice(index, 2);
                if(this.changingRange === '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#attribute_historized' : '#attribute';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                var index = this.editables.indexOf(Editables.dataRangeEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.dataRangeEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.checksumEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.checksumEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.equivalenceEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.equivalenceEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                if(this.checksum && knotted)
                    this.checksum = false; // knotted cannot be checksummed
                if(this.equivalent && knotted)
                    this.equivalent = false; // knotted cannot be equivalent
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata;
                var capsule = Defaults.encapsulation;
                var restatable = Defaults.restatability === 'true';
                var idempotent = Defaults.idempotency === 'true';
                var assertive = Defaults.assertiveness === 'true';
                var equivalent = Defaults.equivalence === 'true';
                var checksum = false;
                var generator = Defaults.positGenerator === 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    var _restatable = metadata.getAttribute("restatable") || metadata.getAttribute("restatements");
                    restatable = _restatable ? _restatable === 'true' : restatable;
                    var _idempotent = metadata.getAttribute("idempotent");
                    idempotent = _idempotent ? _idempotent === 'true' : idempotent;
                    var _checksum = metadata.getAttribute("checksum");
                    checksum = _checksum ? _checksum === 'true' : checksum;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _assertive = metadata.getAttribute("assertive");
                    assertive = _assertive ? _assertive === 'true' : assertive;
                    var _equivalent = metadata.getAttribute("equivalent");
                    equivalent = _equivalent ? _equivalent === 'true' : equivalent;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || '???';
                var descriptor = element.getAttribute("descriptor") || '!Unnamed!';
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || '';
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || '';
                var parent = element.parentNode;
                var identity = element.getAttribute("identity") || Defaults.positIdentity;
                var attribute = new Attribute(x, y, historized);
                attribute.setFixed(fixed);
                attribute.setKnotted(knotted);
                attribute.setHistorized(historized);
                attribute.changingRange = changingRange;
                attribute.dataRange = dataRange;
                attribute.description = description ? description.firstChild.nodeValue : '';
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                attribute.encapsulation = capsule;
                attribute.restatable = restatable;
                attribute.idempotent = idempotent;
                attribute.assertive = assertive;
                attribute.equivalent = equivalent;
                attribute.checksum = checksum;
                attribute.positIdentity = identity;
                attribute.positGenerator = generator;
                var anchorLookup = Model.getAnchorLookup();
                var knotLookup = Model.getKnotLookup();
                var anchor = anchorLookup[parent.getAttribute("mnemonic")];
                Model.addComponent(new Role(attribute, anchor, true));
                if(knotted) {
                    var grandparent = parent.parentNode;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(i = 0; i < knots.length; i++) {
                        if(knots[i].getAttribute("mnemonic") === knotRange) {
                            var knot = knotLookup[knots[i].getAttribute("mnemonic")];
                            Model.addComponent(new Role(attribute, knot, false));
                            break; // only one should match
                        }
                    }
                }
                attribute.updateName();
                return attribute;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                attribute.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                if(Defaults.temporalization === 'crt')
                    attribute.setAttribute("identity", this.isEmpty(this.positIdentity) ? '' : this.positIdentity);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.node.edges[i]; i++)
                        if(edge.otherNode.type === NodeType.KNOT)
                            knot = Model.nodeToComponent(edge.otherNode);
                    attribute.setAttribute("knotRange", this.isEmpty(knot.mnemonic) ? '' : knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);
                }
                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                if(Defaults.equivalence === 'true') {
                    metadata.setAttribute("equivalent", this.isEmpty(this.equivalent) ? '' : this.equivalent);
                }
                if(Defaults.temporalization === 'crt') {
                    metadata.setAttribute("generator", this.isEmpty(this.positGenerator) ? '' : this.positGenerator);
                    metadata.setAttribute("assertive", this.isEmpty(this.assertive) ? '' : this.assertive);
                }
                if(this.checksum) {
                    metadata.setAttribute("checksum", this.isEmpty(this.checksum) ?
                            false : this.checksum);
                }
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability === 'true' : this.restatable);
                    metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                            Defaults.idempotency === 'true' : this.idempotent);
                }
                attribute.appendChild(metadata);
                this.addLayoutXML(attribute, schema);
                this.addDescriptionXML(attribute, schema, this.description);
                element.appendChild(attribute);
            },
            contextualName: function() {
                var name = '';
                if(Settings.showMnemonics)
                    name += this.toString();
                else
                    name += this.descriptor;
                if(this.historized && (this.restatable || this.idempotent)) {
                    name += ' (';
                    if(this.restatable)
                        name += 'r';
                    if(this.idempotent)
                        name += 'i';
                    if(Defaults.temporalization === 'crt' && this.assertive)
                        name += 'a';
                    name += ')';
                }
                return name;
            },
            toString: function() {
                var anchor, edge;
                for(var i = 0; edge = this.node.edges[i]; i++)
                    if(edge.otherNode.type === NodeType.ANCHOR)
                        anchor = Model.nodeToComponent(edge.otherNode);
                return anchor.mnemonic + "_" + this.mnemonic + "_" + anchor.descriptor + "_" + this.descriptor;
            },
            draw: function(image) {
                /* TODO: later
                if(!this.svg.stops) {
                    this.svg.stops = document.createElementNS(SVGNS, 'g');
                    // expando property as a reference back to the underlying component for use in event handlers
                    this.svg.stops.component = this;
                    var stop, route, of, i, box;
                    // TODO: speed up, clicking, editing, layering, route paths?
                    for(i = 0; i < this.keys.length; i++) {
                        stop = this.keys[i].stop;
                        route = this.keys[i].route;
                        of = this.keys[i].of;
                        var stopElement = document.createElementNS(SVGNS, 'text');
                        stopElement.appendChild(document.createTextNode(stop + route.toLowerCase() + of));
                        stopElement.setAttributeNS(null, 'class', 'stop');
                        stopElement.addEventListener('mouseover', EventHandler.modifyKey, false);
                        this.svg.graphicsElement.appendChild(stopElement);
                        box = stopElement.getBBox();
                        var offset = -20 - (box.height + 3) * i;
                        stopElement.setAttributeNS(null, 'transform', 'translate(0, ' + offset + ')');
                        var stopBox = document.createElementNS(SVGNS, 'rect');
                        stopBox.setAttributeNS(null, 'x', box.x - 3);
                        stopBox.setAttributeNS(null, 'y', box.y - 1);
                        stopBox.setAttributeNS(null, 'rx', 4);
                        stopBox.setAttributeNS(null, 'ry', 4);
                        stopBox.setAttributeNS(null, 'width', box.width + 6);
                        stopBox.setAttributeNS(null, 'height', box.height + 2);
                        stopBox.setAttributeNS(null, 'transform', 'translate(0, ' + offset + ')');
                        stopBox.style.fill = '#d33';
                        this.svg.graphicsElement.insertBefore(stopBox, stopElement);
                    }
                }
                */
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
                if(DEBUG) Component.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Attribute, Component);

        function Anchor(x, y) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.ANCHOR));
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.twoMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.encapsulation = Defaults.encapsulation;
            this.identity = Defaults.identity;
            this.operations.push('addAttribute','addTie','addTieAndAnchor','explode');
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#nav_anchor');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Anchor.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: Defaults.identity,
            generator: true,
            encapsulation: Defaults.encapsulation,
            setImploded: function(imploded) {
                this.imploded = imploded;
                if(imploded) {
                    if(this.operations.indexOf('addAttribute') >= 0)
                        this.operations.splice(this.operations.indexOf('addAttribute'), 1);
                    this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor_imploded');
                }
                else {
                    this.operations.push('addAttribute');
                    this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
                }
            },
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                if(this.imploded)
                    name = "(" + name + ")";
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, component, anchor, anchors = [];
                // first find the anchors
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.ANCHOR) {
                        anchors.push(component);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; anchor = anchors[i]; i++) {
                    if(anchor !== this && anchor.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other anchors in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout, imploded;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                    imploded = layout.getAttribute("imploded");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                imploded = imploded ? imploded === 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = true;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    generator = metadata.getAttribute("generator") ?
                            metadata.getAttribute("generator") === 'true' : generator;
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") ?
                            idElement.getAttribute("generator") === 'true' : generator;
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "??";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var anchor = new Anchor(x, y);
                anchor.setFixed(fixed);
                anchor.setImploded(imploded);
                anchor.description = description ? description.firstChild.nodeValue : '';
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                anchor.generator = generator;
                anchor.encapsulation = capsule;
                anchor.updateName();
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "??" : this.mnemonic);
                anchor.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                anchor.setAttribute("identity", this.isEmpty(this.identity) ? "" : this.identity);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                anchor.appendChild(metadata);

                var edge;
                for(var i = 0; edge = this.node.edges[i]; i++) {
                    if (edge.node.type === NodeType.ATTRIBUTE) {
                        var role = Model.nodeToComponent(edge.node);
                        role.addXML(anchor, schema);
                    }
                }
                this.addLayoutXML(anchor, schema);
                this.addDescriptionXML(anchor, schema, this.description);
                return anchor;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
                if(DEBUG) Component.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Anchor, Component);

        function Knot(x, y) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.KNOT));
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.editables.push(Editables.checksumEdit);
            this.editables.push(Editables.equivalenceEdit);
            this.encapsulation = Defaults.encapsulation;
            this.checksum = false;
            this.equivalent = Defaults.equivalence === 'true';
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#knot');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#nav_knot');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Knot.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: '',
            dataRange: '',
            generator: false,
            checksum: false,
            equivalent: false,
            encapsulation: Defaults.encapsulation,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, component, knot, knots = [];
                // first find the knots
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.KNOT) {
                        knots.push(component);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; knot = knots[i]; i++) {
                    if(knot !== this && knot.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other knots in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = false;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                var checksum = false;
                var equivalent = Defaults.equivalence === 'true';
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _checksum = metadata.getAttribute("checksum");
                    checksum = _checksum ? _checksum === 'true' : checksum;
                    var _equivalent = metadata.getAttribute("equivalent");
                    equivalent = _equivalent ? _equivalent === 'true' : equivalent;
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") ?
                            idElement.getAttribute("generator") === 'true' : generator;
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "???";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var dataRange = element.getAttribute("dataRange") || '';
                var knot = new Knot(x, y);
                knot.setFixed(fixed);
                knot.description = description ? description.firstChild.nodeValue : '';
                knot.mnemonic = mnemonic;
                knot.descriptor = descriptor;
                knot.identity = identity;
                knot.dataRange = dataRange;
                knot.generator = generator;
                knot.equivalent = equivalent;
                knot.encapsulation = capsule;
                knot.checksum = checksum;
                knot.updateName();
                return knot;
            },
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                knot.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                knot.setAttribute("identity", this.isEmpty(this.identity) ? '' : this.identity);
                knot.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                if(this.checksum) {
                    metadata.setAttribute("checksum", this.isEmpty(this.checksum) ?
                            false : this.checksum);
                }
                if(Defaults.equivalence === 'true') {
                    metadata.setAttribute("equivalent", this.isEmpty(this.equivalent) ? '' : this.equivalent);
                }
                knot.appendChild(metadata);

                this.addLayoutXML(knot, schema);
                this.addDescriptionXML(knot, schema, this.description);
                return knot;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
                if(DEBUG) Component.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Knot, Component);

        function Tie(x, y, historized) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.TIE));
            this.historized = historized;
            this.restatable = Defaults.restatability === 'true';
            this.idempotent = Defaults.idempotency === 'true';
            this.assertive = Defaults.assertiveness === 'true';
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.positIdentityEdit);
            this.editables.push(Editables.positGeneratorEdit);
            this.editables.push(Editables.assertivenessEdit);
            this.positIdentity = Defaults.positIdentity;
            this.positGenerator = Defaults.positGenerator === 'true';
            this.operations.push('toggleHistorized','addKnot','addAnchor');
            this.encapsulation = Defaults.encapsulation;
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#tie_historized' : '#tie';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 2;
            this.svg.yOffset = 2;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            this.nav.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + x.toFixed(2) + ',' + y.toFixed(2) + ')');
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.getItem(0);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Tie.prototype = {
            changingRange: Defaults.changingRange,
            historized: false,
            restatable: true,
            idempotent: false,
            assertive: true,
            positIdentity: '',
            positGenerator: true,
            encapsulation: Defaults.encapsulation,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            setFirstRole: function(edge) {
                this.node.edges.splice(this.node.edges.indexOf(edge), 1);
                this.node.edges.splice(0, 0, edge);
            },
            checkIdentifiers: function() {
                if(this.historized) {
                    var outside = 0, inside = 0;
                    for(var i = 0; i < this.node.edges.length; i++) {
                        outside += this.node.edges[i].identifier ? 0 : 1;
                        inside += this.node.edges[i].identifier ? 1 : 0;
                    }
                    if(outside > 1)
                        alert("The tie " + this + " has " + outside +
                                " roles outside the identifier, which is not recommended for a historized tie. " +
                                "In order to determine what changes over time leaving exactly one role outside the " +
                                "identifier is recommended.");
                    else if (outside === 0 && inside > 0)
                        alert("The tie " + this +
                                " has no role outside the identifier, which is not recommended for a historized tie. " +
                                "If you want a many-to-many relationship then gaps in the timeline needs to be " +
                                "modeled explicitly using a knotted tie.");
                }
            },
            isConforming: function() {
                var edge, otherEdge, role, otherRole, component, otherComponent;
                var i, j, identical, relation, related;
                var relations = Object.create(null);
                // check that no roles are identical in the tie
                for(i = 0; edge = this.node.edges[i]; i++) {
                    for(j = 0; otherEdge = this.node.edges[j]; j++) {
                        role = Model.nodeToComponent(edge);
                        otherRole = Model.nodeToComponent(otherEdge);
                        if(i !== j && role.role === otherRole.role) {
                            component = Model.nodeToComponent(
                                            edge.node === this.node ? edge.otherNode : edge.node
                            );
                            otherComponent = Model.nodeToComponent(
                                            otherEdge.node === this.node ? otherEdge.otherNode : otherEdge.node)
                            ;
                            if(component.mnemonic === otherComponent.mnemonic)
                                return !confirm("The roles named '" + role.role + "' for '" +
                                        component + "' cannot be identical in this tie. " +
                                        "Please give the roles different and distinguishing names.");
                        }
                    }
                }
                // build the relations lookup
                for(i = 0; edge = this.node.edges[i]; i++) {
                    related = Model.nodeToComponent(edge.node === this.node ? edge.otherNode : edge.node);
                    role = Model.nodeToComponent(edge);
                    relation = role.role + "_" + related.mnemonic;
                    relations[relation] = true;
                }
                // then find all other ties of the same cardinality
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.TIE && component !== this &&
                            component.node.edges.length === this.node.edges.length) {
                        identical = true;
                        for(j = 0; edge = component.node.edges[j]; j++) {
                            related = Model.nodeToComponent(edge.node === component.node ? edge.otherNode : edge.node);
                            role = Model.nodeToComponent(edge);
                            relation = role.role + "_" + related.mnemonic;
                            identical &= relations[relation];
                            if(relations[relation]) delete relations[relation]; // so that it cannot be matched twice
                        }
                        if(identical) {
                            return !confirm("This tie will become identical to the already existing tie named " +
                                    component + ". Please rename the role.");
                        }
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) {
                    this.editables.push(Editables.restatabilityEdit);
                    this.editables.push(Editables.idempotencyEdit);
                }
                else if (!historized && index >= 0)
                    this.editables.splice(index, 2);
                if(this.changingRange === '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#tie_historized' : '#tie';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata;
                var capsule = Defaults.encapsulation;
                var restatable = Defaults.restatability === 'true';
                var idempotent = Defaults.idempotency === 'true';
                var assertive = Defaults.assertiveness === 'true';
                var generator = Defaults.positGenerator === 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    var _restatable = metadata.getAttribute("restatable") || metadata.getAttribute("restatements");
                    restatable = _restatable ? _restatable === 'true' : restatable;
                    var _idempotent = metadata.getAttribute("idempotent");
                    idempotent = _idempotent ? _idempotent === 'true' : idempotent;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _assertive = metadata.getAttribute("assertive");
                    assertive = _assertive ? _assertive === 'true' : assertive;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var identity = element.getAttribute("identity") || Defaults.positIdentity;
                var tie = new Tie(x, y, historized);
                tie.setFixed(fixed);
                tie.setHistorized(historized);
                tie.changingRange = changingRange;
                tie.encapsulation = capsule;
                tie.restatable = restatable;
                tie.idempotent = idempotent;
                tie.assertive = assertive;
                tie.positIdentity = identity;
                tie.positGenerator = generator;
                tie.description = description ? description.firstChild.nodeValue : '';
                var anchorLookup = Model.getAnchorLookup();
                var knotLookup = Model.getKnotLookup();
                var grandparent = element.parentNode.parentNode;
                var j, d, type, role, roleName, identifier, coloring, anchor;
                var anchorRoles = element.getElementsByTagName("anchorRole");
                for(i = 0; i < anchorRoles.length; i++) {
                    type = anchorRoles[i].getAttribute("type") || "??";
                    roleName = anchorRoles[i].getAttribute("role");
                    if(!roleName || roleName.match(/![^role].*!/)) roleName = "!role" + UniqueIdentity.nextId() + "!";
                    identifier = anchorRoles[i].getAttribute("identifier") || false;
                    coloring = anchorRoles[i].getAttribute("coloring") || "#000000";
                    for(d = 0; d < anchorRoles[i].childNodes.length; d++)
                        if(anchorRoles[i].childNodes.item(d).nodeName === 'description')
                            description = anchorRoles[i].childNodes.item(d);
                    var anchors = grandparent.getElementsByTagName("anchor");
                    for(j = 0; j < anchors.length; j++) {
                        if(anchors[j].getAttribute("mnemonic") === type) {
                            anchor = anchorLookup[anchors[j].getAttribute("mnemonic")];
                            role = new Role(tie, anchor, (identifier === "true"));
                            role.role = roleName;
                            role.setColoring(coloring);
                            role.description = description ? description.firstChild.nodeValue : '';
                            Model.addComponent(role);
                            role.updateName();
                            break; // only one should match
                        }
                    }
                }
                var knot, knotRoles = element.getElementsByTagName("knotRole");
                for(i = 0; i < knotRoles.length; i++) {
                    type = knotRoles[i].getAttribute("type") || "???";
                    roleName = knotRoles[i].getAttribute("role");
                    if(!roleName || roleName.match(/![^role].*!/)) roleName = "!role" + UniqueIdentity.nextId() + "!";
                    identifier = knotRoles[i].getAttribute("identifier") || false;
                    coloring = knotRoles[i].getAttribute("coloring") || "#000000";
                    for(d = 0; d < knotRoles[i].childNodes.length; d++)
                        if(knotRoles[i].childNodes.item(d).nodeName === 'description')
                            description = knotRoles[i].childNodes.item(d);
                    var knots = grandparent.getElementsByTagName("knot");
                    for(j = 0; j < knots.length; j++) {
                        if(knots[j].getAttribute("mnemonic") === type) {
                            knot = knotLookup[knots[j].getAttribute("mnemonic")];
                            role = new Role(tie, knot, (identifier === "true"));
                            role.role = roleName;
                            role.setColoring(coloring);
                            role.description = description ? description.firstChild.nodeValue : '';
                            Model.addComponent(role);
                            role.updateName();
                            break; // only one should match
                        }
                    }
                }
                tie.updateName();
                return tie;
            },
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                if(Defaults.temporalization === 'crt')
                    tie.setAttribute("identity", this.isEmpty(this.positIdentity) ? '' : this.positIdentity);
                if(this.historized)
                    tie.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);
                var edges = this.node.edges;
                for(var i = 0; i < edges.length; i++) {
                    var roleElement;
                    var node = edges[i].otherNode;
                    var role = Model.nodeToComponent(edges[i]);
                    var component = Model.nodeToComponent(edges[i].otherNode);
                    if(edges[i].otherNode.type === NodeType.ANCHOR)
                        roleElement = schema.createElement("anchorRole");
                    else if(edges[i].otherNode.type === NodeType.KNOT)
                        roleElement = schema.createElement("knotRole");
                    roleElement.setAttribute("role", this.isEmpty(role.role) ? "!role" + UniqueIdentity.nextId() + "!" : role.role);
                    roleElement.setAttribute("type", this.isEmpty(component.mnemonic) ? "???" : component.mnemonic);
                    if(role.coloring !== '#000000')
                        roleElement.setAttribute("coloring", role.coloring);
                    roleElement.setAttribute("identifier",
                            this.isEmpty(component.identifier) ? false : component.identifier);
                    this.addDescriptionXML(roleElement, schema, component.description);
                    tie.appendChild(roleElement);
                }

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.encapsulation);
                if(Defaults.temporalization === 'crt') {
                    metadata.setAttribute("generator", this.isEmpty(this.positGenerator) ? '' : this.positGenerator);
                    metadata.setAttribute("assertive", this.isEmpty(this.assertive) ? '' : this.assertive);
                }
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability === 'true' : this.restatable);
                    metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                            Defaults.idempotency === 'true' : this.idempotent);
                }
                tie.appendChild(metadata);

                this.addLayoutXML(tie, schema);
                this.addDescriptionXML(tie, schema, this.description);
                return tie;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics) {
                    name = this.toString();
                    if(this.historized && (this.restatable || this.idempotent)) {
                        name += ' (';
                        if(this.restatable)
                            name += 'r';
                        if(this.idempotent)
                            name += 'i';
                        if(Defaults.temporalization === 'crt' && this.assertive)
                            name += 'a';
                        name += ')';
                    }
                }
                else
                    name = '';
                return name;
            },
            toString: function() {
                var i, edge, component, role, name="";
                for(i = 0; edge = this.node.edges[i]; i++) {
                    if(i > 0)
                        name += "_";
                    component = Model.nodeToComponent(edge.otherNode);
                    role = Model.nodeToComponent(edge);
                    name += component.mnemonic + "_" + role.role;
                }
                return name;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
                if(DEBUG) Component.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Tie, Component);

        function Role(component, otherComponent, identifier) {
            this.id = UniqueIdentity.nextId();
            var node = component.node;
            var otherNode = otherComponent.node;
            // call the parent constructor
            Component.call(this, new Edge(this.id, node, otherNode));
            var controlPoint = this.node.controlPoint;
            this.role = '?' + this.id;
            this.component = component;
            this.otherComponent = otherComponent;
            this.identifier = identifier;
            this.editables.push(Editables.roleEdit, Editables.coloringEdit);
            this.operations.push('toggleIdentifier', 'makeFirstRole');
            this.tied = node.type === NodeType.TIE || otherNode.type === NodeType.TIE;
            // SVG
            this.svg.pathElement = document.createElementNS(SVGNS, 'path');
            this.setColoring(this.coloring);
            this.svg.pathElement.setAttributeNS(null, 'd', 'M' + node.xPosition.toFixed(2) + ',' + node.yPosition.toFixed(2) +
                    ' Q' + controlPoint.xPosition.toFixed(2) + ',' + controlPoint.yPosition.toFixed(2) +
                    ' ' + otherNode.xPosition.toFixed(2) + ',' + otherNode.yPosition.toFixed(2));
            this.svg.pathControl = {
                m: this.svg.pathElement.pathSegList.getItem(0),
                q: this.svg.pathElement.pathSegList.getItem(1)
            };
            SVGLayer.edges.appendChild(this.svg.pathElement);
            if(this.tied) {
                this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
                this.svg.graphicsElement.component = this;
                var bubble = document.createElementNS(SVGNS, 'use');
                bubble.setAttributeNS(XLINKNS, 'xlink:href', '#bubble');
                this.svg.graphicsElement.appendChild(bubble);
                this.svg.useElement = document.createElementNS(SVGNS, 'use');
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', this.identifier ? '#many' : '#one');
                this.svg.graphicsElement.appendChild(this.svg.useElement);
                this.svg.graphicsElement.setAttributeNS(null, 'transform', 'translate(' + controlPoint.xPosition + ',' + controlPoint.yPosition + ')');
                this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
                SVGLayer.edges.appendChild(this.svg.graphicsElement);
                this.svg.control = this.svg.graphicsElement.transform.baseVal.getItem(0);
                this.svg.boundingBox = this.svg.graphicsElement.getBBox();
                this.svg.xOffset = 2;
                this.svg.yOffset = 2;
                this.setNameable(true);
                this.svg.nameElement.setAttributeNS(null, 'class', 'role');
            }
            // NAV
            this.nav.pathElement = document.createElementNS(SVGNS, 'path');
            this.nav.pathElement.setAttributeNS(null, 'd', 'M' + node.xPosition.toFixed(2) + ',' + node.yPosition.toFixed(2) +
                    ' Q' + controlPoint.xPosition.toFixed(2) + ',' + controlPoint.yPosition.toFixed(2) +
                    ' ' + otherNode.xPosition.toFixed(2) + ',' + otherNode.yPosition.toFixed(2));
            this.nav.pathControl = {
                m: this.nav.pathElement.pathSegList.getItem(0),
                q: this.nav.pathElement.pathSegList.getItem(1)
            };
            NAVLayer.edges.appendChild(this.nav.pathElement);
            this.postCreationInitialization();
        }
        Role.prototype = {
            role: '',
            component: null,
            otherComponent: null,
            controlPoint: null,
            identifier: true,
            coloring: '#000000',
            tied: false,
            hide: function() {
                this.svg.hideGraphics(SVGLayer.edges);
                this.nav.hideGraphics(NAVLayer.edges);
                Component.prototype.hide.apply(this, arguments);
            },
            show: function() {
                this.svg.showGraphics(SVGLayer.edges);
                this.nav.showGraphics(NAVLayer.edges);
                Component.prototype.show.apply(this, arguments);
            },
            setIdentifier: function(identifier) {
                this.identifier = identifier;
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', this.identifier ? '#many' : '#one');
            },
            setColoring: function(coloring) {
                this.coloring = coloring;
                if(coloring === '#000' || coloring === '#000000') {
                    this.svg.pathElement.style.stroke = null;
                    this.svg.pathElement.style.strokeWidth = null;
                }
                else {
                    this.svg.pathElement.style.stroke = this.coloring;
                    this.svg.pathElement.style.strokeWidth = '10px';
                }
            },
            isInteractive: function() {
                return this.tied;
            },
            isDraggable: function() {
                return false;
            },
            // edges never fixate
            setFixed: function(fixed) {
                this.fixed = false;
            },
            contextualName: function() {
                return this.toString();
            },
            toString: function() {
                return this.role;
            },
            draw: function(image) {
                var node = this.node.node;
                var otherNode = this.node.otherNode;
                var controlPoint = this.node.controlPoint;
                var role = this.node;
                image.pathControl.m.x = node.xPosition;
                image.pathControl.m.y = node.yPosition;
                image.pathControl.q.x1 = controlPoint.xPosition;
                image.pathControl.q.y1 = controlPoint.yPosition;
                image.pathControl.q.x = otherNode.xPosition;
                image.pathControl.q.y = otherNode.yPosition;
                if(this.tied && image.control) {
                    // experimenting with cardinality placement
//                    var l = image.pathElement.getTotalLength();
//                    var p = image.pathElement.getPointAtLength(l/4);
//                    image.control.setTranslate(p.x, p.y);
                    image.control.setTranslate(role.xPosition, role.yPosition);
                }
                if(DEBUG) Component.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Role, Component);

        var DataTypeConverter = {
            MATCH: 0,
            REPLACE: 1,
            SQLServer_to_Oracle: [
                // exact numbers
                [/"tinyint"/ig,                         '"NUMBER(3)"'],
                [/"smallint"/ig,                        '"NUMBER(5)"'],
                [/"int"|"integer"/ig,                   '"NUMBER(10)"'],
                [/"bigint"/ig,                          '"NUMBER(19)"'],
                [/"decimal\(([0-9]+),\s*([0-9]+)\)"/ig, '"NUMBER($1,$2)"'],
                [/"numeric\(([0-9]+),\s*([0-9]+)\)"/ig, '"NUMBER($1,$2)"'],
                [/"smallmoney"/ig,                      '"NUMBER(10,4)"'],
                [/"money"/ig,                           '"NUMBER(19,4)"'],
                // approximate numbers
                [/"real"/ig,                            '"BINARY_FLOAT"'],
                [/"float"/ig,                           '"BINARY_DOUBLE"'],
                // time types
                [/"smalldatetime"/ig,                   '"TIMESTAMP(3)"'],
                [/"datetime"/ig,                        '"TIMESTAMP(3)"'],
                [/"datetime2\(([0-9]+)\)"/ig,           '"TIMESTAMP($1)"'],
                [/"datetimeoffset\(([0-9]+)\)"/ig,      '"TIMESTAMP($1) WITH TIME ZONE"'],
                // strings
                [/"varchar\(([0-9]+)\)"/ig,             '"VARCHAR2($1)"'],
                [/"varchar\(max\)"/ig,                  '"CLOB"'],
                [/"text"/ig,                            '"LONG"'],
                // binaries
                [/"binary\(([0-9]+)\)"/ig,              '"RAW($1)"'],
                [/"varbinary\(([0-9]+)\)"/ig,           '"LONG RAW"'],
                [/"varbinary\(max\)"/ig,                '"BLOB"'],
                [/"image"/ig,                           '"LONG RAW"'],
                // other
                [/"xml"/ig,                             '"XMLTYPE"'],
                [/"bit"/ig,                             '"NUMBER(1)"'],
                [/"uniqueidentifier"/ig,                '"RAW(16)"']
            ],
            convert: function(xml, source, target) {
                var ruleset = this[source + '_to_' + target];
                if(!ruleset) {
                    alert('Conversion between ' + source + ' and ' + target + ' is not supported.');
                    return xml;
                }
                var str = (new XMLSerializer()).serializeToString(xml);
                var rule;
                for(var i = 0; rule = ruleset[i]; i++) {
                    str = str.replace(rule[this.MATCH], rule[this.REPLACE]);
                }
                xml = (new DOMParser()).parseFromString(str, 'text/xml');
                return xml;
            }
        };

        function ModalBackground(message) {
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;
            if(message) {
                var text = document.createTextNode(message);
                modalBackground.appendChild(text);
            }
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
            }
        };

        function URLPopover(url) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "urlPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('iframe');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.src = url;

            popover.appendChild(content);
            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        URLPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CodePopover(documentFragment, preformatted) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "codePopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.setAttribute("contenteditable", "true");
            content.setAttribute("spellcheck", "false");
            if(preformatted)
                content.setAttribute("class", "preformatted");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.appendChild(documentFragment);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CodePopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CloudBrowserPopover(scope) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudBrowserPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var filter = document.createElement('div');
            filter.setAttribute("id", "keywordFilter");
            filter.appendChild(document.createTextNode('Keyword: '));
            var keywords = document.createElement('input');
            keywords.setAttribute('type', 'text');
            keywords.addEventListener('change', function() { self.keywordFilter = this.value; }, false);
            filter.appendChild(keywords);
            var searchButton = document.createElement('input');
            searchButton.setAttribute('type', 'button');
            searchButton.value = 'Search';
            searchButton.addEventListener('click', function(e) {
                self.generateList();
            }, false);
            this.searchButton=searchButton;
            filter.appendChild(searchButton);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';

            this.listContainer=content;
            this.scope=scope;
            this.generateList();

            popover.appendChild(filter);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudBrowserPopover.prototype = {
            popover: null,
            modalBackground: null,
            listContainer:null,
            searchButton:null,
            scope:'',
            keywordFilter:'',
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            },
            generateList : function() {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var self = this;
                var xmlhttp = new window.XMLHttpRequest();
                this.searchButton.disabled=true;
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var modelList = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        self.fillFromList(modelList);
                    }
				};
                var params = {};
                params.action = 'list';
                params.maxItemsReturned = '100';
                params.scope = this.scope;
                if(self.keywordFilter!=='') {
                    params.filterBy='keywords';
                    params.filterValue=self.keywordFilter;
                }
                Actions.cloudWrapper(xmlhttp, params);
            },
            fillFromList : function(modelList) {
                var self = this;
                var models = modelList.getElementsByTagName('Model');
                var model, modelContainer;
                while (this.listContainer.hasChildNodes())
                    this.listContainer.removeChild(this.listContainer.firstChild);
                for(var i = 0; i < models.length; i++) {
                    model = models.item(i);
                    modelContainer = document.createElement('div');
                    modelContainer.setAttribute("class", "modelContainer");
                    modelContainer.modelId = model.getAttribute("modelId");
                    modelContainer.modelName = model.getAttribute("modelName");
                    modelContainer.modelScope = model.getAttribute("scope") || "private";
                    modelContainer.modelKeywords = model.getAttribute("keywords");
                    modelContainer.modelDescription = unescape(model.getAttribute("description"));
                    modelContainer.lastLoaded = model.getAttribute("lastLoaded");
                    modelContainer.loadedCount = model.getAttribute("loadedCount");
                    modelContainer.url = window.location.protocol + '//' +
                            window.location.hostname + window.location.pathname + "?id=" + modelContainer.modelId;
                    modelContainer.addEventListener('click', function(e) {
                        Actions.loadModelFromCloud(
                                this.modelId,
                                this.modelName,
                                this.modelScope,
                                this.modelKeywords,
                                this.modelDescription
                        );
                        self.close(e);
                    }, false);

                    //modelContainer.setAttribute("id","codePopover");
                    if(LOGGED_IN && (USER_ID===model.getAttribute("userId"))) {
                        var deleteButton = document.createElement('div');
                        deleteButton.className = 'modelDeleteButton';
                        deleteButton.setAttribute(
                                "style",
                                "border-style: hidden; display: block; margin: 0px 0px -28px; padding: 0;"
                        );
                        deleteButton.modelId = modelContainer.modelId;
                        deleteButton.modelName = modelContainer.modelName;
                        deleteButton.modelContainer = modelContainer;
                        deleteButton.addEventListener('click', function(event) {
                            //Disable click for modelcontainer
                            if (event.stopPropagation)
                                event.stopPropagation();
                            else if(window.event)
                               window.event.cancelBubble=true;
                            if(confirm("Are you sure you want to delete this model:?\n" + this.modelName)) {
                                Actions.deleteModelFromCloud(this.modelId);
                                self.listContainer.removeChild(this.modelContainer);
                            }
                        }, false);
                        modelContainer.appendChild(deleteButton);
                    }
                    var icon = document.createElement('img');
                    icon.setAttribute("src", model.getAttribute("icon"));
                    icon.setAttribute("class", "modelIcon");
                    var name = document.createElement("div");
                    name.appendChild(document.createTextNode(model.getAttribute("modelName") + " "));
                    name.className = 'modelName';
                    var keywords = document.createElement("div");
                    keywords.className = 'modelKeywords';
                    keywords.appendChild(document.createTextNode(model.getAttribute("keywords")));
                    var description = document.createElement("div");
                    description.className = 'modelDescription';
                    description.appendChild(document.createTextNode(modelContainer.modelDescription));
                    modelContainer.appendChild(icon);
                    modelContainer.appendChild(name);
                    modelContainer.appendChild(keywords);
                    modelContainer.appendChild(description);
                    if(modelContainer.modelScope === 'public') {
                        var twitter = document.createElement('div');
                        var tweet = document.createElement("a");
                        var externalLink = document.createElement("img");
                        externalLink.setAttribute("src", "externalLink.png");
                        externalLink.setAttribute("class", "externalLink");
                        var params = [];
                        params.push("url=" + modelContainer.url);
                        params.push("via=anchormodeling");
                        params.push("text=" + modelContainer.modelName);
                        params.push("lang=en");
                        params.push("count=vertical");
                        tweet.setAttribute("href", "https://twitter.com/share?" + params.join('&'));
                        tweet.setAttribute("class", "tweet");
                        tweet.setAttribute("target", "_blank");
                        tweet.appendChild(document.createTextNode("tweet this model"));
                        twitter.setAttribute("class", "twitter");
                        twitter.appendChild(tweet);
                        twitter.appendChild(externalLink);
                        modelContainer.appendChild(twitter);
                    }
                    modelContainer.title = modelContainer.modelName +
                            ' - ' + modelContainer.loadedCount + ' views, last on ' + modelContainer.lastLoaded;
                    this.listContainer.appendChild(modelContainer);
                }
				self.searchButton.disabled=false;
            }
        };

        function CloudSaverPopover() {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudSaverPopover");
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");

            var icon = document.createElement('img');
            icon.setAttribute('src', Actions.toPNGDataURL(NAV));
            content.appendChild(icon);

            var table = document.createElement('table');
            var tr = document.createElement('tr');
            var td = document.createElement('td');
            td.appendChild(document.createTextNode('Model name: '));
            tr.appendChild(td);
            td = document.createElement('td');
            var modelName = document.createElement('input');
            modelName.setAttribute('type', 'text');
            if(Model.name && Model.name !== null)
                modelName.value = Model.name;
            modelName.addEventListener('change', function() { Model.name = this.value; }, false);
            td.appendChild(modelName);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelScope = document.createElement('select');
            var privateOption = document.createElement('option');
            privateOption.setAttribute('value', 'private');
            privateOption.appendChild(document.createTextNode('Private'));
            modelScope.appendChild(privateOption);
            var publicOption = document.createElement('option');
            publicOption.setAttribute('value', 'public');
            publicOption.appendChild(document.createTextNode('Public'));
            modelScope.appendChild(publicOption);
            if(Model.scope && Model.scope !== null)
                modelScope.value = Model.scope;
            modelScope.addEventListener('change', function() { Model.scope = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Scope: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelScope);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelKeywords = document.createElement('input');
            modelKeywords.setAttribute('type', 'text');
            modelKeywords.setAttribute('placeholder', 'keywords separated with spaces');
            if(Model.keywords && Model.keywords !== null)
                modelKeywords.value = Model.keywords;
            modelKeywords.addEventListener('change', function() { Model.keywords = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Keywords: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelKeywords);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelDesc = document.createElement('textarea');
            modelDesc.setAttribute('rows', '4');
            modelDesc.setAttribute('cols', '40');
            if(Model.description && Model.description !== null)
                modelDesc.value = Model.description;
            modelDesc.addEventListener('change', function() { Model.description = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Description: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelDesc);
            tr.appendChild(td);
            table.appendChild(tr);

            content.appendChild(table);

            if(Model.id) {
                var overwriteButton = document.createElement('input');
                overwriteButton.setAttribute('type', 'button');
                overwriteButton.className = 'overwriteButton';
                overwriteButton.value = 'Overwrite';
                overwriteButton.addEventListener('click', function(e) {
                    Actions.saveModelInCloud(false);
                    self.close(e);
                }, false);
                content.appendChild(overwriteButton);
            }
            var saveButton = document.createElement('input');
            saveButton.setAttribute('type', 'button');
            saveButton.className = 'saveButton';
            saveButton.value = 'Save New';
            saveButton.addEventListener('click', function(e) {
                Model.id = null;
                Actions.saveModelInCloud(false);
                self.close(e);
            }, false);
            content.appendChild(saveButton);

            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudSaverPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        var Operations = {
            // operations are defined as 'method', 'display name', 'description', 'optional rule'
            list: [
                ['erase',
                    'Delete selected...',
                    'Deletes the selected item(s) from the model.'],
                ['toggleKnotted',
                    'Toggle knotted',
                    'Adds or removes a knot from the selected attribute(s).'], // TODO: only remove knot if it is the last attribute
                ['toggleHistorized',
                    'Toggle historized',
                    'Historized items can store versions of values over changing time and are marked by a double outline in the model.'],
                ['addAttribute',
                    'Add attribute',
                    'Add an attribute to the selected anchor(s).'],
                ['addTie',
                    'Add tie',
                    'Add a tie between the selected anchors.'],
                ['addAnchor',
                    'Add anchor',
                    'Add an anchor to the selected tie(s).'],
                ['addKnot',
                    'Add knot',
                    'Add a knot to the selected tie(s).'],
                ['addTieAndAnchor',
                    'Add tied anchor',
                    'Add a tie with a connected anchor to the selected anchor(s).'],
                ['toggleIdentifier',
                    'Toggle identifier',
                    'Toggles whether the selected role(s) should be a part of the primary key or not.'],
                ['makeFirstRole',
                    'Make first role',
                    'Make the selected role(s) the first role in the primary key and tie name.'],
                ['connect',
                    'Connect',
                    'Connect the selected node(s).',
                    function(allComponents) {
                        if(allComponents.length !== 2)
                            return false;
                        var component, anchors = 0, ties = 0, knots = 0, knotted, attributes = 0;
                        for(var i = 0; component = allComponents[i]; i++) {
                            if(component.node.type === NodeType.ANCHOR)
                                anchors++;
                            else if(component.node.type === NodeType.TIE)
                                ties++;
                            else if(component.node.type === NodeType.KNOT)
                                knots++;
                            else if(component.node.type === NodeType.ATTRIBUTE) {
                                attributes++;
                                knotted = component.getKnotted();
                            }
                        }
                        return anchors && ties || knots && ties || attributes && knots && !knotted;
                    }],
                ['explode',
                    'Explode/Implode',
                    'Change the level of detail for the selected item(s) in the model.']
            ],
            isSupported: function(operation, components) {
                for(var i = 0; i < components.length; i++)
                    if(components[i].operations.indexOf(operation) < 0)
                        return false;
                return true;
            }
        };

        function ContextMenu(hoveredComponent, selectedComponents) {
            var self = this;

            this.hoveredComponent = hoveredComponent;
            this.selectedComponents = selectedComponents;
            var contextMenu = document.createElement('div');
            contextMenu.setAttribute('id', 'contextMenu');
            this.toggler = document.createElement('div');
            this.toggler.setAttribute('class', 'toggler collapsed');
            this.toggler.setAttribute('title', 'Click to open the context menu.');
            this.toggler.addEventListener('click', function(event) { self.toggle(); }, false);
            contextMenu.appendChild(this.toggler);
            this.contextMenu = contextMenu;

            this.topper = document.createElement('div');
            this.topper.setAttribute('class', 'topper unselectable');
            this.topper.addEventListener('mousedown', function(event) { self.mousedown(event); }, false);

            var editable;
            this.editsHaveBeenMade = false;
            this.editables = document.createElement('table');
            this.editables.setAttribute('class', 'items');
            this.showEditables = false;

            var i, j, tr;
            // if we are operating a single node, show its editable fields
            if(selectedComponents.length === 0 || (selectedComponents.length === 1 && selectedComponents[0] === hoveredComponent)) {
                this.topper.appendChild(document.createTextNode("Edit " + NodeType[hoveredComponent.node.type]));
                for(i = 0; editable = hoveredComponent.editables[i]; i++) {
                    if(editable.editable) {
                        this.showEditables = true;
                        var element = document.createElement(editable.type);
                        element.className = 'editable';
                        if(editable.pattern)
                            element.setAttribute('pattern', editable.pattern);
                        for(j = 0; j < editable.attributes.length;) {
                            var attribute = editable.attributes[j++];
                            var value = editable.attributes[j++];
                            element.setAttribute(attribute, value);
                        }
                        editable.setElement(element, hoveredComponent);
                        element.editable = editable;
                        element.addEventListener(editable.event, function() { self.edit(this, hoveredComponent); }, false);
                        element.addEventListener('change', function() { self.editsHaveBeenMade = true; }, false);
                        this.keypress = this.keypress.bind(this);
                        element.addEventListener('keypress', this.keypress, false);
                        tr = document.createElement('tr');
                        tr.setAttribute('valign', 'top');
                        tr.setAttribute('title', editable.description);
                        var td1 = document.createElement('td');
                        td1.appendChild(document.createTextNode(editable.name + ":"));
                        tr.appendChild(td1);
                        var td2 = document.createElement('td');
                        td2.appendChild(element);
                        tr.appendChild(td2);
                        this.editables.appendChild(tr);
                    }
                }
            }
            else {
                this.topper.appendChild(document.createTextNode("Edit selection"));
            }

            var supportedOperations = [];

            var allComponents = selectedComponents.slice(0);
            if(allComponents.indexOf(hoveredComponent) < 0)
                allComponents.push(hoveredComponent);

            var validator;
            for(i = 0; i < Operations.list.length; i++) {
                if(Operations.isSupported(Operations.list[i][0], allComponents)) {
                    if(validator = Operations.list[i][3]) {
                        if(validator(allComponents))
                            supportedOperations.push(Operations.list[i]);
                    }
                    else
                        supportedOperations.push(Operations.list[i]);
                }
            }

            this.operators = document.createElement('fieldset');
            this.operators.setAttribute('class', 'operators');
            var operations = document.createElement('legend');
            operations.setAttribute(
                    'title',
                    'Context sensitive list of operations that can be performed ' +
                    'on the selected item(s). Shift+click in order to select ' +
                    'multiple items in the model graph.'
            );
            operations.appendChild(document.createTextNode('OPERATIONS'));
            this.operators.appendChild(operations);
            for(i = 0; i < supportedOperations.length; i++) {
                var operator = document.createElement('div');
                operator.setAttribute('class', 'operator');
                operator.setAttribute('title', supportedOperations[i][2]);
                operator.appendChild(document.createTextNode(supportedOperations[i][1]));
                operator.method = supportedOperations[i][0];
                operator.addEventListener('click', function() { self.operate(this, allComponents); }, false);
                this.operators.appendChild(operator);
            }

            this.updatePosition();
            document.body.appendChild(this.contextMenu);
            return this;
        }
        ContextMenu.prototype = {
            contextMenu: null,
            hoveredComponent: null,
            selectedComponents: null,
            showEditables: false,
            editables: null,
            operators: null,
            divider: null,
            topper: null,
            toggler: null,
            collapsed: true,
            modalBackground: null,
            editsHaveBeenMade: false,
            dragging: false,
            operate: function(button, components) {
                Model[button.method](components);
            },
            edit: function(element, component) {
                if(element && component) {
                    element.editable.setMember(element, component);
                    element.checkValidity();
                }
            },
            mousedown: function(event) {
                this.mousemove = this.mousemove.bind(this);
                this.mouseup = this.mouseup.bind(this);
                window.addEventListener('mousemove', this.mousemove, false);
                window.addEventListener('mouseup', this.mouseup, false);
                this.dragging = true;
            },
            mousemove: function(event) {
                if(this.dragging) {
                    var xScreen, yScreen;
                    xScreen = event.clientX
                            - this.contextMenu.offsetWidth / 2;
                    yScreen = event.clientY
                            - this.topper.offsetHeight / 2;
                    this.updatePosition(xScreen, yScreen);
                }
            },
            mouseup: function(event) {
                this.dragging = false;
                window.removeEventListener('mousemove', this.mousemove, false);
                window.removeEventListener('mouseup', this.mouseup, false);
            },
            updatePosition: function(x, y) {
                var point = EventHandler.svgToScreen(
                        this.hoveredComponent.node.xPosition + 15, // inside the highlight ring with radius 30
                        this.hoveredComponent.node.yPosition + 15
                );
                x = x ? x : point.x;
                y = y ? y : point.y;
                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
            },
            keypress: function(event) {
                if(event.keyCode === 13) {
                    event.srcElement.blur();
                    if(Model.isConforming())
                        this.close();
                }
            },
            toggle: function() {
                var self = this;
                if(this.collapsed) {
                    this.toggler.className = 'toggler expanded';
                    this.toggler.setAttribute('title', 'Click to close the context menu.');
                    this.collapsed = false;
                    this.modalBackground = new ModalBackground();
                    this.contextMenu.appendChild(this.topper);
                    if(this.showEditables) {
                        this.contextMenu.appendChild(this.editables);
                        var editables = this.editables.getElementsByClassName('editable');
                        if(editables.length > 0)
                            editables[0].focus();
                    }
                    window.removeEventListener('keypress', EventHandler.keypress, false);
                    this.contextMenu.appendChild(this.operators);
                }
                else {
                    if(this.editsHaveBeenMade && !Model.isConforming())
                        return;
                    this.toggler.className = 'toggler collapsed';
                    this.toggler.setAttribute('title', 'Click to open the context menu.');
                    this.collapsed = true;
                    this.contextMenu.removeChild(this.operators);
                    if(this.showEditables) {
                        this.contextMenu.removeChild(this.editables);
                    }
                    this.contextMenu.removeChild(this.topper);
                    this.unmodal();
                    window.addEventListener('keypress', EventHandler.keypress, false);
                    DrawingEngine.start(false);
                }
            },
            unmodal: function() {
                if(this.modalBackground) {
                    this.modalBackground.close();
                    this.modalBackground = null;
                }
            },
            close: function() {
                this.unmodal();
                if(this.editsHaveBeenMade)
                    Model.recordState();
                if(document.body.contains(this.contextMenu))
                    document.body.removeChild(this.contextMenu);
                window.addEventListener('keypress', EventHandler.keypress, false);
                DrawingEngine.start(false);
            }
        };

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                this.reader = new FileReader();
                this.reader.onload = function(e) { FileHandler.fileLoaded(e); };
                this.reader.onerror = function(e) {
                    if(console && console.error)
                        console.error("File could not be read! Code " + event.target.error.code);
                };
                this.reader.readAsText(files[0]);
            },
            replaceInput: function(parent, input) {
                var newInput = document.createElement('input');
                newInput.className = 'fileSelect';
                newInput.setAttribute('type', 'file');
                newInput.addEventListener('change', function() {
                    FileHandler.handleFiles(this.files);
                    FileHandler.replaceInput(this.parentNode, this);
                }, false);
                parent.replaceChild(newInput, input);
            },
            fileLoaded: function(event) {
                var xml;
                try {
                    var parser = new DOMParser();
                    xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                }
                Model.uncloud();
                Model.clearStates();
                Model.fromXML(xml);
                Actions.setModelStatus();
                Actions.resetZoom();
                Actions.centerModel();
                DrawingEngine.taint();
                DrawingEngine.start(false);
            }
        };

        var Actions = {
            startKeyboardEvents: function() {
                window.addEventListener('keypress', EventHandler.keypress, false);
            },
            stopKeyboardEvents: function() {
                window.removeEventListener('keypress', EventHandler.keypress, false);
            },
            populateSelector: function(selector, searchString) {
                this.startKeyboardEvents();
                var node, component;
                var selected = selector.value;
                while(selector.options.length > 0)
                    selector.options.remove(0);
                selector.options.add(new Option("None selected", "none"));
                var components = Model.components.slice();
                components.sort(
                    function(a, b) {
                        var nameA = a.encapsulation + '.' + a.toString();
                        var nameB = b.encapsulation + '.' + b.toString();
                        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
                    }
                );
                for(var i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(component.toString() && node.type !== NodeType.EDGE) {
                        var fullName = component.encapsulation + '.' + component.toString();
                        if(component.incomplete)
                            fullName = "* " + fullName;
                        var option = new Option(fullName, component.id);
                        if(searchString && searchString.trim() !== '') {
                            if(fullName.indexOf(searchString) >= 0)
                                selector.options.add(option);
                        }
                        else {
                            selector.options.add(option);
                        }
                    }
                }
                selector.value = selected;
            },
            toSVGDataURL: function(image) {
                var graph = image.cloneNode(true);
                var viewport = graph.getElementById('viewport');
                if(viewport) graph.removeChild(viewport);
                var svg = (new XMLSerializer()).serializeToString(graph);
                return "data:image/svg+xml;base64," + btoa(svg);
            },
            toPNGDataURL: function(image) {
                var can = document.createElement('canvas');
                var ctx = can.getContext('2d');
                var img = new Image();
                img.width = can.width = image.width.baseVal.value;
                img.height = can.height = image.height.baseVal.value;
                img.src = this.toSVGDataURL(image);
                // TODO: seems to work synchronously
                ctx.drawImage(img, 0, 0);
                return can.toDataURL();
            },
            findNodeToExplode: function(node) {
                var edge, otherNode;
                for(var i = 0; edge = node.edges[i]; i++) {
                    otherNode = edge.node === node ? edge.otherNode : edge.node;
                    if((otherNode.type === NodeType.ANCHOR) && otherNode.imploded) {
                        Model.explode([Model.nodeToComponent(otherNode)]);
                        break;
                    }
                }
            },
            selectNode: function(id) {
                if(id !== 'none') {
                    var i, edge, otherNode, node;
                    var component = Model.idToComponent[id];
                    var node = component.node;
                    // find the closest imploded node and explode it
                    if(!node.visible) {
                        if(node.type === NodeType.ATTRIBUTE)
                            this.findNodeToExplode(node);
                        else if(node.type === NodeType.KNOT) {
                            this.findNodeToExplode(node);
                            if(!node.visible) {
                                for(i = 0; edge = node.edges[i]; i++) {
                                    otherNode = edge.node === node ? edge.otherNode : edge.node;
                                    if(otherNode.type === NodeType.ATTRIBUTE) {
                                        this.findNodeToExplode(otherNode);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    EventHandler.clearSelection();
                    EventHandler.addComponentToSelection(component);
                    Actions.centerModelOn(node);
                }
                else {
                    EventHandler.clearSelection();
                }
            },
            getDirective: function() {
                var database = Defaults.databaseTarget;
                var temporalization = Defaults.temporalization;
                var directive = database + '_' + temporalization + '.directive';
                return directive;
            },
            transform: function (xmlDocument, transformationURL, ownerDocument) {
                var result;
                var xmlhttp = new window.XMLHttpRequest();
                // Added random parameter to prevent caching...
                xmlhttp.open("GET", transformationURL + '?r=' + Math.random(), false);
                xmlhttp.send(null);
                var processor = new XSLTProcessor();
                if(xmlhttp.responseXML) {
                    processor.importStylesheet(xmlhttp.responseXML.documentElement);
                }
                else {
                    var xml = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                    processor.importStylesheet(xml.documentElement);
                }
                result = processor.transformToFragment(xmlDocument, ownerDocument);
                return result;
            },
            createEmail: function(str) {
                ASKBEFOREUNLOAD = false; // prevent onbeforeunload behavior
                var modelDescription = new XMLSerializer().serializeToString(Model.toXML());
                var save = document.createElement('a');
                var modelName = Model.name || 'Model';
                save.href = "mailto:?subject=" + modelName + "&body=" + str;
                save.target = '_self';
                var event = document.createEvent('Event');
                event.initEvent('click', true, true);
                save.dispatchEvent(event);
                (window.URL || window.webkitURL).revokeObjectURL(save.href);
            },
            saveToDisk: function (str, type) {
                var save = document.createElement('a');
                save.href = 'data:text/' + type + ',' + str;
                save.target = '_blank';
                save.download = (Model.name || 'Model') + '.' + type;
                var event = document.createEvent('Event');
                event.initEvent('click', true, true);
                save.dispatchEvent(event);
                (window.URL || window.webkitURL).revokeObjectURL(save.href);
            },
            loadFromURL: function (url, layout) {
                layout = typeof layout !== 'undefined' ? layout : false;
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.open("GET", url, false);
                xmlhttp.send(null);
                EventHandler.clearSelection();
                SVGLayer.clearAll();
                NAVLayer.clearAll();
                Model.uncloud();
                Model.clearStates();
                Model.fromXML(xmlhttp.responseXML);
                Actions.setModelStatus();
                Actions.resetZoom();
                Actions.centerModel();
                DrawingEngine.taint();
                DrawingEngine.start(layout);
            },
            modelStatusText: null,
            setModelStatus: function() {
                var statusElement = document.getElementById("model");
                var status = "Local editing mode";
                if(Model.name && Model.id)
                    status = "Cloud mode, editing " + Model.scope + " model: " + Model.name;
                if(Actions.modelStatusText)
                    statusElement.removeChild(Actions.modelStatusText);
                Actions.modelStatusText = document.createTextNode(status);
                statusElement.appendChild(Actions.modelStatusText);
            },
            cloudStatusText: null,
            checkCloudConnectionStatus: function(redirect) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var statusElement = document.getElementById("cloud");
                        if(Actions.cloudStatusText)
                            statusElement.removeChild(Actions.cloudStatusText);
                        var lines, response = xmlhttp.responseText;
                        if(response.match(/^OK:/) && !redirect) {
                            lines = response.split(/[\r\n]/);
                            var login = lines[0].replace(/^OK:/, '').replace(/^[^\S]+/,'');
                            Actions.cloudStatusText = document.createTextNode(login);
                            statusElement.appendChild(Actions.cloudStatusText);
                            USER_ID = lines[2];
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^LOGIN:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging in...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            window.location = response.replace(/^LOGIN:/, '').replace(/^[^\S]+/,'');
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^OK:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging out...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            lines = response.split(/[\r\n]/);
                            window.location = lines[1];
                            LOGGED_IN = false;
                        }
                        else {
                            Actions.cloudStatusText = document.createTextNode("Not logged in (click here to log in)");
                            statusElement.appendChild(Actions.cloudStatusText);
                            LOGGED_IN = false;
                        }
                        Actions.setModelStatus();
                    }
                };

                var params = {};
                params.action = 'status';
                this.cloudWrapper(xmlhttp, params);
            },
            listModelsInCloud: function(scope) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";

                if(scope === 'private' && !LOGGED_IN) {
                    alert("You need to log in to reach your private models. Try again after logging in!");
                    this.checkCloudConnectionStatus(true);
                }

                new CloudBrowserPopover(scope);
            },
            loadModelFromCloud: function(modelId, modelName, modelScope, modelKeywords, modelDescription) {
                var modalBackground = new ModalBackground('Loading model, please wait...');
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be loaded from the cloud service!");
                            if(Model.isEmpty())
                                Model.setupMinimal(false);
                        }
                        else {
                            var model = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                            EventHandler.clearSelection();
                            SVGLayer.clearAll();
                            NAVLayer.clearAll();
                            Model.uncloud();
                            Model.clearStates();
                            Model.fromXML(model);
                            Model.id = modelId;
                            Model.name = modelName;
                            Model.scope = modelScope;
                            Model.keywords = modelKeywords;
                            Model.description = modelDescription;
                            Actions.setModelStatus();
                            Actions.resetZoom();
                            Actions.centerModel();
                            DrawingEngine.taint();
                            DrawingEngine.start(false);
                        }
                        modalBackground.close();
                    }
                };

                var params = {};
                params.action = 'load';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp,params);
            },
            saveModelInCloud: function(popover) {
                if(popover) {
                    new CloudSaverPopover();
                }
                else {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                        if(xmlhttp.readyState === 4) {
                            var response = xmlhttp.responseText;
                            if(response.match(/^LOGIN:/)) {
                                alert("You need to log in before saving. Try to save again after logging in!");
                                ASKBEFOREUNLOAD = false;
                                window.location = response.replace(/^LOGIN:/, '');
                            }
                            else if(response.match(/^OK:/)) {
                                var modelId = response.replace(/^OK:/, '').replace(/^[^\S]+/,'').replace(/[^\S]+$/,'');
                                Model.id = modelId;
                                Actions.setModelStatus();
                                alert("Model saved in cloud as: " + Model.name);
                            }
                            else {
                                // this is probably an error msg from the server
                                alert(response);
                            }
                        }
                    };

                    var params = {};
                    params.action = 'save';
                    params.modelName = Model.name;
                    params.modelXml = new XMLSerializer().serializeToString(Model.toXML(false));
                    params.icon = Actions.toPNGDataURL(NAV);
                    params.scope = Model.scope || "private";
                    params.keywords = Model.keywords;
                    params.description = escape(Model.description);
                    if(Model.id)
                        params.modelId = Model.id;
                    this.cloudWrapper(xmlhttp,params);
                }
            },
            deleteModelFromCloud : function(modelId) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be deleted from the cloud service!\n" + response);
                        }
                        else {
                            alert("The model was deleted successfully.");
                        }
                    }
                };
                var params = {};
                params.action = 'delete';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp, params);
            },
            sendMultiPart: function(xmlhttp, params) {
                var BOUNDARY = "---------------------------1966284435497298061834782736";
                var rn = "\r\n";
                var req = "--" + BOUNDARY;
                for (var i in params) {
                    req += rn + "Content-Disposition: form-data; name=\"" + i + "\"";
                    req += rn + rn + params[i] + rn + "--" + BOUNDARY;
                }
                req += "--";
                xmlhttp.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
                xmlhttp.sendAsBinary(req);
            },
            cloudWrapper : function(xmlhttp, params) {
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                //var url = "http://localhost:8888/anchormodeler";
                xmlhttp.open("POST", url, true);
                xmlhttp.withCredentials = 'true';
                if(window.FormData) {
                    var formData = new FormData();
                    for (var i in params)
                        formData.append(i,params[i]);
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    this.sendMultiPart(xmlhttp, params);
                }
            },
            resetZoom: function() {
                SVG.viewBox.baseVal.width = window.innerWidth;
                SVG.viewBox.baseVal.height = window.innerHeight;
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
            },
            centerModel: function() {
                var boundingBox = SVGLayer.nodes.getBBox();
                var xCenter = boundingBox.x + boundingBox.width/2;
                var yCenter = boundingBox.y + boundingBox.height/2;
                this.centerModelAt(xCenter, yCenter);
            },
            centerModelOn: function(node) {
                this.centerModelAt(node.xPosition, node.yPosition);
            },
            centerModelAt: function(x, y) {
                SVG.viewBox.baseVal.x = x - SVG.viewBox.baseVal.width/2;
                SVG.viewBox.baseVal.y = y - SVG.viewBox.baseVal.height/2;
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
            },
            randomizeLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    if(!Model.visibleNodes[i].fixed) {
                        Model.visibleNodes[i].xPosition = Math.random() * window.innerWidth;
                        Model.visibleNodes[i].yPosition = Math.random() * window.innerHeight;
                    }
                }
                DrawingEngine.start(true);
            },
            toggleFixation: function () {
                for(var i = 0; i < Model.components.length; i++)
                    Model.components[i].setFixed(!Model.components[i].getFixed());
                DrawingEngine.start(true);
            },
            releaseAll: function () {
                for(var i = 0; i < Model.components.length; i++)
                    Model.components[i].setFixed(false);
                DrawingEngine.start(true);
            },
            toggleNames: function () {
                DrawingEngine.showNames = !DrawingEngine.showNames;
                if(DrawingEngine.showNames)
                    SVGLayer.show('names');
                else
                    SVGLayer.hide('names');
                DrawingEngine.start(false);
            },
            toggleMnemonics: function () {
                Settings.showMnemonics = !Settings.showMnemonics;
                DrawingEngine.start(false);
            },
            toggleColoring: function() {
                DrawingEngine.coloring = !DrawingEngine.coloring;
                DrawingEngine.start(false);
            },
            implodeAll: function() {
                var i, component, allComponents = [];
                for(i = 0; component = Model.components[i]; i++) {
                    if((component.node.type === NodeType.ANCHOR) && !component.imploded)
                        allComponents.push(component);
                }
                EventHandler.clearSelection();
                Model.explode(allComponents);
            },
            explodeAll: function() {
                var i, component, allComponents = [];
                for(i = 0; component = Model.components[i]; i++) {
                    if((component.node.type === NodeType.ANCHOR) && component.imploded)
                        allComponents.push(component);
                }
                Model.explode(allComponents);
            },
            generateURL: function() {
                if(Model.id) {
                    if(Model.scope !== 'public')
                        alert("This model not public. Please note that only you will be able to use the URL.");
                    var url = window.location.protocol + '//' + window.location.hostname + window.location.pathname;
                    url += "?id=" + Model.id;
                    prompt("Sharable and social media friendly URL:", url);
                }
                else {
                    alert("This model is not saved in the cloud. Please save the model before generating a URL.");
                }
            },
            generateHTML: function() {
                var html = window.open('', '_newtab').document;
                html.open();
                html.write(
                    '<!DOCTYPE HTML>'+
                    '<html><head>'+
                    '  <title>Anchor Model</title>' +
                    '  <link rel="stylesheet" type="text/css" href="documentation.css">'+
                    '</head><body>'+
                    '</body></html>'
                );
                html.close();
                var fragment = this.transform(Model.toXML(false), 'xml2documentation.xsl', html);
                // alert(new XMLSerializer().serializeToString(fragment));
                html.body.appendChild(fragment);
            },
            jsonify: function(xml) {
                var object = Sisulator.objectify(xml, Sisulator.MAP);
                // jsonify the object
                return JSON.stringify(object, null, 3);
            },
            // creates a preformatted document fragment from the given text
            preformat: function(text) {
                var fragment = document.createDocumentFragment();
                var pre = document.createElement('pre');
                pre.appendChild(document.createTextNode(text));
                fragment.appendChild(pre);
                return fragment;
            }
        };

        var Sisulator = {
            // the map defines 'keys' for elements that may occur more than once
            // on the same level in the XML document
            MAP: {
                knot: function(xml, fragment) {
                    return fragment.getAttribute('mnemonic');
                },
                anchor: function(xml, fragment) {
                    return fragment.getAttribute('mnemonic');
                },
                attribute: function(xml, fragment) {
                    return fragment.getAttribute('mnemonic');
                },
                tie: function(xml, fragment) {
                    var roles = xml.evaluate(
                            '*[@role]',
                            fragment,
                            null,
                            XPathResult.ORDERED_NODE_ITERATOR_TYPE, // document order
                            null
                    );
                    var key = '', role = roles.iterateNext();
                    while(role) {
                        key += role.getAttribute('type') + '_' + role.getAttribute('role');
                        role = roles.iterateNext();
                        if(role) key += '_';
                    }
                    return key;
                },
                anchorRole: function(xml, fragment) {
                    return fragment.getAttribute('type') + '_' + fragment.getAttribute('role');
                },
                knotRole: function(xml, fragment) {
                    return fragment.getAttribute('type') + '_' + fragment.getAttribute('role');
                }
            },
            // used to replace certain element names with others
            replacer: function(name) {
                switch(name) {
                    case 'anchorRoles':
                        return 'roles';
                    case 'knotRoles':
                        return 'roles';
                    default:
                        return name;
                }
            },
            // this function will recursively traverse the XML document and
            // create a 'hash' object that mimics the structure using the given map
            // to handle siblings using the same tag
            objectify: function(xml, map) {
                var listSuffix = 's';
                function objectifier(xmlFragment, map, object) {
                    // element node
                    if(xmlFragment.nodeType === 1) {
                        // if there are children or attributes we need a container
                        if(xmlFragment.attributes.length > 0 || xmlFragment.firstChild) {
                            if(!object[xmlFragment.nodeName])
                                object[xmlFragment.nodeName] = Object.create(null);
                            var partialObject = object[xmlFragment.nodeName];
                            if(typeof map[xmlFragment.nodeName] === 'function') {
                                var key = map[xmlFragment.nodeName](xml, xmlFragment);
                                if(key) {
                                    partialObject = partialObject[key] = Object.create(null);
                                    partialObject.id = key;
                                    var name = Sisulator.replacer(
                                            xmlFragment.nodeName + listSuffix
                                    );
                                    // reference the object from the array
                                    if(!object[name])
                                        object[name] = [];
                                    object[name].push(key);
                                }
                            }
                            // process attributes
                            if (xmlFragment.attributes.length > 0) {
                                for (var j = 0; j < xmlFragment.attributes.length; j++) {
                                    var attribute = xmlFragment.attributes.item(j);
                                    partialObject[attribute.nodeName] = attribute.nodeValue;
                                }
                            }
                            // process children
                            var child = xmlFragment.firstChild;
                            if(child) objectifier(child, map, partialObject);
                        }
                    }
                    // text node
                    else if(xmlFragment.nodeType === 3) {
                        // add content with underscore naming
                        if(xmlFragment.nodeValue)
                            object['_' + xmlFragment.parentNode.nodeName] = xmlFragment.nodeValue;
                    }
                    // process siblings
                    var sibling = xmlFragment.nextSibling;
                    if(sibling) objectifier(sibling, map, object);
                    return object;
                }
                // just initialize and return the result
                return objectifier(xml.documentElement, map, {});
            },
            sisulate: function(xml, directive) {
                // objectify the xml
                var schema = Sisulator.objectify(xml, Sisulator.MAP).schema;
                var cacheDisabler = '';
                if(DEBUG) cacheDisabler = '?r=' + Math.random();
                // this variable holds the result
                var _sisula_ = '';

                // process and evaluate all sisulas in the directive
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.open("GET", directive + cacheDisabler, false);
                xmlhttp.send(null);
                var response = xmlhttp.responseText.replace(/\r/g, ''); // unify line breaks
                // only non-empty lines that are not comments (starts with #)
                var scripts = response.match(/^[^#].+/gm);
                var script;
                var splitter = /\/\*~([\s\S]*?)~\*\//g; // split JS /*~ sisula template ~*/ JS
                // process every sisula
                for(var s = 0; script = scripts[s]; s++) {
                    xmlhttp.open("GET", script + cacheDisabler, false);
                    xmlhttp.send(null);
                    var sisula = xmlhttp.responseText;
                    // split language into JavaScript and SQL template components
                    var sisulets = sisula.split(splitter);
                    // substitute from SQL template to JavaScript
                    for(var i = 1; i < sisulets.length; i+=2) {
                        // honor escaped dollar signs
                        sisulets[i] = sisulets[i].replace(/[$]{2}/g, '§DOLLAR§'); // escaping dollar signs
                        sisulets[i] = sisulets[i].replace(/["]{2}/g, '§QUOTED§'); // escaping double quotes
                        sisulets[i] = sisulets[i].replace(/[$]{([\S\s]*?)}[$]/g, '" + $1 + "'); // multi-expression
                        sisulets[i] = sisulets[i].replace(/[$]\(([\S\s]*?)\)\?[^\S\n]*([^:\n]*)[:]?[^\S\n]*(.*)/g, '" + ($1 ? "$2" : "$3") + "'); // conditional
                        sisulets[i] = sisulets[i].replace(/[\$]([\w.]*?)(?:([\$])|([^\w.]|$))/g, '" + ($1 ? $1 : "") + "$3'); // single
                        sisulets[i] = sisulets[i].replace(/(\r\n|\n|\r)/g, '\\n" +\n'); // line breaks
                        sisulets[i] = sisulets[i].replace(/^/gm, '"'); // start of line
                        sisulets[i] = '_sisula_+=' + sisulets[i] + '";'; // variable assignment
                    }
                    // join the parts together again (now all JavaScript)
                    sisula = sisulets.join('');
                    try {
                        if(DEBUG && console && console.log)
                            console.log(sisula);
                        // this eval needs schema and _sisula_ to be defined
                        eval(sisula);
                    }
                    catch(e) {
                        if(DEBUG && console && console.error && script)
                            console.error('The script ' + script + ' could not be executed.');
                        throw e;
                    }
                }
                _sisula_ = _sisula_.replace(/§DOLLAR§/g, '$'); // unescaping dollar signs
                _sisula_ = _sisula_.replace(/§QUOTED§/g, '"'); // unescaping double quotes
                _sisula_ = _sisula_.replace(/^\s*[\r\n]/gm, ''); // remove empty lines
                _sisula_ = _sisula_.replace(/(\S+[^\S\n])(?:[^\S\n]+)/gm, '$1'); // consume multiple spaces, but not indentation
                return _sisula_;
            }
        };

        var Settings = {
            // default values for some 'global' settings
            calculations: 'simple',
            showMnemonics: true,
            showCardinalities: true,
            init: function() {
                document.getElementById('damping').value = ((1 - LayoutEngine.damping) * 100).toFixed(0);
                document.getElementById('longRangeEffect').value = (LayoutEngine.longRangeEffect * 100).toFixed(0);
                document.getElementById('fuzziness').value = (LayoutEngine.fuzziness * 100).toFixed(0);
                document.getElementById('normalDistance').value = LayoutEngine.normalDistance.toFixed(0);
                document.getElementById('stoppingVelocity').value = LayoutEngine.stoppingVelocity.toFixed(1);
                document.getElementById('minimumStartingVelocity').value = LayoutEngine.minimumStartingVelocity.toFixed(1);
                document.getElementById('maximumStartingVelocity').value = LayoutEngine.maximumStartingVelocity.toFixed(1);
                document.getElementById('partitionFactor').value = LayoutEngine.partitionFactor.toFixed(0);
                document.getElementById('stiffness').value = LayoutEngine.stiffness.toFixed(1);
                document.getElementById('temporalization').value = Defaults.temporalization;
                document.getElementById('database').value = Defaults.databaseTarget;
                document.getElementById('miniatureFramesBetweenRefresh').value = DrawingEngine.miniatureFramesBetweenRefresh;
                document.getElementById('calculations').value = this.calculations;
                document.getElementById('defaultCapsule').value = Defaults.encapsulation;
                document.getElementById('defaultIdentity').value = Defaults.identity;
                document.getElementById('defaultChronon').value = Defaults.chronon;
                document.getElementById('defaultNow').value = Defaults.now;
                document.getElementById('defaultChangingRange').value = Defaults.changingRange;
                document.getElementById('restatability').checked = Defaults.restatability === 'true';
                document.getElementById('idempotency').checked = Defaults.idempotency === 'true';
                document.getElementById('metadataUsage').checked = Defaults.metadataUsage === 'true';
                document.getElementById('businessViews').checked = Defaults.businessViews === 'true';
                document.getElementById('equivalence').checked = Defaults.equivalence === 'true';
                document.getElementById('changingSuffix').value = Defaults.changingSuffix;
                document.getElementById('checksumSuffix').value = Defaults.checksumSuffix;
                document.getElementById('identitySuffix').value = Defaults.identitySuffix;
                document.getElementById('naming').value = Defaults.naming;
            },
            resetDefaults: function(warn) {
                var reset = false;
                if(warn)
                    reset = confirm(
                            "Are you sure you want to reset to default values? " +
                            "This will overwrite any changes you have made."
                    );
                else
                    reset = true;
                if(reset) {
                    this.setDefaultCapsule('dbo');
                    this.setDefaultIdentity('int');
                    this.setDefaultChronon('datetime2(7)');
                    this.setDefaultNow('sysdatetime()');
                    this.setDefaultChangingRange('datetime');
                    this.setMetadataPrefix('Metadata');
                    this.setMetadataType('int');
                    this.setEquivalentSuffix('EQ');
                    this.setEquivalentRange('tinyint');
                    this.setRestatability('true');
                    this.setIdempotency('false');
                    this.setAssertiveness('true');
                    this.setMetadataUsage('true');
                    this.setBusinessViews('false');
                    this.setEquivalence('false');
                    this.setChangingSuffix('ChangedAt');
                    this.setIdentitySuffix('ID');
                    this.setPositIdentityRange('int');
                    this.setPositingRange('datetime');
                    this.setPositingSuffix('PositedAt');
                    this.setPositorRange('tinyint');
                    this.setPositorSuffix('Positor');
                    this.setReliabilityRange('tinyint');
                    this.setReliabilitySuffix('Reliability');
                    this.setReliableCutoff('1');
                    this.setDeleteReliability('0');
                    this.setReliableSuffix('Reliable');
                    this.setPartitioning('false');
                    this.setEntityIntegrity('true');
                    this.setTemporalization('uni');
                    this.setDatabase('SQLServer', false);
                    this.setNaming('improved');
                    this.init();
                }
            },
            resetSettings: function(warn) {
                var reset = false;
                if(warn)
                    reset = confirm(
                            "Are you sure you want to reset to default values? " +
                            "This will overwrite any changes you have made."
                    );
                else
                    reset = true;
                if(reset) {
                    this.setDamping(4);
                    this.setLongRangeEffect(25);
                    this.setFuzziness(10);
                    this.setNormalDistance(30);
                    this.setStoppingVelocity(0.1);
                    this.setMinimumStartingVelocity(1);
                    this.setMaximumStartingVelocity(5);
                    this.setPartitionFactor(15);
                    this.setStiffness(1);
                    this.setMiniRate(50);
                    this.setCalculations('simple');
                    NodeType.mass[NodeType.KNOT] = 1;
                    NodeType.charge[NodeType.KNOT] = 1;
                    NodeType.mass[NodeType.ANCHOR] = 1;
                    NodeType.charge[NodeType.ANCHOR] = 1;
                    NodeType.mass[NodeType.ATTRIBUTE] = 1;
                    NodeType.charge[NodeType.ATTRIBUTE] = 1;
                    NodeType.mass[NodeType.TIE] = 1;
                    NodeType.charge[NodeType.TIE] = 1;
                    NodeType.mass[NodeType.EDGE] = 1;
                    NodeType.charge[NodeType.EDGE] = 1;
                    this.init();
                }
            },
            storeSettings: function(storage) {
                storage.setItem("version", VERSION);
                storage.setItem("damping", (1 - LayoutEngine.damping) * 100);
                storage.setItem("longRangeEffect", LayoutEngine.longRangeEffect * 100);
                storage.setItem("fuzziness", LayoutEngine.fuzziness * 100);
                storage.setItem("normalDistance", LayoutEngine.normalDistance);
                storage.setItem("stoppingVelocity", LayoutEngine.stoppingVelocity);
                storage.setItem("minimumStartingVelocity", LayoutEngine.minimumStartingVelocity);
                storage.setItem("maximumStartingVelocity", LayoutEngine.maximumStartingVelocity);
                storage.setItem("partitionFactor", LayoutEngine.partitionFactor);
                storage.setItem("stiffness", LayoutEngine.stiffness);
                storage.setItem("temporalization", Defaults.temporalization);
                storage.setItem("database", Defaults.databaseTarget);
                storage.setItem("miniatureFramesBetweenRefresh", DrawingEngine.miniatureFramesBetweenRefresh);
                storage.setItem("calculations", this.calculations);
                storage.setItem("defaultCapsule", Defaults.encapsulation);
                storage.setItem("defaultIdentity", Defaults.identity);
                storage.setItem("defaultChronon", Defaults.chronon);
                storage.setItem("defaultNow", Defaults.now);
                storage.setItem("defaultChangingRange", Defaults.changingRange);
                storage.setItem("metadataPrefix", Defaults.metadataPrefix);
                storage.setItem("metadataType", Defaults.metadataType);
                storage.setItem("equivalentSuffix", Defaults.equivalentSuffix);
                storage.setItem("equivalentRange", Defaults.equivalentRange);
                storage.setItem("metadataUsage", Defaults.metadataUsage);
                storage.setItem("businessViews", Defaults.businessViews);
                storage.setItem("equivalence", Defaults.equivalence);
                storage.setItem("restatability", Defaults.restatability);
                storage.setItem("idempotency", Defaults.idempotency);
                storage.setItem("assertiveness", Defaults.assertiveness);
                storage.setItem("changingSuffix", Defaults.changingSuffix);
                storage.setItem("identitySuffix", Defaults.identitySuffix);
                storage.setItem("positIdentity", Defaults.positIdentity);
                storage.setItem("positingRange", Defaults.positingRange);
                storage.setItem("positingSuffix", Defaults.positingSuffix);
                storage.setItem("positorRange", Defaults.positorRange);
                storage.setItem("positorSuffix", Defaults.positorSuffix);
                storage.setItem("checksumSuffix", Defaults.checksumSuffix);
                storage.setItem("reliabilityRange", Defaults.reliabilityRange);
                storage.setItem("reliabilitySuffix", Defaults.reliabilitySuffix);
                storage.setItem("reliableCutoff", Defaults.reliableCutoff);
                storage.setItem("deleteReliability", Defaults.deleteReliability);
                storage.setItem("reliableSuffix", Defaults.reliableSuffix);
                storage.setItem("partitioning", Defaults.partitioning);
                storage.setItem("entityIntegrity", Defaults.entityIntegrity);
                storage.setItem("naming", Defaults.naming);
                storage.setItem("knotMass", NodeType.mass[NodeType.KNOT]);
                storage.setItem("knotCharge", NodeType.charge[NodeType.KNOT]);
                storage.setItem("anchorMass", NodeType.mass[NodeType.ANCHOR]);
                storage.setItem("anchorCharge", NodeType.charge[NodeType.ANCHOR]);
                storage.setItem("attributeMass", NodeType.mass[NodeType.ATTRIBUTE]);
                storage.setItem("attributeCharge", NodeType.charge[NodeType.ATTRIBUTE]);
                storage.setItem("tieMass", NodeType.mass[NodeType.TIE]);
                storage.setItem("tieCharge", NodeType.charge[NodeType.TIE]);
                storage.setItem("edgeMass", NodeType.mass[NodeType.EDGE]);
                storage.setItem("edgeCharge", NodeType.charge[NodeType.EDGE]);
            },
            loadSettings: function(storage) {
                if(storage.getItem("version") != VERSION) {
                    this.resetDefaults(false);
                    this.resetSettings(false);
                }
                else {
                    this.setDamping(storage.getItem('damping') || 4);
                    this.setLongRangeEffect(storage.getItem('longRangeEffect') || 25);
                    this.setFuzziness(storage.getItem('fuzziness') || 10);
                    this.setNormalDistance(storage.getItem('normalDistance') || 30);
                    this.setStoppingVelocity(storage.getItem('stoppingVelocity') || 0.1);
                    this.setMinimumStartingVelocity(storage.getItem('minimumStartingVelocity') || 1);
                    this.setMaximumStartingVelocity(storage.getItem('maximumStartingVelocity') || 5);
                    this.setPartitionFactor(storage.getItem('partitionFactor') || 15);
                    this.setStiffness(storage.getItem('stiffness') || 1);
                    this.setDatabase(storage.getItem('database') || 'SQLServer', false);
                    this.setMiniRate(storage.getItem('miniatureFramesBetweenRefresh') || 50);
                    this.setCalculations(storage.getItem('calculations') || 'simple');
                    this.setDefaultCapsule(storage.getItem('defaultCapsule') || Defaults.encapsulation);
                    this.setDefaultIdentity(storage.getItem('defaultIdentity') || Defaults.identity);
                    this.setDefaultChronon(storage.getItem('defaultChronon') || Defaults.chronon);
                    this.setDefaultNow(storage.getItem('defaultNow') || Defaults.now);
                    this.setDefaultChangingRange(storage.getItem('defaultChangingRange') || Defaults.changingRange);
                    this.setMetadataPrefix(storage.getItem('metadataPrefix') || Defaults.metadataPrefix);
                    this.setMetadataType(storage.getItem('metadataType') || Defaults.metadataType);
                    this.setEquivalentRange(storage.getItem('equivalentRange') || Defaults.equivalentRange);
                    this.setEquivalentSuffix(storage.getItem('equivalentSuffix') || Defaults.equivalentSuffix);
                    this.setMetadataUsage(storage.getItem('metadataUsage') || Defaults.metadataUsage);
                    this.setBusinessViews(storage.getItem('businessViews') || Defaults.businessViews);
                    this.setEquivalence(storage.getItem('equivalence') || Defaults.equivalence);
                    this.setChangingSuffix(storage.getItem('changingSuffix') || Defaults.changingSuffix);
                    this.setIdentitySuffix(storage.getItem('identitySuffix') || Defaults.identitySuffix);
                    this.setPositIdentityRange(storage.getItem('positIdentity') || Defaults.positIdentity);
                    this.setPositingRange(storage.getItem('positingRange') || Defaults.positingRange);
                    this.setPositingSuffix(storage.getItem('positingSuffix') || Defaults.positingSuffix);
                    this.setPositorRange(storage.getItem('positorRange') || Defaults.positorRange);
                    this.setPositorSuffix(storage.getItem('positorSuffix') || Defaults.positorSuffix);
                    this.setChecksumSuffix(storage.getItem('checksumSuffix') || Defaults.checksumSuffix);
                    this.setReliabilityRange(storage.getItem('reliabilityRange') || Defaults.reliabilityRange);
                    this.setReliabilitySuffix(storage.getItem('reliabilitySuffix') || Defaults.reliabilitySuffix);
                    this.setReliableCutoff(storage.getItem('reliableCutoff') || Defaults.reliableCutoff);
                    this.setDeleteReliability(storage.getItem('deleteReliability') || Defaults.deleteReliability);
                    this.setReliableSuffix(storage.getItem('reliableSuffix') || Defaults.reliableSuffix);
                    this.setPartitioning(storage.getItem('partitioning') || Defaults.partitioning);
                    this.setEntityIntegrity(storage.getItem('entityIntegrity') || Defaults.entityIntegrity);
                    this.setRestatability(storage.getItem('restatability') || Defaults.restatability);
                    this.setIdempotency(storage.getItem('idempotency') || Defaults.idempotency);
                    this.setAssertiveness(storage.getItem('assertiveness') || Defaults.assertiveness);
                    this.setNaming(storage.getItem('naming') || Defaults.naming);
                    NodeType.mass[NodeType.KNOT] = 1 * storage.getItem('knotMass') || 1;
                    NodeType.charge[NodeType.KNOT] = 1 * storage.getItem('knotCharge') || 1;
                    NodeType.mass[NodeType.ANCHOR] = 1 * storage.getItem('anchorMass') || 1;
                    NodeType.charge[NodeType.ANCHOR] = 1 * storage.getItem('anchorCharge') || 1;
                    NodeType.mass[NodeType.ATTRIBUTE] = 1 * storage.getItem('attributeMass') || 1;
                    NodeType.charge[NodeType.ATTRIBUTE] = 1 * storage.getItem('attributeCharge') || 1;
                    NodeType.mass[NodeType.TIE] = 1 * storage.getItem('tieMass') || 1;
                    NodeType.charge[NodeType.TIE] = 1 * storage.getItem('tieCharge') || 1;
                    NodeType.mass[NodeType.EDGE] = 1 * storage.getItem('edgeMass') || 1;
                    NodeType.charge[NodeType.EDGE] = 1 * storage.getItem('edgeCharge') || 1;
                    // must be done after Defaults have been populated with previously stored values
                    this.setTemporalization(storage.getItem('temporalization') || 'uni');
                }
                this.init();
            },
            setPositIdentityRange: function(value) {
                Defaults.positIdentity = value;
            },
            setPositingRange: function(value) {
                Defaults.positingRange = value;
            },
            setPositingSuffix: function(value) {
                Defaults.positingSuffix = value;
            },
            setPositorRange: function(value) {
                Defaults.positorRange = value;
            },
            setPositorSuffix: function(value) {
                Defaults.positorSuffix = value;
            },
            setChecksumSuffix: function(value) {
                Defaults.checksumSuffix = value;
            },
            setReliabilityRange: function(value) {
                Defaults.reliabilityRange = value;
            },
            setReliabilitySuffix: function(value) {
                Defaults.reliabilitySuffix = value;
            },
            setReliableCutoff: function(value) {
                Defaults.reliableCutoff = value;
            },
            setDeleteReliability: function(value) {
                Defaults.deleteReliability = value;
            },
            setReliableSuffix: function(value) {
                Defaults.reliableSuffix = value;
            },
            setPartitioning: function(value) {
                Defaults.partitioning = value;
            },
            setEntityIntegrity: function(value) {
                Defaults.entityIntegrity = value;
            },
            setNaming: function(value) {
                Defaults.naming = value;
            },
            positIdentity: null,
            positingRange: null,
            positingSuffix: null,
            positorRange: null,
            positorSuffix: null,
            reliabilityRange: null,
            reliabilitySuffix: null,
            reliableCutoff: null,
            deleteReliability: null,
            reliableSuffix: null,
            partitioning: null,
            entityIntegrity: null,
            metadataPrefix: null,
            metadataType: null,
            equivalentSuffix: null,
            equivalentRange: null,
            assertiveness: null,
            addTextItem: function(item, destination, before, label, title, listener) {
                if(!this[item]) {
                    this[item] = {
                        container: document.createElement('li'),
                        input: document.createElement('input')
                    };
                    this[item].input.setAttribute('type', 'text');
                    this[item].input.setAttribute('class', 'inputDefaults');
                    this[item].input.addEventListener('blur', listener, false);
                    this[item].input.value = Defaults[item];
                    this[item].container.setAttribute('title', title);
                    this[item].container.appendChild(this[item].input);
                    this[item].container.appendChild(document.createTextNode(label));
                    destination.insertBefore(this[item].container, before);
                }
                else // update values in case settings have changed
                    this[item].input.value = Defaults[item];
            },
            addBoolItem: function(item, destination, before, label, title, listener) {
                if(!this[item]) {
                    this[item] = {
                        container: document.createElement('li'),
                        input: document.createElement('input')
                    };
                    this[item].input.setAttribute('type', 'checkbox');
                    this[item].input.setAttribute('class', 'inputDefaults');
                    this[item].input.addEventListener('change', listener, false);
                    this[item].input.checked = Defaults[item] === 'true';
                    this[item].container.setAttribute('title', title);
                    this[item].container.appendChild(this[item].input);
                    this[item].container.appendChild(document.createTextNode(label));
                    destination.insertBefore(this[item].container, before);
                }
                else // update values in case settings have changed
                    this[item].input.checked = Defaults[item] === 'true';
            },
            removeItem: function(item, from) {
                if(this[item]) {
                    this[item].container.removeChild(this[item].input);
                    from.removeChild(this[item].container);
                    this[item] = null;
                }
            },
            setTemporalization: function(value) {
                Defaults.temporalization = value;
                var temporalizationSelect = document.getElementById('temporalization');
                temporalizationSelect.value = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('crtSettingsBeforeHere');
                if(value === 'crt') {
                    this.addOrRemovePartitioning();
                    this.addTextItem(
                            'positIdentity', listOfDefaults, beforeItem, ' Posit identity',
                            "The 'data type' for identities of posits used throughout the implementation.",
                            function() { Settings.setPositIdentityRange(this.value); }
                    );
                    this.addTextItem(
                            'positingRange', listOfDefaults, beforeItem, ' Positing time range',
                            "The positing time (corrections) 'data type' used throughout the implementation.",
                            function() { Settings.setPositingRange(this.value); }
                    );
                    this.addTextItem(
                            'positingSuffix', listOfDefaults, beforeItem, ' Positing time suffix',
                            "The suffix used for the column storing the point in time a posit was made.",
                            function() { Settings.setPositingSuffix(this.value); }
                    );
                    this.addTextItem(
                            'positorRange', listOfDefaults, beforeItem, ' Positor range',
                            "The positor (one able to correct) 'data type' used throughout the implementation.",
                            function() { Settings.setPositorRange(this.value); }
                    );
                    this.addTextItem(
                            'positorSuffix', listOfDefaults, beforeItem, ' Positor suffix',
                            "The suffix used for the column storing the who made a posit.",
                            function() { Settings.setPositorSuffix(this.value); }
                    );
                    this.addTextItem(
                            'reliabilityRange', listOfDefaults, beforeItem, ' Reliability range',
                            "A 'data type' that can hold the desired degrees of reliability.",
                            function() { Settings.setReliabilityRange(this.value); }
                    );
                    this.addTextItem(
                            'reliabilitySuffix', listOfDefaults, beforeItem, ' Reliability suffix',
                            "The suffix used for the column storing reliability.",
                            function() { Settings.setReliabilitySuffix(this.value); }
                    );
                    this.addTextItem(
                            'reliableCutoff', listOfDefaults, beforeItem, ' Reliable cutoff',
                            "The smallest (inclusive) value of reliability to be considered reliable.",
                            function() { Settings.setReliableCutoff(this.value); }
                    );
                    this.addTextItem(
                            'deleteReliability', listOfDefaults, beforeItem, ' Delete reliability',
                            "The default value of reliability to use when deleting information.",
                            function() { Settings.setDeleteReliabilty(this.value); }
                    );
                    this.addTextItem(
                            'reliableSuffix', listOfDefaults, beforeItem, ' Reliable suffix',
                            "The suffix used for the computed column storing the boolean reliable result." +
                            "This is based on a calculation using the cutoff to determine if data is " +
                            "considered reliable or unreliable.",
                            function() { Settings.setReliableSuffix(this.value); }
                    );
                    this.addBoolItem(
                            'entityIntegrity', listOfDefaults, beforeItem, ' Ensure entity integrity',
                            "Entity integrity adds constraints ensuring that no temporal duplicates " +
                            "can co-exist for the same entity and version, that no negative recording " +
                            "time intervals can be stored, and that there are no overlapping intervals " +
                            "with respect to recording time.",
                            function() { Settings.setEntityIntegrity(this.checked ? 'true' : 'false'); }
                    );
                    this.addBoolItem(
                            'assertiveness', listOfDefaults, beforeItem, ' Assertiveness',
                            "Default for new items. Assertive items get new annex rows everytime a posit " +
                            "is made with a differnt positing time. Non-assertive items must also have a " +
                            "different reliability.",
                            function() { Settings.setAssertiveness(this.checked ? 'true' : 'false'); }
                    );
                    Editables.setEditability(Editables.positIdentityEdit, true);
                    Editables.setEditability(Editables.positGeneratorEdit, true);
                    Editables.setEditability(Editables.assertivenessEdit, true);
                }
                else {
                    this.removeItem('positIdentity', listOfDefaults);
                    this.removeItem('positingRange', listOfDefaults);
                    this.removeItem('positingSuffix', listOfDefaults);
                    this.removeItem('positorRange', listOfDefaults);
                    this.removeItem('positorSuffix', listOfDefaults);
                    this.removeItem('reliabilityRange', listOfDefaults);
                    this.removeItem('reliabilitySuffix', listOfDefaults);
                    this.removeItem('reliableCutoff', listOfDefaults);
                    this.removeItem('deleteReliability', listOfDefaults);
                    this.removeItem('reliableSuffix', listOfDefaults);
                    this.removeItem('entityIntegrity', listOfDefaults);
                    this.removeItem('assertiveness', listOfDefaults);
                    this.addOrRemovePartitioning();
                    Editables.setEditability(Editables.positIdentityEdit, false);
                    Editables.setEditability(Editables.positGeneratorEdit, false);
                    Editables.setEditability(Editables.assertivenessEdit, false);
                }
            },
            addOrRemovePartitioning: function() {
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('crtSettingsBeforeHere');
                if(Defaults.temporalization === 'crt' || Defaults.equivalence === 'true') {
                    if(!this.partitioning) {
                        this.addBoolItem(
                                'partitioning', listOfDefaults, beforeItem, ' Use partitioning',
                                "Partitioning will put currently recorded information in a separate partition " +
                                "from erased information, greatly speeding up querying in the bitemporal implementation.",
                                function() { Settings.setPartitioning(this.checked ? 'true' : 'false'); }
                        );
                    }
                }
                else
                    this.removeItem('partitioning', listOfDefaults);
            },
            setMetadataPrefix: function(value) {
                Defaults.metadataPrefix = value;
            },
            setMetadataType: function(value) {
                Defaults.metadataType = value;
            },
            setEquivalentSuffix: function(value) {
                Defaults.equivalentSuffix = value;
            },
            setEquivalentRange: function(value) {
                Defaults.equivalentRange = value;
            },
            setMetadataUsage: function(value) {
                Defaults.metadataUsage = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('metadataSettingsBeforeHere');
                if(value === 'true') {
                    this.addTextItem(
                            'metadataPrefix', listOfDefaults, beforeItem, ' Metadata prefix',
                            "The prefix used for the columns that store a metadata reference.",
                            function() { Settings.setMetadataPrefix(this.value); }
                    );
                    this.addTextItem(
                            'metadataType', listOfDefaults, beforeItem, ' Metadata type',
                            "The 'data type' of the metadata column.",
                            function() { Settings.setMetadataType(this.value); }
                    );
                }
                else {
                    this.removeItem('metadataPrefix', listOfDefaults);
                    this.removeItem('metadataType', listOfDefaults);
                }
            },
            setBusinessViews: function(value, userToggle) {
                Defaults.businessViews = value;
                if(userToggle && value === 'true')
                    alert(
                            "Please note that when business views are used " +
                            "descriptors must follow the same rules of uniqueness as mnemonics do, " +
                            "otherwise naming clashes may occur."
                    );
            },
            setEquivalence: function(value) {
                Defaults.equivalence = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('metadataSettingsBeforeHere');
                if(value === 'true') {
                    this.addTextItem(
                            'equivalentSuffix', listOfDefaults, beforeItem, ' Equivalents suffix',
                            "The suffix used for the columns that store equivalents.",
                            function() { Settings.setEquivalentSuffix(this.value); }
                    );
                    this.addTextItem(
                            'equivalentRange', listOfDefaults, beforeItem, ' Equivalents range',
                            "The 'data type' of the equivalents column.",
                            function() { Settings.setEquivalentRange(this.value); }
                    );
                    this.addOrRemovePartitioning();
                    Editables.setEditability(Editables.equivalenceEdit, true);
                }
                else {
                    this.removeItem('equivalentSuffix', listOfDefaults);
                    this.removeItem('equivalentRange', listOfDefaults);
                    this.addOrRemovePartitioning();
                    Editables.setEditability(Editables.equivalenceEdit, false);
                }
            },
            setRestatability: function(value) {
                Defaults.restatability = value;
            },
            setIdempotency: function(value) {
                Defaults.idempotency = value;
            },
            setAssertiveness: function(value) {
                Defaults.assertiveness = value;
            },
            setChangingSuffix: function(value) {
                Defaults.changingSuffix = value;
            },
            setIdentitySuffix: function(value) {
                Defaults.identitySuffix = value;
            },
            setDefaultCapsule: function(value) {
                Defaults.encapsulation = value;
            },
            setDefaultIdentity: function(value) {
                Defaults.identity = value;
            },
            setDefaultChronon: function(value) {
                Defaults.chronon = value;
            },
            setDefaultNow: function(value) {
                Defaults.now = value;
            },
            setDefaultChangingRange: function(value) {
                Defaults.changingRange = value;
            },
            setDamping: function(value) {
                LayoutEngine.damping = (100 - value)/100;
                LayoutEngine.init();
            },
            setLongRangeEffect: function(value) {
                LayoutEngine.longRangeEffect = value/100;
                LayoutEngine.init();
            },
            setFuzziness: function(value) {
                LayoutEngine.fuzziness = value/100;
                LayoutEngine.init();
            },
            setNormalDistance: function(value) {
                LayoutEngine.normalDistance = 1 * value;
                LayoutEngine.init();
            },
            setStoppingVelocity: function(value) {
                LayoutEngine.stoppingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMinimumStartingVelocity: function(value) {
                LayoutEngine.minimumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMaximumStartingVelocity: function(value) {
                LayoutEngine.maximumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setPartitionFactor: function(value) {
                LayoutEngine.partitionFactor = 1 * value;
                LayoutEngine.init();
            },
            setStiffness: function(value) {
                LayoutEngine.stiffness = 1 * value;
                LayoutEngine.init();
            },
            setDatabase: function(value, convert) {
                if(convert && confirm("Would you like to convert data types to " + value + "?")) {
                    var original = Defaults.databaseTarget;
                    Defaults.databaseTarget = value;
                    var xml = DataTypeConverter.convert(Model.toXML(false), original, value);
                    Model.fromXML(xml);
                }
                Defaults.databaseTarget = value;
            },
            setMiniRate: function(value) {
                DrawingEngine.miniatureFramesBetweenRefresh = 1 * value;
            },
            toggleDebug: function () {
                DEBUG = !DEBUG;
                if(DEBUG) {
                    SVGLayer.show('debugPartitions');
                    SVGLayer.show('debug');
                }
                else {
                    SVGLayer.hide('debug');
                    SVGLayer.hide('debugPartitions');
                }
                DrawingEngine.start(false);
            },
            knotMass: null,
            knotCharge: null,
            anchorMass: null,
            anchorCharge: null,
            attributeMass: null,
            attributeCharge: null,
            tieMass: null,
            tieCharge: null,
            edgeMass: null,
            edgeCharge: null,
            setCalculations: function(value) {
                var listOfSettings = document.getElementById('listOfSettings');
                var calcsItem = document.getElementById('calcsItem');
                if(value === 'simple') {
                    LayoutEngine.layout = LayoutEngine.simpleLayout;
                    if(this.knotMass) listOfSettings.removeChild(this.knotMass);
                    if(this.knotCharge) listOfSettings.removeChild(this.knotCharge);
                    if(this.anchorMass) listOfSettings.removeChild(this.anchorMass);
                    if(this.anchorCharge) listOfSettings.removeChild(this.anchorCharge);
                    if(this.attributeMass) listOfSettings.removeChild(this.attributeMass);
                    if(this.attributeCharge) listOfSettings.removeChild(this.attributeCharge);
                    if(this.tieMass) listOfSettings.removeChild(this.tieMass);
                    if(this.tieCharge) listOfSettings.removeChild(this.tieCharge);
                    if(this.edgeMass) listOfSettings.removeChild(this.edgeMass);
                    if(this.edgeCharge) listOfSettings.removeChild(this.edgeCharge);
                    this.knotMass = null;
                    this.knotCharge = null;
                    this.anchorMass = null;
                    this.anchorCharge = null;
                    this.attributeMass = null;
                    this.attributeCharge = null;
                    this.tieMass = null;
                    this.tieCharge = null;
                    this.edgeMass = null;
                    this.edgeCharge = null;
                }
                else if (value === 'complex') {
                    LayoutEngine.layout = LayoutEngine.complexLayout;
                    this.knotMass = document.createElement('li');
                    this.knotCharge = document.createElement('li');
                    this.anchorMass = document.createElement('li');
                    this.anchorCharge = document.createElement('li');
                    this.attributeMass = document.createElement('li');
                    this.attributeCharge = document.createElement('li');
                    this.tieMass = document.createElement('li');
                    this.tieCharge = document.createElement('li');
                    this.edgeMass = document.createElement('li');
                    this.edgeCharge = document.createElement('li');
                    var knotMassInput = document.createElement('input');
                    var knotChargeInput = document.createElement('input');
                    var anchorMassInput = document.createElement('input');
                    var anchorChargeInput = document.createElement('input');
                    var attributeMassInput = document.createElement('input');
                    var attributeChargeInput = document.createElement('input');
                    var tieMassInput = document.createElement('input');
                    var tieChargeInput = document.createElement('input');
                    var edgeMassInput = document.createElement('input');
                    var edgeChargeInput = document.createElement('input');
                    knotMassInput.setAttribute('type', 'number');
                    knotChargeInput.setAttribute('type', 'number');
                    anchorMassInput.setAttribute('type', 'number');
                    anchorChargeInput.setAttribute('type', 'number');
                    attributeMassInput.setAttribute('type', 'number');
                    attributeChargeInput.setAttribute('type', 'number');
                    tieMassInput.setAttribute('type', 'number');
                    tieChargeInput.setAttribute('type', 'number');
                    edgeMassInput.setAttribute('type', 'number');
                    edgeChargeInput.setAttribute('type', 'number');
                    knotMassInput.setAttribute('step', '0.1');
                    knotChargeInput.setAttribute('step', '0.1');
                    anchorMassInput.setAttribute('step', '0.1');
                    anchorChargeInput.setAttribute('step', '0.1');
                    attributeMassInput.setAttribute('step', '0.1');
                    attributeChargeInput.setAttribute('step', '0.1');
                    tieMassInput.setAttribute('step', '0.1');
                    tieChargeInput.setAttribute('step', '0.1');
                    edgeMassInput.setAttribute('step', '0.1');
                    edgeChargeInput.setAttribute('step', '0.1');
                    knotMassInput.value = NodeType.mass[NodeType.KNOT];
                    knotChargeInput.value = NodeType.charge[NodeType.KNOT];
                    anchorMassInput.value = NodeType.mass[NodeType.ANCHOR];
                    anchorChargeInput.value = NodeType.charge[NodeType.ANCHOR];
                    attributeMassInput.value = NodeType.mass[NodeType.ATTRIBUTE];
                    attributeChargeInput.value = NodeType.charge[NodeType.ATTRIBUTE];
                    tieMassInput.value = NodeType.mass[NodeType.TIE];
                    tieChargeInput.value = NodeType.charge[NodeType.TIE];
                    edgeMassInput.value = NodeType.mass[NodeType.EDGE];
                    edgeChargeInput.value = NodeType.charge[NodeType.EDGE];
                    knotMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.KNOT] = 1 * this.value; }, false);
                    knotChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.KNOT] = 1 * this.value; }, false);
                    anchorMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.ANCHOR] = 1 * this.value; }, false);
                    anchorChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.ANCHOR] = 1 * this.value; }, false);
                    attributeMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.ATTRIBUTE] = 1 * this.value; }, false);
                    attributeChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.ATTRIBUTE] = 1 * this.value; }, false);
                    tieMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.TIE] = 1 * this.value; }, false);
                    tieChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.TIE] = 1 * this.value; }, false);
                    edgeMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.EDGE] = 1 * this.value; }, false);
                    edgeChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.EDGE] = 1 * this.value; }, false);
                    this.knotMass.appendChild(knotMassInput);
                    this.knotCharge.appendChild(knotChargeInput);
                    this.anchorMass.appendChild(anchorMassInput);
                    this.anchorCharge.appendChild(anchorChargeInput);
                    this.attributeMass.appendChild(attributeMassInput);
                    this.attributeCharge.appendChild(attributeChargeInput);
                    this.tieMass.appendChild(tieMassInput);
                    this.tieCharge.appendChild(tieChargeInput);
                    this.edgeMass.appendChild(edgeMassInput);
                    this.edgeCharge.appendChild(edgeChargeInput);
                    this.knotMass.appendChild(document.createTextNode(' Knot mass'));
                    this.knotCharge.appendChild(document.createTextNode(' Knot charge'));
                    this.anchorMass.appendChild(document.createTextNode(' Anchor mass'));
                    this.anchorCharge.appendChild(document.createTextNode(' Anchor charge'));
                    this.attributeMass.appendChild(document.createTextNode(' Attribute mass'));
                    this.attributeCharge.appendChild(document.createTextNode(' Attribute charge'));
                    this.tieMass.appendChild(document.createTextNode(' Tie mass'));
                    this.tieCharge.appendChild(document.createTextNode(' Tie charge'));
                    this.edgeMass.appendChild(document.createTextNode(' Edge mass'));
                    this.edgeCharge.appendChild(document.createTextNode(' Edge charge'));
                    listOfSettings.insertBefore(this.edgeCharge, calcsItem);
                    listOfSettings.insertBefore(this.edgeMass, calcsItem);
                    listOfSettings.insertBefore(this.tieCharge, calcsItem);
                    listOfSettings.insertBefore(this.tieMass, calcsItem);
                    listOfSettings.insertBefore(this.attributeCharge, calcsItem);
                    listOfSettings.insertBefore(this.attributeMass, calcsItem);
                    listOfSettings.insertBefore(this.anchorCharge, calcsItem);
                    listOfSettings.insertBefore(this.anchorMass, calcsItem);
                    listOfSettings.insertBefore(this.knotCharge, calcsItem);
                    listOfSettings.insertBefore(this.knotMass, calcsItem);
                }
            }
        };

        var ControlButtons = {
            playPauseButton: null,
            nudgeButton: null,
            undoButton: null,
            redoButton: null,
            zoomInButton: null,
            zoomOutButton: null,
            zoomFactor: 1.75,
            init: function() {
                this.playPauseButton = document.getElementById('playpause');
                this.undoButton = document.getElementById('undo');
                this.redoButton = document.getElementById('redo');
                this.zoomInButton = document.getElementById('zoomin');
                this.zoomOutButton = document.getElementById('zoomout');

                // rebinding
                this.togglePlayPause = this.togglePlayPause.bind(this);
                this.undo = this.undo.bind(this);
                this.redo = this.redo.bind(this);
                this.zoomIn = this.zoomIn.bind(this);
                this.zoomOut = this.zoomOut.bind(this);

                this.playPauseButton.addEventListener('click', this.togglePlayPause, false);
                this.undoButton.addEventListener('click', this.undo, false);
                this.redoButton.addEventListener('click', this.redo, false);
                this.zoomInButton.addEventListener('click', this.zoomIn, false);
                this.zoomOutButton.addEventListener('click', this.zoomOut, false);
            },
            togglePlayPause: function (event) {
                if(DrawingEngine.running) {
                    DrawingEngine.stop();
                    this.setPlayState();
                }
                else if (LayoutEngine.equilibrium) {
                    this.invalidateLayout();
                }
                else {
                    DrawingEngine.start(false);
                    this.setPauseState();
                }
            },
            setUndoLevels: function(numberOfLevels) {
                var undos = '';
                if(numberOfLevels)
                    undos = ' (' + numberOfLevels + ')';
                this.undoButton.firstChild.nodeValue = 'Undo' + undos;
            },
            setRedoLevels: function(numberOfLevels) {
                var redos = '';
                if(numberOfLevels)
                    redos = ' (' + numberOfLevels + ')';
                this.redoButton.firstChild.nodeValue = 'Redo' + redos;
            },
            undo: function() {
                Model.undoState();
                DrawingEngine.start(false);
            },
            redo: function() {
                Model.redoState();
                DrawingEngine.start(false);
            },
            setPlayState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Play';
                this.playPauseButton.className = 'pausing';
            },
            setPauseState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Pause';
                this.playPauseButton.className = 'playing';
            },
            invalidateLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    Model.visibleNodes[i].start();
                }
                DrawingEngine.start(true);
            },
            doZoom: function (zoom) {
                var w = SVG.viewBox.baseVal.width;
                var h = SVG.viewBox.baseVal.height;
                var dx = w * (1-zoom)/2;
                var dy = h * (1-zoom)/2;
                SVG.viewBox.baseVal.x += dx;
                SVG.viewBox.baseVal.y += dy;
                SVG.viewBox.baseVal.width = w * zoom;
                SVG.viewBox.baseVal.height = h * zoom;
                DrawingEngine.start(false);
            },
            zoomIn: function (event) {
                this.doZoom(1/this.zoomFactor);
            },
            zoomOut: function (event) {
                this.doZoom(this.zoomFactor);
            }
        };

        function Layer(graph) {
            this.graph = graph;
            this.layers = [];
        }
        Layer.prototype = {
            graph: null,
            layers: null,
            addLayer: function(name) {
                var layer = document.createElementNS(SVGNS, 'g');
                layer.setAttributeNS(null, 'id', name);
                this.graph.appendChild(layer);
                this.layers.push(name);
                this[name] = layer;
            },
            show: function(name) {
                var after;
                for(var i = this.layers.indexOf(name) + 1; i < this.layers.length; i++) {
                    after = this.layers[i];
                    if(this.isShowing(after))
                        break;
                }
                if(i < this.layers.length) {
                    this.graph.insertBefore(this[name], this[after]);
                }
                else {
                    this.graph.appendChild(this[name]);
                }
            },
            isShowing: function(name) {
                return this.graph.contains(this[name]);
            },
            hide: function(name) {
                if(this.isShowing(name))
                    this.graph.removeChild(this[name]);
            },
            clear: function(name) {
                var layer = this[name];
                while(layer.firstChild) {
                    layer.removeChild(layer.firstChild);
                }
            },
            clearAll: function() {
                var l = this.layers.length;
                while(l--) {
                    this.clear(this.layers[l]);
                }
            }
        };

        // make sure our init function is called when the page is loaded
        window.onload = function() {
            init(this);
        };

        // implementation of our init function
        function init(window) {
            // another disclaimer for the testing versions
            if(!RELEASE) {
                alert(
                    '----------- DISCLAIMER -----------\n' +
                    'Please note that this is a test version.\n' +
                    'It should not be used for production \n' +
                    'work. Report bugs found in our issue \n' +
                    'tracking system, to which a link can \n' +
                    'be found under the Help/About menu.\n' +
                    '----------- DISCLAIMER -----------'
                );
                document.getElementById("disclaimer").style.display = "block";
            }
            // set values in the settings and defaults input fields
            Settings.loadSettings(window.localStorage);

            // find any parameters passed in the url
            var gets = window.location.search.substring(1);
            var pair, pairs = gets.split('&');
            for(var i = 0; pair = pairs[i]; i++) {
              pair = pairs[i].split('=');
              PARAMETERS[pair[0]] = pair[1];
            }

            // assign event handlers to buttons
            ControlButtons.init();
            LayoutEngine.init();

            // set the global svg and graph variable
            SVG = document.getElementById("graph");
            SVG.viewBox.baseVal.x = 0;
            SVG.viewBox.baseVal.y = 0;
            SVG.viewBox.baseVal.width = window.innerWidth;
            SVG.viewBox.baseVal.height = window.innerHeight;

            // add layers to the SVG
            SVGLayer = new Layer(SVG);
            SVGLayer.addLayer('debugPartitions');
            SVGLayer.addLayer('debug');
            SVGLayer.addLayer('edges');
            SVGLayer.addLayer('nodes');
            SVGLayer.addLayer('names');
            SVGLayer.hide('names');
            SVGLayer.hide('debug');
            SVGLayer.hide('debugPartitions');

            // some inherited properties
            SVGLayer.edges.style.stroke = '#000';
            SVGLayer.edges.style.strokeWidth = '1px';
            SVGLayer.edges.style.fill = 'none';
            SVGLayer.debug.style.stroke = '#fcc';
            SVGLayer.debug.style.strokeWidth = '7px';
            SVGLayer.debug.style.strokeLinecap = 'round';
            SVGLayer.debugPartitions.style.fill = 'fff8f8';
            SVGLayer.debugPartitions.style.stroke = 'f4ebeb';
            SVGLayer.debugPartitions.style.strokeWidth = LayoutEngine.fuzz;
            SVGLayer.names.setAttributeNS(null, 'class', 'label');

            // set up "global" event handlers
            var wheel = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
                        document.onmousewheel !== undefined ? "mousewheel" :
                        "DOMMouseScroll";
            SVG.addEventListener(wheel, EventHandler.zoom, false);
            SVG.addEventListener('mousedown', EventHandler.preparePanning, false);

            // set up the miniature navigation
            NAV = document.getElementById("minigraph");
            NAV.addEventListener('mousedown', EventHandler.prepareNavigation, false);

            // add layers to the NAV
            NAVLayer = new Layer(NAV);
            NAVLayer.addLayer('edges');
            NAVLayer.addLayer('nodes');
            NAVLayer.addLayer('viewport');

            // some inherited properties
            NAVLayer.edges.style.stroke = '#000';
            NAVLayer.edges.style.strokeWidth = '1px';
            NAVLayer.edges.style.fill = 'none';

            DrawingEngine.init();
            // load previous scale and transform
            DrawingEngine.loadSettings(window.localStorage);

            // handle resizing
            window.addEventListener('resize', EventHandler.resize, false);

            // load url or previous model, if any
            var model;
            if(PARAMETERS.id) {
                Actions.loadModelFromCloud(PARAMETERS.id, null, 'public', null, null);
            }
            else if(model = window.localStorage.getItem("model")) {
                Model.fromXML(new DOMParser().parseFromString(model, 'text/xml'));
                Model.id = window.localStorage.getItem("modelId");
                Model.name = window.localStorage.getItem("modelName");
                Model.scope = window.localStorage.getItem("modelScope");
                Model.keywords = window.localStorage.getItem("modelKeywords");
                Model.description = window.localStorage.getItem("modelDescription");
            }
            else
                Actions.loadFromURL('example.xml');

            Actions.checkCloudConnectionStatus(false);

            // start the engine and let's go
            DrawingEngine.start(true);
        }

        // make sure our exit function is called when the page is unloaded
        window.onbeforeunload = function() {
            if(ASKBEFOREUNLOAD)
                return "Are you absolutely sure you want to leave?\nAny unsaved changes will be lost!";
            else
                ASKBEFOREUNLOAD = true;
        };

        window.onunload = function() {
            save(this, false);
        };

        function save(window, popup) {
            window.localStorage.clear();
            var xml = new XMLSerializer().serializeToString(Model.toXML(false));
            if(xml)
                window.localStorage.setItem("model", xml);
            if(Model.id)
                window.localStorage.setItem("modelId", Model.id);
            if(Model.name)
                window.localStorage.setItem("modelName", Model.name);
            if(Model.scope)
                window.localStorage.setItem("modelScope", Model.scope);
            if(Model.keywords)
                window.localStorage.setItem("modelKeywords", Model.keywords);
            if(Model.description)
                window.localStorage.setItem("modelDescription", Model.description);
            Settings.storeSettings(window.localStorage);
            DrawingEngine.storeSettings(window.localStorage);
            if(popup)
                alert("The model and settings are now saved in the browser cache.");
        }

        // -->
    </script>
</head>
<body>
    <svg id="graph"
         class="unselectable"
         xmlns="http://www.w3.org/2000/svg"
         version="1.1"
         xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs id="graphics">
            <marker id="arrowhead"
                    viewBox="0 0 10 10" refX="0" refY="5"
                    markerUnits="strokeWidth"
                    markerWidth="4" markerHeight="3"
                    orient="auto" fill="#fcc">
                <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <style type="text/css">
                .label {
                    font-size:          8pt;
                    font-family:        "Open Sans", "Verdana", "Helvetica Neue", sans-serif;
                    font-weight:        normal;
                    text-anchor:        left;
                    dominant-baseline:  middle;
                    fill:               #000;
                }
                .role {
                    font-style:         italic;
                    stroke:             none;
                    fill:               #000;
                }
                .stop {
                    font-size:          6pt;
                    font-family:        "Source Code Pro", "Consolas", "Andale Mono", monospace;
                    font-weight:        bold;
                    text-anchor:        middle;
                    dominant-baseline:  bottom;
                    fill:               #fff;
                }
                .bad {
                    fill:               #e00;
                }
                .end {
                    text-anchor:        end;
                }
            </style>
            <g id="knot" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <rect width="20" height="20" rx="5" ry="5" transform="translate(-10, -10)"/>
            </g>
            <g id="anchor" style="fill:#b55;">
                <rect width="20" height="20" transform="translate(-10, -10)"/>
            </g>
            <g id="anchor_imploded" style="fill:#633;">
                <path d="M 0 0 Q 12 4 24 0 Q 20 12 24 24 Q 12 20 0 24 Q 4 12 0 0" transform="translate(-12, -12)"/>
            </g>
            <g id="tie" style="fill:#a8a8a8;">
                <rect width="20" height="20" transform="rotate(45) translate(-10, -10)"/>
            </g>
            <g id="tie_historized">
                <rect width="22" height="22" transform="rotate(45) translate(-11, -11)" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;"/>
                <rect width="14" height="14" transform="rotate(45) translate(-7, -7)" style="fill:#a8a8a8;"/>
            </g>
            <g id="attribute" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <circle r="10"/>
            </g>
            <g id="attribute_historized" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <circle r="12"/>
                <circle r="7"/>
            </g>
            <g id="highlight" style="stroke:#ede5e5; stroke-width:10px; fill:#fff;">
                <circle r="30"/>
            </g>
            <g id="selection" style="fill:#ede5e5;">
                <circle r="30"/>
                <circle r="30" style="stroke:#000; stroke-width:1px;"/>
            </g>
            <g id="fixation" style="fill:#000;">
                <circle r="1.5"/>
            </g>
            <g id="bubble" style="fill:#f9f8f7; stroke:none;">
                <circle r="8"/>
            </g>
            <g id="one" style="stroke:#544; stroke-width:1px;">
                <line x1="0" y1="-3" x2="0" y2="3"/>
            </g>
            <g id="many" style="stroke:#544; stroke-width:1px;">
                <line x1="-3" y1="-3" x2="3" y2="-3"/>
                <line x1="-3" y1="0" x2="3" y2="0"/>
                <line x1="-3" y1="3" x2="3" y2="3"/>
            </g>
        </defs>
        <!-- layers are appended here -->
    </svg>

    <div id="disclaimer" class="unselectable">
        THIS<br/>
        IS A<br/>
        TEST<br/>
        VERSION
    </div>

    <div id="header" class="unselectable">
        <div id="file" class="menu">File
            <ul class="submenu">
                <li title="Discards the current model and starts a new model with a minimal setup, a single anchor." onclick="Model.setupMinimal(true)">New model...</li>
                <li title="Load a publicly stored model from the Google Cloud connection." onclick="Actions.listModelsInCloud('public')">Load public model from cloud...</li>
                <li title="Load a privately stored model from the Google Cloud connection. Requires that you log in to your Google account." onclick="Actions.listModelsInCloud('private')">Load private model from cloud...</li>
                <li title="Save the current model in the Google Cloud, either publicly or privately. If it already exists you will be given the option to overwrite the old model." onclick="Actions.saveModelInCloud(true)">Save model in cloud...</li>
                <li><i>Load model from local file:</i></li>
                <li title="Load a model from an XML file accessible from your local computer."><input type="file" class="fileSelect" onchange="FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this);"/></li>
                <li title="Save model XML definition and settings in browser cache. This is also done automatically when leaving this page." onclick="save(window, true)">Save settings in browser cache...</li>
                <li title="Save model XML definition to disk." onclick="Actions.saveToDisk(new XMLSerializer().serializeToString(Model.toXML(false)), 'xml')">Save model to local file...</li>
                <li title="Save model Scalable Vector Graphics file to disk." onclick="Actions.saveToDisk(new XMLSerializer().serializeToString(SVG), 'svg')">Save SVG to local file...</li>
                <li title="Sends an email with the XML description of the model to a specified recipient." onclick="Actions.createEmail(new XMLSerializer().serializeToString(Model.toXML(false)))">Send model by email...</li>
                <li title="Loads an example model based on a business managing actors that perform programs on different stages." onclick="Actions.loadFromURL('example.xml', true)">Load example model</li>
            </ul>
        </div>

        <div id="actions" class="menu">Layout
            <ul class="submenu">
                <li title="Toggle whether names should be visible in the modeler or not." onclick="Actions.toggleNames()">Toggle names</li>
                <li title="Toggle whether full names including mnemonics or short names excluding mnemonics should be used." onclick="Actions.toggleMnemonics()">Toggle mnemonics</li>
                <li title="Toggle whether coloring of edges should be visible or not." onclick="Actions.toggleColoring()">Toggle coloring</li>
                <li title="Release all fixed nodes and fixate all released nodes." onclick="Actions.toggleFixation()">Toggle fixation</li>
                <li title="Release all fixed nodes." onclick="Actions.releaseAll()">Release all fixed</li>
                <li title="Hide attributes from anchors, and knots from both anchors and ties, in order to get a better overview of larger models." onclick="Actions.implodeAll()">Implode all</li>
                <li title="Unhide all hidden attributes and knots." onclick="Actions.explodeAll()">Explode all</li>
                <li title="Lost in your model? Resetting the view will center your model on screen and set the zoom back to its default value." onclick="Actions.resetZoom();Actions.centerModel()">Reset view</li>
                <li title="Having trouble finding a good layout? This will randomize the locations of all items and let the algorithms do the work." onclick="Actions.randomizeLayout()">Randomize layout</li>
            </ul>
        </div>

        <div id="generate" class="menu">Generate
            <ul class="submenu">
                <li title="Selects the target database for the generated SQL code.">
                    <select id="database" onchange="Settings.setDatabase(this.value, true)">
                        <option value="SQLServer" selected="selected">Microsoft SQL Server</option>
                        <option value="Oracle">Oracle</option>
                    </select> Target database
                </li>
                <li title="Selects the version of the naming convention to use for the generated code.">
                    <select id="naming" onchange="Settings.setNaming(this.value)">
                        <option value="original">Original</option>
                        <option value="improved" selected="selected">Improved</option>
                    </select> Naming convention
                </li>
                <li title="Selects if the generated code should be monotemporal (only changing time) or bitemporal (both changing and recording time).">
                    <select id="temporalization" onchange="Settings.setTemporalization(this.value)">
                        <option value="uni" selected="selected">Unitemporal</option>
                        <option value="crt">Concurrent-reliance-temporal</option>
                        <!-- hidden until ported to sisula
                        <option value="bi">Bitemporal</option>
                        -->
                    </select> Temporalization
                </li>
                <li title="Selects if the generated code should contain a metadata reference or not."><input id="metadataUsage" class="inputDefaults" type="checkbox" onchange="Settings.setMetadataUsage(this.checked ? 'true' : 'false')"/> Use metadata</li>
                <li title="Selects if the generated code should contain business views or not."><input id="businessViews" class="inputDefaults" type="checkbox" onchange="Settings.setBusinessViews(this.checked ? 'true' : 'false', true)"/> Use business views</li>
                <li title="Selects if equivalence should be allowed. Multiple values can be marked as having the same meaning, which for example is useful for multilingualism or multitenancy."><input id="equivalence" class="inputDefaults" type="checkbox" onchange="Settings.setEquivalence(this.checked ? 'true' : 'false', true)"/> Use equivalence</li>
                <li title="Generate SQL code for implementation of a model in a relational database." onclick="new CodePopover(Actions.preformat(Sisulator.sisulate(Model.toXML(true), Actions.getDirective(), document)), true)"> SQL code</li>
                <li title="Generate a portable and compact XML representation of your model, including information about the graphical layout." onclick="new CodePopover(Actions.transform(Model.toXML(false), 'xml2html.xsl', document), false)"> XML code</li>
                <li title="Generate a JSON string to implement the model in a program." onclick="new CodePopover(Actions.preformat(Actions.jsonify(Model.toXML(false))), true)"> JSON string</li>
                <li title="Generate a URL for a public model that can be shared over social media or through email." onclick="Actions.generateURL()"> URL for sharing</li>
                <li title="Generate an HTML legend that describes the items in your model." onclick="Actions.generateHTML()"> HTML documentation</li>
                <li title="Generate a bitmap image of the view currently shown on screen." onclick="window.open(Actions.toPNGDataURL(SVG), '_newtab')">PNG screenshot</li>
                <li title="Generate a vector image of the entire model." onclick="window.open(Actions.toSVGDataURL(SVG), '_newtab')">SVG screenshot</li>
            </ul>
        </div>

        <div id="controls">
            <div id="playpause">Pause</div>
            <div id="zoomin">Zoom+</div>
            <div id="zoomout">Zoom-</div>
            <div id="redo">Redo</div>
            <div id="undo">Undo</div>
        </div>

        <div id="search">
            <input id="searchFilter" type="text" placeholder=" search filter " title="Search the model for the given (sub)string." onfocus="Actions.stopKeyboardEvents()" onblur="Actions.populateSelector(document.getElementById('nodeSelector'), this.value)"/>
            <select id="nodeSelector" title="Focus model on the selected node." onmouseover="Actions.populateSelector(this, document.getElementById('searchFilter').value)" onchange="Actions.selectNode(this.value)">
                <option value="none" selected="selected">None selected</option>
            </select>
        </div>

        <div id="about" class="menu">Help
            <ul class="submenu">
                <li title="Takes you to a page containing a number of video tutorials explaining how to use the modeling tool." onclick="new URLPopover('http://www.anchormodeling.com/?page_id=186')">Tutorials</li>
                <li title="Shows a page with information about who coded the modeling tool, where it can be found, and the available keyboard shortcuts." onclick="new URLPopover('about.html')">About</li>
            </ul>
        </div>

        <div id="defaults" class="menu">Defaults
            <ul id="listOfDefaults" class="submenu">
                <li title="The default changing time (versions) 'data type' for newly created and historized items."><input id="defaultChangingRange" class="inputDefaults" type="text" onblur="Settings.setDefaultChangingRange(this.value)"/> Changing time range</li>
                <li title="The suffix used for the columns that store changing time (versions)."><input id="changingSuffix" class="inputDefaults" type="text" onblur="Settings.setChangingSuffix(this.value)"/> Changing time suffix</li>
                <li title="The suffix used for the columns that store checksums."><input id="checksumSuffix" class="inputDefaults" type="text" onblur="Settings.setChecksumSuffix(this.value)"/> Checksum suffix</li>
                <li title="The default 'schema' to use for new items."><input id="defaultCapsule" class="inputDefaults" type="text" onblur="Settings.setDefaultCapsule(this.value)"/> Capsule</li>
                <li title="The default 'data type' to use for identity columns."><input id="defaultIdentity" class="inputDefaults" type="text" onblur="Settings.setDefaultIdentity(this.value)"/> Identity</li>
                <li title="The suffix used for the columns that store identities."><input id="identitySuffix" class="inputDefaults" type="text" onblur="Settings.setIdentitySuffix(this.value)"/> Identity suffix</li>
                <li title="The smallest common time type of all those used in the model."><input id="defaultChronon" class="inputDefaults" type="text" onblur="Settings.setDefaultChronon(this.value)"/> Chronon</li>
                <li title="How to get current, UTC or desired timestamping time from the database."><input id="defaultNow" class="inputDefaults" type="text" onblur="Settings.setDefaultNow(this.value)"/> Now</li>
                <li id="metadataSettingsBeforeHere" title="Default for new items. Restatable items can store the exact same value for consecutive changing times. Unchecking this will introduce a constraint preventing restatements."><input id="restatability" class="inputDefaults" type="checkbox" onchange="Settings.setRestatability(this.checked ? 'true' : 'false')"/> Restatability</li>
                <li title="Default for new items. Idempotent items discard any attempt to insert or update a value that is identical to the latest one stored with respect to changing time."><input id="idempotency" class="inputDefaults" type="checkbox" onchange="Settings.setIdempotency(this.checked ? 'true' : 'false')"/> Idempotency</li>
                <li id="crtSettingsBeforeHere" title="Resets all settings in this menu to their default values." onclick="Settings.resetDefaults(true)">Reset defaults to their default values</li>
            </ul>
        </div>

        <!-- TODO: focus gets "stuck" on the input fields below sometimes, annoying! -->
        <div id="settings" title="Expert settings" class="menu">Settings
            <ul id="listOfSettings" class="submenu">
                <li title="Damping can be likened to friction and is needed in order to slow down the movement of the nodes."><input id="damping" type="number" min="0" max="99" step="1" onblur="Settings.setDamping(this.value)"/> % Damping</li>
                <li title="The normal distance is the distance in pixels two nodes would be separated by if they were the only nodes in the graph."><input id="normalDistance" type="number" min="10" max="90" step="5" onblur="Settings.setNormalDistance(this.value)"/> px Normal distance</li>
                <li title="Any node whose velocity is smaller than this number is assumed to have stopped."><input id="stoppingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setStoppingVelocity(this.value)"/> px/s Stopping velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a small graph."><input id="minimumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMinimumStartingVelocity(this.value)"/> px/s Minimum starting velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a large graph."><input id="maximumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMaximumStartingVelocity(this.value)"/> px/s Maximum starting velocity</li>
                <li title="The size of space partitions in number of normal distances."><input id="partitionFactor" type="number" min="0" max="100" step="1" onblur="Settings.setPartitionFactor(this.value)"/> Partition size</li>
                <li title="The 'fuzziness' within which the size of the partitions are altered."><input id="fuzziness" type="number" min="0" max="100" step="1" onblur="Settings.setFuzziness(this.value)"/> % Fuzziness</li>
                <li title="The effect of the force from other partitions on nodes in the current partition."><input id="longRangeEffect" type="number" min="0" max="100" step="1" onblur="Settings.setLongRangeEffect(this.value)"/> % Long range effect</li>
                <li title="The stiffness of the edges control whether they behave like rubber bands or steel wires."><input id="stiffness" type="number" min="0" max="10" step="0.1" onblur="Settings.setStiffness(this.value)"/> Edge stiffness factor</li>
                <li title="The number of frame redraws needed in the large SVG to trigger a redraw of the miniature."><input id="miniatureFramesBetweenRefresh" type="number" min="1" max="99" step="1" onblur="Settings.setMiniRate(this.value)"/> Miniature refresh interval</li>
                <li title="Switching on advanced calculations lets you set more properties of nodes and edges, but at the cost of some performance." id="calcsItem">
                    <select id="calculations" onchange="Settings.setCalculations(this.value)">
                        <option value="simple" selected="selected">Simplified</option>
                        <option value="complex">Adjustable</option>
                    </select> &nbsp;Calculations
                </li>
                <li title="Resets all settings in this menu to their default values." onclick="Settings.resetSettings(true)">Reset settings to their default values</li>
                <li title="In debug mode force vectors will be drawn in the graph." onclick="Settings.toggleDebug()">Toggle debug</li>
            </ul>
        </div>
    </div>

    <!-- shows a navigatable miniature of the model -->
    <div id="miniature">
        <svg id="minigraph"
             class="unselectable"
             xmlns="http://www.w3.org/2000/svg"
             version="1.1"
             xmlns:xlink="http://www.w3.org/1999/xlink"
             viewBox="0 0 1 1"
             preserveAspectRatio="xMinYMin slice">
            <defs id="nav_graphics">
                <g id="nav_knot" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <rect width="20" height="20" rx="5" ry="5" transform="translate(-10, -10)"/>
                </g>
                <g id="nav_anchor" style="fill:#b55;">
                    <rect width="20" height="20" transform="translate(-10, -10)"/>
                </g>
                <g id="nav_tie" style="fill:#a8a8a8;">
                    <rect width="20" height="20" transform="rotate(45) translate(-10, -10)"/>
                </g>
                <g id="nav_tie_historized">
                    <rect width="22" height="22" transform="rotate(45) translate(-11, -11)" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;"/>
                    <rect width="14" height="14" transform="rotate(45) translate(-7, -7)" style="fill:#a8a8a8;"/>
                </g>
                <g id="nav_attribute" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <circle r="10"/>
                </g>
                <g id="nav_attribute_historized" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <circle r="12"/>
                    <circle r="7"/>
                </g>
            </defs>
        </svg>
    </div>

    <div id="logotype" class="unselectable">
        <img width="100%" src="Anchor.svg" type="image/svg+xml"/>
    </div>
    <div id="cloud" class="unselectable" onclick="Actions.checkCloudConnectionStatus(true)">
        <!-- filled dynamically -->
    </div>
    <div id="model" class="unselectable">
        <!-- filled dynamically -->
    </div>
</body>
</html>