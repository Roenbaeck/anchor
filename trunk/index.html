<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Anchor Modeler</title>
    <style type="text/css">
    body {
        font:               75% georgia, sans-serif;
        line-height:        1.88889;
        color:              #000000;
        background:         #f9f8f7;
        overflow:           hidden;
        margin:             0;
        padding:            0;
    }

    .unselectable {
        user-select:        none;
        -moz-user-select:   none;
        -khtml-user-select: none;
    }

    .invisible {
        opacity:            0;
        z-index:            1000;
        position:           absolute;
        left:               0;
    }

    .editable:invalid {
        background-color:   #fbb;
    }

    .closebutton {
        display:            none;
        background-image:   url(deleteButton.png);
        position:           absolute;
        left:               -15px;
        top:                -15px;
        height:             30px;
        width:              30px;
        z-index:            14;
    }
    .closebutton:active {
        background-image:   url(deleteButtonPressed.png);
    }

    /* visible canvas - at the bottom of the visible layers */
    #canvas {
        position:           absolute;
        top:                0px;
        left:               0px;
        z-index:            1;
    }

    /* invisible canvas - at the very bottom */
    #shadow {
        position:           absolute;
        top:                0px;
        left:               0px;
        display:            none;
        z-index:            0;
    }

    /* minature canvas - positioned in the southeast corner */
    #miniature {
        position:           absolute;
        bottom:             40px;
        right:              42px;
        background-color:   rgba(255, 255, 255, 0.8);
        z-index:            2;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }

    /* context menu that pops up when editing */
    #contextMenu {
        position:           absolute;
        top:                0;
        left:               0;
        display:            block;
        background-color:   rgba(255, 255, 255, 0.8);
        color:              black;
        padding:            0;
        margin:             0;
        text-align:         left;
        border:             1px dotted black;
        z-index:            11;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    #contextMenu .items {
        margin:             15px 10px 5px 10px;
    }

    .toggler {
        font:               16px sans-serif;
        position:           absolute;
        margin:             0;
        padding:            0;
        border:             1px solid #555;
        width:              16px;
        height:             16px;
        z-index:            12;
    }
    .expanded {
        cursor:             nw-resize;
        left:               -1px;
        top:                -1px;
        background-color:   #f55;
    }
    .collapsed {
        cursor:             se-resize;
        left:               -3px;
        top:                -3px;
        background-color:   #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }
    .collapsed:hover {
        background-color:   #fa5;
    }

    /* is used in the code popover */
    #modalBackground {
        position:           absolute;
        top:                0;
        left:               0;
        background-color:   rgba(142, 128, 128, 0.5);
        margin:             0;
        padding:            0;
        overflow:           hidden;
        z-index:            10;
    }

    /* these classes style the xml representation */
    #codePopover {
        position:           relative;
        border:             3px solid black;
        top:                5%;
        margin:             auto;
        display:            table;
        background-color:   rgba(8, 0, 0, 0.8);
        box-shadow:         0px 10px 20px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #codePopover .closebutton {
        display:            inherit;
        position:           relative;
    }
    
    #content {
        position:           relative;
        margin-top:         -30px;
        text-align:         left;
        font:               125% Andale Mono, monospace;
        color:              white;
        padding:            15px 20px;
        overflow:           auto;
        background-color:   transparent;
        z-index:            12;
    }
    #content .tabs {
        visibility:         hidden;
    }
    #content .brackets {
        color:              white;
    }
    #content .elements {
        color:              #ffffc0;
    }
    #content .attributes {
        color:              #c0c0c0;
        font-weight:        bold;
    }
    #content .values {
        color:              #ffc0c0;
        font-style:         italic;
    }
    .preformatted {
        white-space:        pre;        
    }


    /* Menus and control buttons */
    ul, li {
		list-style-type:    none;
		margin:             0;
        padding:            0;
	}

    #header {
        font:               10pt georgia, sans-serif;
        position:           relative;
        margin:             0;
        padding:            0;
        top:                0;
        left:               0;
        height:             32px;
        display:            block;
        background-color:   rgba(212, 212, 212, 0.8);
        color:              black;
        border-bottom:      2px solid #fff;
        box-shadow:         0px 0px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 0px 10px rgba(0, 0, 0, 0.5);
        z-index:            7;
    }

    /* http://www.ie7nomore.com/fun/menu2/ */
    #actions, #settings {
        position:           absolute;
        display:            block;
        top:                0px;
        z-index:            8;
    }
    #actions {
        left:               8px;
        text-align:         left;
    }
    #settings {
        right:              8px;
        text-align:         right;
    }
    .menu {
        font:               10pt georgia, sans-serif;
        margin:             0;
        cursor:             pointer;
        list-style:         none;
    }
    .menu li {
        padding-left:       8px;
        padding-right:      8px;
        line-height:        32px;
    }
    .menu > li {
        display:            inline-block;
    }
    .submenu {
        opacity:            0;
        background-color:   rgba(212, 212, 212, 0.8);
        white-space:        nowrap;
        border:             2px solid #fff;
        box-shadow:         0px 5px 10px rgba(0, 0, 0, 0.5);
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
        z-index:            9;
    }
    .submenu li {
        height:             0;
        line-height:        25px;
        list-style-type:    none;
        margin:             0;
        padding-right:      8px;
        padding-left:       8px;
        text-align:         left;
    }
    .menu > li:hover .submenu, .menu > li.focus .submenu {
        opacity:            1;
    }
    .menu > li:hover .submenu li, .menu > li.focus .submenu li {
        height:             25px;
    }
    .submenu li:hover {
        color:              white;
        background-color:   rgba(128, 128, 128, 0.8);
        text-decoration:    none;
        text-shadow:        0px 0px 6px #555;
    }

    /* Flexible menu without images - taken from ie7nomore.com and modified */
    #controls {
        position:           absolute;
        top:                0px;
        left:               50%;
        margin-left:        -300px; /* half of the actual width */
        display:            block;
        z-index:            9;
    }
    #controls .playing {
        background-color:   #ffaa55;      
    }
    #controls .pausing {
        /* just go back to normal */
    }
    .control {
        cursor:             pointer;
        width:              600px;
        height:             32px;
        margin:             0;
        padding:            0;
        list-style:         none;
        display:            -moz-box;
        display:            -webkit-box;
        display:            box;
        -moz-box-orient:    horizontal;
        -webkit-box-orient: horizontal;
        box-orient:         horizontal;
    }
    .control li {
        -moz-box-flex :     1;
        -webkit-box-flex :  1;
        box-flex :          1;
        min-width:          65px; /* @bugfix : avoid jerky transition ending */
        padding:            8px 0 8px 20px;
        margin:             0;
        border-left:        0;
        background:         #bb5555;
        color:              #fff;
        text-decoration:    none;
        text-shadow:        0px 0px 6px #777;
        -moz-border-radius: 10px 0 / 40px 0;
        -webkit-border-radius: 10px 0 / 40px 0;
        border-radius:      10px 0 / 40px 0;
        -webkit-transition: .5s;
        -moz-transition:    .5s;
        transition:         .5s;
    }
    .control li:hover, .menu li:focus {
        background:         #ff7777;
        width:              20%; /* times number of menu items = 100% */
/*      This is buggy right now so removed until FF does smooth flexing
        -moz-box-flex :     2;
*/
        -webkit-box-flex :  2;
        box-flex :          2;
    }
    .control li + li {
        margin-left:        -50px;
    }
    
    </style>

    <script type="text/javascript">
        <!--
        // set to true to show debugging information
        var DEBUG = false;

        // frames per second - set low when debugging
        var FPS = 100;

        // draw the miniature every minirate frames
        var MINIRATE = 50;

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 30,
            // 4 percent damping (simulated friction)
            damping: 0.96,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // minimum starting velocity is a whole pixel
            minimumStartingVelocity: 1,
            // maximum starting velocity is higher (to remove "twitching" when few nodes are moving)
            maximumStartingVelocity: 5,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.00003703703704,
            // adjusts the size of the influence square by this factor
            influenceConstant: 4,
            // the stiffness of the edges
            stiffness: 3,
            // calculated as stiffness^2
            stiffnessBound: 9,
            // when the layout has reached equilibrium
            equilibrium: true,
            // the metric in use
            metric: null,
            // for some reason Math.abs is slower than this
            absolute: function(value) {
                return value < 0 ? -value : value;
            },

            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },
            // measures distance between two nodes
            distance: function(node, otherNode) {
                var d = this.metric(node.xPosition, node.yPosition, otherNode.xPosition, otherNode.yPosition);
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            // use the taxi cab metric for measuring distances
            manhattan: function(x1, y1, x2, y2) {
                return this.absolute(x2 - x1) + this.absolute(y2 - y1);
            },
            // use the euclidean metric for measuring distances
            euclidean: function(x1, y1, x2, y2) {
                return Math.sqrt(this.square(x2 - x1) + this.square(y2 - y1));
            },
            // x component of the repelling force formula
            xRepelling: function(node, otherNode) {
                return (node.xPosition - otherNode.xPosition)/this.square(this.distance(node, otherNode));
            },

            // y component of the repelling force formula
            yRepelling: function(node, otherNode) {
                return (node.yPosition - otherNode.yPosition)/this.square(this.distance(node, otherNode));
            },

            // x component of the attracting force formula
            xAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPosition - node.xPosition) * this.distance(node, otherNode);
            },

            // y component of the attracting force formula
            yAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPosition - node.yPosition) * this.distance(node, otherNode);
            },
            // create the square of influence
            createSquare: function(node, offset) {
                return {
                    xMin: node.xPosition - offset,
                    xMax: node.xPosition + offset,
                    yMin: node.yPosition - offset,
                    yMax: node.yPosition + offset
                };
            },
            // check if a node falls within the square of influence
            withinSquare: function(otherNode, square) {
                return  otherNode.xPosition >= square.xMin &&
                        otherNode.xPosition <= square.xMax &&
                        otherNode.yPosition >= square.yMin &&
                        otherNode.yPosition <= square.yMax;
            },

            // calculate all forces and change the velocity and position of the node
            layout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, curvature, square;
                var numberOfNodes = model.nodes.length;
                var numberOfStoppedNodes = 0;
                var startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;

                for(i = 0; node = model.nodes[i]; i++) {
                    square = this.createSquare(node, this.influenceConstant * this.normalDistance);
                    for(j = 0; otherNode = model.nodes[j]; j++) {
                        // not the same node
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode, square)) {
                                node.xVelocity += this.xRepelling(node, otherNode);
                                node.yVelocity += this.yRepelling(node, otherNode);
                            }
                        }
                        // the first iteration we count the number of stopped nodes
                        if(j == 0 && (!otherNode.moving || otherNode.fixed)) {
                            numberOfStoppedNodes++;
                        }
                    }
                    // bending force (straightens out edges)
                    if(node instanceof Edge) {
                        // update the control and center points
                        node.controlPoint.xPosition = 2 * node.xPosition - node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                        node.controlPoint.yPosition = 2 * node.yPosition - node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                        node.centerPoint.xPosition = node.node.xPosition + (node.otherNode.xPosition - node.node.xPosition) / 2;
                        node.centerPoint.yPosition = node.node.yPosition + (node.otherNode.yPosition - node.node.yPosition) / 2;
                        curvature = this.square(this.stiffness * this.distance(node.centerPoint, node.controlPoint)/this.distance(node.node, node.otherNode));
                        // safeguard
                        curvature = curvature > this.stiffnessBound ? this.stiffnessBound : curvature;
                        // flexure force moves the midway point toward the center point
                        node.xVelocity -= curvature * this.xRepelling(node, node.centerPoint);
                        node.yVelocity -= curvature * this.yRepelling(node, node.centerPoint);
                    }
                    // for all edges, add the attracting velocity
                    for(j = 0; edge = node.edges[j]; j++) {
                        node.xVelocity += this.xAttracting(node, edge)/node.edges.length;
                        node.yVelocity += this.yAttracting(node, edge)/node.edges.length;
                    }
                    // apply damping
                    node.xVelocity *= this.damping;
                    node.yVelocity *= this.damping;
                    node.velocity = this.absolute(node.xVelocity) + this.absolute(node.yVelocity);
                    // check to see if the node has stopped moving
                    if(node.velocity <= this.stoppingVelocity)
                        node.stop();
                    // the more nodes that have stopped, the larger the starting velocity must be
                    if(node.velocity >= this.minimumStartingVelocity + startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                        node.start();
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.fixed) {
                        this.equilibrium = false;
                        node.xPosition += node.xVelocity;
                        node.yPosition += node.yVelocity;
                    }
                    if(node.yPosition < model.topmostNode.yPosition)
                        model.topmostNode = node;
                    if(node.xPosition > model.rightmostNode.xPosition)
                        model.rightmostNode = node;
                    if(node.yPosition > model.bottommostNode.yPosition)
                        model.bottommostNode = node;
                    if(node.xPosition < model.leftmostNode.xPosition)
                        model.leftmostNode = node;
                }
            }
        };

        var UniqueColor = {
            // note that #000000 is reserved for the background and never assigned
            takenColors: {},
            formatColor: function(red, green, blue) {
                return '#' +
                        ('0' + red.toString(16)).slice(-2) +
                        ('0' + green.toString(16)).slice(-2) +
                        ('0' + blue.toString(16)).slice(-2);
            },
            reserveUniqueColor: function() {
                var r = Math.ceil(Math.random() * 255);
                var g = Math.ceil(Math.random() * 255);
                var b = Math.ceil(Math.random() * 255);
                var color = this.formatColor(r, g, b);
                if(this.takenColors[color] || (r + g + b) == 0)
                    return this.reserveUniqueColor();
                this.takenColors[color] = true;
                return color;
            },
            releaseUniqueColor: function(color) {
                delete this.takenColors[color];
            }
        };

        var Model = {
            nodes: [],
            edges: [],
            idToNode: [],
            shadowToNode: {},
            topmostNode: null,
            rightmostNode: null,
            bottommostNode: null,
            leftmostNode: null,
            version: -1,
            versions: [],
            empty: function() {
                this.nodes = [];
                this.edges = [];
                this.idToNode = [];
                this.shadowToNode = {};
                this.topmostNode = null;
                this.rightmostNode = null;
                this.bottommostNode = null;
                this.leftmostNode = null;
            },
            // TODO: We probably should have a maximum number of versions
            recordState: function() {
                this.version++;
                this.versions[this.version] = this.toXML();
                this.versions.length = this.version + 1;
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(0);
            },
            undoState: function() {
                this.version -= (this.version == 0 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            redoState: function() {
                this.version += (this.version == this.versions.length - 1 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            setupMinimal: function() {
                if(confirm("Are you sure you want to clear the current model?\nAny unsaved changes will be lost!")) {
                    this.empty();
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.reset();
                    this.addNode(new Anchor(DrawingEngine.canvas.width/2, DrawingEngine.canvas.height/2));
                    DrawingEngine.start(true);
                }
            },
            sort: function() {
                this.nodes.sort(function(a, b) {
                    if (a instanceof Edge)
                        return -1;
                    if (a instanceof Knot && !(b instanceof Edge))
                        return -1;
                    if (a instanceof Anchor && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    if (a instanceof Attribute && !(b instanceof Anchor) && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    return 1;
                });
            },
            addNode: function(node) {
                // add node at the end of the array
                if(node) {
                    this.nodes[this.nodes.length] = node;
                    this.sort();
                    this.idToNode[node.id] = node;
                    this.shadowToNode[node.shadowColor] = node;
                    if(this.topmostNode == null || node.yPosition < this.topmostNode.yPosition)
                        this.topmostNode = node;
                    if(this.rightmostNode == null || node.xPosition > this.rightmostNode.xPosition)
                        this.rightmostNode = node;
                    if(this.bottommostNode == null || node.yPosition > this.bottommostNode.yPosition)
                        this.bottommostNode = node;
                    if(this.leftmostNode == null || node.xPosition < this.leftmostNode.xPosition)
                        this.leftmostNode = node;
                    this.invalidateNode(node);
                }
            },
            removeNode: function(node) {
                UniqueColor.releaseUniqueColor(node.shadowColor);
                delete this.shadowToNode[node.shadowColor];
                delete this.idToNode[node.id];
                this.deleteElementFromArray(this.nodes, node);
            },
            addEdge: function(edge) {
                // the edge is also a node
                if(edge) {
                    this.addNode(edge);
                    this.edges[this.edges.length] = edge;                    
                }
            },
            removeEdge: function(edge) {
                this.deleteElementFromArray(this.edges, edge);
                this.deleteElementFromArray(edge.node.edges, edge);
                this.deleteElementFromArray(edge.otherNode.edges, edge);
                this.removeNode(edge);
            },
            getNodeFromShadow: function(shadow) {
                return this.shadowToNode[shadow];
            },
            getNodeFromId: function(id) {
                return this.idToNode[id];
            },
            deleteElementFromArray: function(array, element) {
                array.splice(array.indexOf(element), 1);
            },
            invalidateNode: function(node) {
                var square = LayoutEngine.createSquare(node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.nodes.length; i++)
                    if(LayoutEngine.withinSquare(this.nodes[i], square))
                        this.nodes[i].start();
            },
            toXML: function() {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                for(var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i].toXML(schema);
                    if(node != null)
                        schema.documentElement.appendChild(node);
                }
                return schema;
            },
            fromXML: function(xml) {
                if(xml) {
                    this.empty();
                    // add an id to elements that are missing that attribute and take the ids that are specified
                    var i, id, elements = xml.getElementsByTagName('*');
                    for (i = 0; i < elements.length; i++) {
                        if(elements[i].tagName in {knot:null, anchor:null, attribute:null, tie:null}) {
                            id = elements[i].getAttribute("id");
                            id = id ? UniqueIdentity.takeId(Number(id)) : UniqueIdentity.nextId();
                            elements[i].setAttribute("id", id);                            
                        }
                    }
                    // the order in which we add these are important (attributes create edges to anchors)
                    var knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addNode(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addNode(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addNode(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addNode(Tie.prototype.fromXML(ties[i]));
                }
            },
            walkFromNode: function(node, affectedNodes) {
                var i, j, k, edge, otherNode, otherEdge, anotherNode, otherNodeShouldAlsoBeErased;
                for(j = 0; edge = node.edges[j]; j++) {
                    otherNode = (node == edge.otherNode ? edge.node : edge.otherNode);
                    otherNodeShouldAlsoBeErased = true;
                    for(k = 0; otherEdge = otherNode.edges[k]; k++) {
                        anotherNode = (otherNode == otherEdge.otherNode ? otherEdge.node : otherEdge.otherNode);
                        otherNodeShouldAlsoBeErased &= affectedNodes.indexOf(anotherNode) >= 0;
                    }
                    if(otherNodeShouldAlsoBeErased && affectedNodes.indexOf(otherNode) < 0) {
                        affectedNodes.push(otherNode);
                        this.walkFromNode(otherNode, affectedNodes);
                    }
                }
            },
            walkFromEdge: function(edge, affectedNodes) {
                var j, k, otherEdge, anotherNode, potentialNode, potentialNodeShouldAlsoBeErased;
                var potentialNodes = [edge.node, edge.otherNode];
                for(j = 0; potentialNode = potentialNodes[j]; j++) {
                    if(potentialNode.edges.length == 1)
                        affectedNodes.push(potentialNode);
                }
            },
            erase: function(nodes) {
                var i, j, node, edge, affectedNodes = [], affectedEdges = [];
                for(i = 0; node = nodes[i]; i++) {
                    if(node instanceof Edge)
                        affectedEdges.push(node);
                    else
                        affectedNodes.push(node);
                }
                for(i = 0; node = affectedNodes[i]; i++)
                    this.walkFromNode(node, affectedNodes);
                for(i = 0; edge = affectedEdges[i]; i++)
                    this.walkFromEdge(edge, affectedNodes);
                for(i = 0; node = affectedNodes[i]; i++)
                    for(j = 0; edge = node.edges[j]; j++)
                        if(affectedEdges.indexOf(edge) < 0)
                            affectedEdges.push(edge);
                if(confirm("Are you sure you want to delete the following?\n--" +
                        affectedNodes.length + " nodes and " +
                        affectedEdges.length + " edges --\n" + affectedNodes.join('\n'))) {
                    for(i = 0; node = affectedNodes[i]; i++)
                        this.removeNode(node);
                    for(i = 0; edge = affectedEdges[i]; i++)
                        this.removeEdge(edge);
                    this.recordState();
                    CanvasEventHandler.clearSelection();
                    DrawingEngine.start(true);
                }
            },
            toggleKnotted: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot, edge;
                    if(nodes[i].knotted) {
                        for(var j = 0; edge = nodes[i].edges[j]; j++) {
                            if(edge.otherNode instanceof Knot) {
                                this.removeNode(edge.otherNode);
                                this.removeEdge(edge);
                            }
                        }
                        nodes[i].knotted = false;
                    }
                    else {
                        knot = new Knot(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 2 * LayoutEngine.normalDistance);
                        this.addNode(knot);
                        this.addEdge(new Edge(nodes[i], knot, true));
                        nodes[i].knotted = true;
                    }
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            toggleHistorized: function(nodes) {
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].historized = !nodes[i].historized;
                this.recordState();
                DrawingEngine.start(false);
            },
            toggleIdentifier: function(nodes) {
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].identifier = !nodes[i].identifier;
                this.recordState();
                DrawingEngine.start(false);
            },
            addAttribute: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var attribute = new Attribute(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(attribute);
                    this.addEdge(new Edge(attribute, nodes[i], true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTie: function(nodes) {
                var tie;
                // multiple anchors selected
                if(nodes.length > 1) {
                    var i, xAverage = 0, yAverage = 0;
                    for(i = 0; i < nodes.length; i++) {
                        xAverage += nodes[i].xPosition;
                        yAverage += nodes[i].yPosition;
                    }
                    xAverage /= nodes.length;
                    yAverage /= nodes.length;
                    tie = new Tie(xAverage, yAverage, false);
                    this.addNode(tie);
                    for(i = 0; i < nodes.length; i++)
                        this.addEdge(new Edge(tie, nodes[i], true));
                }
                // single anchor selected
                else {
                    var anchor = nodes[0];
                    tie = new Tie(anchor.xPosition + 2 * LayoutEngine.normalDistance, anchor.yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    this.addEdge(new Edge(tie, anchor, true));
                    this.addEdge(new Edge(tie, anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var anchor = new Anchor(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    this.addEdge(new Edge(nodes[i], anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addTieAndAnchor: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var tie = new Tie(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance, false);
                    this.addNode(tie);
                    this.addEdge(new Edge(tie, nodes[i], true));
                    var anchor = new Anchor(nodes[i].xPosition + 4 * LayoutEngine.normalDistance, nodes[i].yPosition - 6 * LayoutEngine.normalDistance);
                    this.addNode(anchor);
                    this.addEdge(new Edge(tie, anchor, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            },
            addKnot: function(nodes) {
                for(var i = 0; i < nodes.length; i++) {
                    var knot = new Knot(nodes[i].xPosition + 2 * LayoutEngine.normalDistance, nodes[i].yPosition - 3 * LayoutEngine.normalDistance);
                    this.addNode(knot);
                    this.addEdge(new Edge(nodes[i], knot, true));
                }
                this.recordState();
                DrawingEngine.start(true);
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            initialized: false,
            canvas: null,
            shadowCanvas: null,
            miniatureCanvas: null,
            context: null,
            shadowContext: null,
            miniatureContext: null,
            running: false,
            xyScale: 1,
            xTranslation: 0,
            yTranslation: 0,
            xVisible: 0,
            yVisible: 0,
            widthVisible: 0,
            heightVisible: 0,
            miniScale: 0.2, // one fifth of the large canvas
            miniPadding: 50,
            miniWidth: 0,
            miniHeight: 0,
            miniCounter: 0,
            miniature: null,
            showNames: false,
            newState: true,
            init: function(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext) {
                this.canvas = canvas;
                this.shadowCanvas = shadowCanvas;
                this.miniatureCanvas = miniatureCanvas;
                this.context = context;
                this.shadowContext = shadowContext;
                this.miniatureContext = miniatureContext;
                this.miniature = document.getElementById('miniature');
                this.context.font = '10px sans-serif';
                this.initialized = true;
                this.refreshViewportCoordinates();
            },
            storeSettings: function(storage) {
                storage.setItem("xyScale", this.xyScale);
                storage.setItem("xTranslation", this.xTranslation);
                storage.setItem("yTranslation", this.yTranslation);
            },
            loadSettings: function(storage) {
                this.xyScale = 1 * storage.getItem("xyScale") || 1;
                this.xTranslation = 1 * storage.getItem("xTranslation") || 0;
                this.yTranslation = 1 * storage.getItem("yTranslation") || 0;
                ResizeHandler.resizeCanvas(this.canvas, this.context);
                ResizeHandler.resizeCanvas(this.shadowCanvas, this.shadowContext);
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            reset: function() {
                this.xyScale = 1;
                this.xTranslation = 0;
                this.yTranslation = 0;
                this.miniScale = 0.2;
                ResizeHandler.resizeCanvas(this.canvas, this.context);
                ResizeHandler.resizeCanvas(this.shadowCanvas, this.shadowContext);
                this.invalidateMiniature();
                this.refreshViewportCoordinates();
            },
            scale: function(scale) {
                this.xyScale *= scale;
                this.context.scale(scale, scale);
                this.shadowContext.scale(scale, scale);
                this.refreshViewportCoordinates();
            },
            translate: function(x, y) {
                this.xTranslation += x * this.xyScale;
                this.yTranslation += y * this.xyScale;
                this.context.translate(x, y);
                this.shadowContext.translate(x, y);
                this.refreshViewportCoordinates();
            },
            refreshViewportCoordinates: function() {
                if(this.initialized) {
                    this.xVisible = -this.xTranslation/this.xyScale;
                    this.yVisible = -this.yTranslation/this.xyScale;
                    this.widthVisible = this.canvas.width/this.xyScale;
                    this.heightVisible = this.canvas.height/this.xyScale;                    
                }
            },
            xContext: function(xScreen) {
                return Math.round((xScreen - this.xTranslation) / this.xyScale);
            },
            yContext: function(yScreen) {
                return Math.round((yScreen - this.yTranslation) / this.xyScale);
            },
            xScreen: function(xContext) {
                return Math.round(xContext * this.xyScale + this.xTranslation);
            },
            yScreen: function(yContext) {
                return Math.round(yContext * this.xyScale + this.yTranslation);
            },
            setCursor: function(cursor) {
                this.canvas.style.cursor = cursor;
            },
            getNodeAt: function(x, y) {
                // clear the shadow context
                this.shadowContext.fillStyle = '#000000';
                this.shadowContext.fillRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);

                var i, node;
                // draw all nodes on the shadow context
                for(i = 0; node = Model.nodes[i]; i++)
                    node.drawShadow(this.shadowContext);

                var data = this.shadowContext.getImageData(x, y, 1, 1).data;
                return Model.getNodeFromShadow(UniqueColor.formatColor(data[0], data[1], data[2]));
            },
            start: function(layoutModel) {
                if(this.initialized) {
                    this.invalidateMiniature();
                    if(!this.running) {
                        this.running = true;
                        this.drawId = setInterval(function() { DrawingEngine.draw(layoutModel); }, 1000 / FPS);
                        if(layoutModel)
                            ControlButtons.setPauseState();
                    }
                }
            },
            stop: function() {
                if(this.running) {
                    clearInterval(this.drawId);
                    this.running = false;
                    ControlButtons.setPlayState();
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            draw: function(layoutModel) {
                // layout nodes
                if(layoutModel || !LayoutEngine.equilibrium) {
                    LayoutEngine.layout(Model);
                    this.newState = true;
                }
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    clearInterval(this.drawId);
                    this.running = false;
                    this.invalidateMiniature();
                    if(this.newState) {
                        this.newState = false;
                        Model.recordState();
                    }
                    ControlButtons.setPlayState();
                }

                // clear the visible context
                this.context.clearRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);

                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % MINIRATE;
                if(this.miniCounter == 1)
                    this.drawMiniature(Model);

                var i, node;
                // draw focus rings around hovered and selected nodes
                if(node = CanvasEventHandler.hoveredNode)
                    this.drawHovered(node.xPosition, node.yPosition);

                for(i = 0; node = CanvasEventHandler.selectedNodes[i]; i++)
                    this.drawSelected(node.xPosition, node.yPosition, node == CanvasEventHandler.hoveredNode);

                // cast all shadows first
                this.context.globalAlpha = 0.8;
                for(i = 0; node = Model.nodes[i]; i++)
                    node.drawMoving(this.context);

                this.context.globalAlpha = 1.0;
                // draw all nodes and edges on the visible context
                for(i = 0; node = Model.nodes[i]; i++) {
                    node.draw(this.context);
                    if(this.miniCounter == 1)
                        node.draw(this.miniatureContext);
                }
                if(this.showNames) {
                    for(i = 0; node = Model.nodes[i]; i++)
                        if(!(node instanceof Edge))
                            node.drawName(this.context);
                }
                else if (node = CanvasEventHandler.hoveredNode)
                    node.drawName(this.context);
            },
            drawMiniature: function(model) {
                // check current size first and adjust scale accordingly
                if(!model.rightmostNode) return;
                
                do {
                    this.miniWidth = model.rightmostNode.xPosition - model.leftmostNode.xPosition + 2 * this.miniPadding;
                    this.miniHeight = model.bottommostNode.yPosition - model.topmostNode.yPosition + 2 * this.miniPadding;
                    this.miniatureCanvas.width = this.miniScale * this.miniWidth;
                    this.miniatureCanvas.height = this.miniScale * this.miniHeight;
                }
                while(this.resizeMiniature());

                this.miniature.style.width = this.miniatureCanvas.width + 'px';
                this.miniature.style.height = this.miniatureCanvas.height + 'px';
                this.miniatureContext.setTransform(this.miniScale, 0, 0, this.miniScale, this.miniScale * (this.miniPadding - Model.leftmostNode.xPosition), this.miniScale * (this.miniPadding - Model.topmostNode.yPosition));

                // show the viewport on the miniature
                this.miniatureContext.strokeStyle = '#bb5555';
                this.miniatureContext.lineWidth = 1/this.miniScale;
                this.miniatureContext.strokeRect(this.xVisible, this.yVisible, this.widthVisible, this.heightVisible);
            },
            resizeMiniature: function() {
                if(this.miniatureCanvas.width + this.miniatureCanvas.height < (window.innerWidth + window.innerHeight)/6) {
                    this.miniScale += 0.03;
                    return true;
                }
                if(this.miniatureCanvas.width + this.miniatureCanvas.height > (window.innerWidth + window.innerHeight)/4) {
                    this.miniScale -= 0.03;
                    return true;
                }
                return false;
            },
            drawHovered: function(x, y) {
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance + 5, 0, 2*Math.PI, false);
                this.context.fillStyle = '#ede5e5';
                this.context.fill();
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance - 5, 0, 2*Math.PI, false);
                this.context.fillStyle = '#fff';
                this.context.fill();
            },
            drawSelected: function(x, y, isHovered) {
                if(!isHovered) {
                    this.context.beginPath();
                    this.context.arc(x, y, LayoutEngine.normalDistance + 5, 0, 2*Math.PI, false);
                    this.context.fillStyle = '#ede5e5';
                    this.context.fill();
                }
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance, 0, 2*Math.PI, false);
                this.context.strokeStyle = '#b88';
                this.context.lineWidth = 1.0;
                this.context.stroke();
            }
        };

        var ResizeHandler = {
            resizeCanvas: function(canvas, context) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // apparently changing the canvas width or height resets the transform
                context.setTransform(DrawingEngine.xyScale, 0, 0, DrawingEngine.xyScale, DrawingEngine.xTranslation, DrawingEngine.yTranslation);
                DrawingEngine.refreshViewportCoordinates();
                DrawingEngine.start(false);
            }
        };

        var CanvasEventHandler = {
            dragging: false,
            contextMenu: null,
            focusedNode: null,
            xLastKnown: 0,
            yLastKnown: 0,
            hoveringPrepared: false,
            hoveringId: null,
            hoveredNode: null,
            selectedNodes: [],
            mousedown: function(event) {
                if(this.focusedNode = DrawingEngine.getNodeAt(event.xScreen, event.yScreen)) {
                    if(event.shiftKey) {
                        if(this.selectedNodes.indexOf(this.focusedNode) >= 0)
                            this.removeNodeFromSelection(this.focusedNode);
                        else
                            this.addNodeToSelection(this.focusedNode);
                    }
                    else {
                        this.focusedNode.fixed = !this.focusedNode.fixed;
                        DrawingEngine.start(true);
                    }
                }
                else {
                    // we are shift clicking the canvas background
                    if(event.shiftKey)
                        this.clearSelection();
                }
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    // if we are dragging a node, we must also be hovering over it
                    if(this.focusedNode) {
                        if(!(this.focusedNode instanceof Edge)) {
                            this.focusedNode.xPosition = DrawingEngine.xContext(event.xScreen);
                            this.focusedNode.yPosition = DrawingEngine.yContext(event.yScreen);
                            this.focusedNode.fixed = true;
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;
                            }
                            Model.invalidateNode(this.focusedNode);
                            DrawingEngine.start(true);
                        }
                    }
                    // if the dragging started over an empty part of the canvas
                    else {
                        DrawingEngine.setCursor('move');
                        DrawingEngine.translate((event.xScreen - this.xLastKnown)/DrawingEngine.xyScale, (event.yScreen - this.yLastKnown)/DrawingEngine.xyScale);
                        DrawingEngine.start(false);
                    }
                }
                else {
                    // we are hovering, but not dragging
                    if(this.hoveredNode) {
                        var mouse = {
                            xPosition: DrawingEngine.xContext(event.xScreen),
                            yPosition: DrawingEngine.yContext(event.yScreen)
                        };
                        if(LayoutEngine.distance(this.hoveredNode, mouse) > 1.5 * LayoutEngine.normalDistance) {
                            DrawingEngine.setCursor('default');
                            this.hoveredNode = null;
                            this.hoveringPrepared = false;
                            if(this.contextMenu != null && this.contextMenu.collapsed) {
                                this.contextMenu.close();
                                this.contextMenu = null;                                
                            }
                            DrawingEngine.start(false);
                        }
                    }
                    // if we are not hovering, set up a check in half a second
                    else if (!this.hoveringPrepared) {
                        this.hoveringPrepared = true;
                        this.hoveringId = setTimeout(function(self) { self.mousehover(event); }, 500, this);
                    }
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mousehover: function(event) {
                // mouse pointer over node
                if(this.hoveredNode = DrawingEngine.getNodeAt(this.xLastKnown, this.yLastKnown)) {
                    if(this.contextMenu == null)
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    else if (this.contextMenu.collapsed) {
                        this.contextMenu.close();
                        this.contextMenu = new ContextMenu(this.hoveredNode, this.selectedNodes);
                    }
                    DrawingEngine.setCursor('pointer');
                    DrawingEngine.start(false);
                }
                // mouse pointer not over node, trigger a new check
                else {
                    this.hoveringPrepared = false;
                }
            },
            closeContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;                    
                }
            },
            keydown: function(event) {
                // not used at the moment
            },
            // this is special Firefox handling
            DOMMouseScroll: function(event) {
                event.wheelDelta = event.detail * 120;
                this.mousewheel(event);
            },
            // TODO: We need upper and lower bounds on the zoom            
            mousewheel: function(event) {
                var zoom = 1 + 10/event.wheelDelta;
                DrawingEngine.scale(zoom);
                DrawingEngine.translate(DrawingEngine.xContext(event.xScreen) - DrawingEngine.xContext(event.xScreen) * zoom, DrawingEngine.yContext(event.yScreen) - DrawingEngine.yContext(event.yScreen) * zoom);
                DrawingEngine.start(false);
            },
            mouseup: function(event) {
                // the dragging started over a node
                if(this.focusedNode) 
                    this.focusedNode = null;
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.setCursor('default');
                DrawingEngine.start(false);
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.CanvasEventHandler[event.type])
                    this.CanvasEventHandler[event.type](event);
            },
            addNodeToSelection: function(node) {
                if(this.selectedNodes.indexOf(node) < 0)
                    this.selectedNodes.push(node);
            },
            removeNodeFromSelection: function(node) {
                this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1);
            },
            clearSelection: function() {
                this.selectedNodes.length = 0;
            }
        };

        var MiniatureEventHandler = {
            dragging: false,
            xLastKnown: 0,
            yLastKnown: 0,
            mousedown: function(event) {
                // TODO: Position the viewport under mousepointer on click
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    DrawingEngine.translate((this.xLastKnown - event.xScreen)/DrawingEngine.miniScale, (this.yLastKnown - event.yScreen)/DrawingEngine.miniScale);
                    DrawingEngine.start(false);
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mouseup: function(event) {
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.start(false);
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.MiniatureEventHandler[event.type])
                    this.MiniatureEventHandler[event.type](event);
            }
        };


        var UniqueIdentity = {
            lastId: 0,
            usedIds: [],
            nextId: function() {
                while(this.usedIds[++this.lastId]);
                this.usedIds[this.lastId] = true;
                return this.lastId;
            },
            takeId: function(id) {
                this.usedIds[id] = true;
                return id;
            }
        };

        function AbstractNode(x, y) {
            this.xPosition = x;
            this.yPosition = y;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.velocity = 0;
            this.moving = true;
            this.fixed = false;
            this.shadowColor = UniqueColor.reserveUniqueColor();
            this.edges = [];
            this.editables = [];
            // TODO: descriptions have to be handled separately
            //this.editables = [['Description','description','textarea','rows','5','cols','20']];
            this.operations = ['erase'];
            this.incomplete = true;
        }
        AbstractNode.prototype = {
            description: null,
            xPosition: null,
            yPosition: null,
            xVelocity: null,
            yVelocity: null,
            velocity: null,
            edges: null,
            moving: true,
            shadowColor: '#ffffff',
            editables: null,
            incomplete: true,
            operations: null,
            // getters and setters (with hidden _id member)
            set id(id)  {
                if(id) {
                    UniqueIdentity.takeId(id);
                    this._id = id;
                }
            },
            get id() {
                if (!("_id" in this))
                    this._id = UniqueIdentity.nextId();
                return this._id;
            },
            set fixed(fixed) {
                this._fixed = fixed;
            },
            get fixed() {
                return this._fixed;
            },
            get name() {
                return '';
            },
            toString: function() {
                return this.name.toString();
            },
            isEmpty: function(value) {
                return !value || value == null || value.toString().replace(/^[^\S]+/,'').replace(/[^\S]+$/,'') == '';
            },
            isIncomplete: function() {
                var editable;
                for(var i = 0; editable = this.editables[i]; i++) {
                    if(this.isEmpty(this[editable.member]))
                        return true;
                    if(!this[editable.member].toString().match(new RegExp('^' + editable.pattern + '$')))
                        return true;
                }
                return false;
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addLayoutXML: function(element, schema) {
                if(this.description != null) {
                    var description = schema.createElement("description");
                    description.innerHTML = this.description;
                    element.appendChild(description);
                }
                var layout = schema.createElement("layout");
                layout.setAttribute("x", this.xPosition.toFixed(2));
                layout.setAttribute("y", this.yPosition.toFixed(2));
                layout.setAttribute("fixed", this.fixed);
                element.appendChild(layout);
            },
            stop: function() {
                this.moving = false;
            },
            // movement is propagated to the edges of a node
            start: function() {
                this.moving = true;
                for(var i = 0; i < this.edges.length; i++)
                    this.edges[i].start();
            },
            nameXOffset: function() {
                return 20;
            },
            drawName: function(context) {
                var i, edge, xAverage = 0;
                for(i = 0; edge = this.edges[i]; i++)
                    xAverage += edge.xPosition;
                xAverage /= this.edges.length;
                var currentDistance, smallestDistance, yClosest;
                for(i = 0; edge = this.edges[i]; i++) {
                    currentDistance = LayoutEngine.absolute(this.yPosition - edge.yPosition);
                    if(!i || ((this.xPosition < xAverage && edge.xPosition < this.xPosition) || (this.xPosition >= xAverage && edge.xPosition >= this.xPosition) && (currentDistance < smallestDistance))) {
                        smallestDistance = currentDistance;
                        yClosest = edge.yPosition;
                    }
                }
                var nameYOffset = -7 + (yClosest ? (this.yPosition < yClosest ? -3 : 3) : 0);
                context.save();
                var nameWidth = context.measureText(this.name).width;
                if(this.xPosition < xAverage)
                    context.translate(-nameWidth - this.nameXOffset(), nameYOffset);
                else
                    context.translate(this.nameXOffset(), nameYOffset);
                context.textBaseline = 'top';
                if(this.incomplete)
                    context.fillStyle = '#e00';
                else
                    context.fillStyle = '#000';
                context.fillText(this.name, this.xPosition, this.yPosition);
                context.restore();
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(context) {
                if(DEBUG) {
                    context.beginPath();
                    context.moveTo(this.xPosition, this.yPosition);
                    // draw an exaggerated velocity vector
                    context.lineTo(this.xPosition + LayoutEngine.normalDistance * this.xVelocity, this.yPosition + LayoutEngine.normalDistance * this.yVelocity);
                    context.strokeStyle = '#008800';
                    context.lineWidth = 0.5;
                    context.stroke();
                    context.fillStyle = '#ffffff';
                    context.fillRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                    context.strokeRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                }
            },
            // this is how a node draws itself on the shadow context
            drawShadow: function(context) {
                this.drawOutline(context);
                context.fillStyle = this.shadowColor;
                context.fill();
            },
            // this is used to draw the outline of a node, used in the shadow context
            drawOutline: function(context) {
                // subclasses implements this
            },
            // this is how to draw a graphical representation of the fact that a node is moving
            drawMoving: function(context) {
                if(this.moving && !this.fixed) {
                    var shadowOffsetX = 4 * ((this.velocity > 2) ? 2 : this.velocity);
                    var shadowOffsetY = 4 * ((this.velocity > 3) ? 3 : this.velocity);
                    context.save();
                    context.translate(-shadowOffsetX, shadowOffsetY);
                    this.drawOutline(context);
                    var color = Math.floor(96 + 128 * (1 - 1/(1 + this.velocity)));
                    // shift the color slightly towards red
                    context.fillStyle = 'rgb(' + (color + 8) + ',' + (color + 4) + ',' + color + ')';
                    context.fill();
                    context.restore();
                }
            },
            drawFixed: function(context) {
                if(this.fixed) {
                    context.fillStyle = '#000000';
                    context.fillRect(this.xPosition - 1, this.yPosition - 1, 2, 2);
                }
            }
        };

        function Attribute(x, y, historized) {
            AbstractNode.call(this, x, y);
            this.mnemonic = '?' + this.id;
            this.descriptor = '!Unnamed!';
            this.editables.push(this.descriptorEdit);
            this.editables.push(this.mnemonicEdit);
            this.knotted = false;
            this.historized = historized;
            this.operations.push('toggleKnotted','toggleHistorized');
        }
        Attribute.prototype = {
            mnemonic: null,
            descriptor: null,
            dataRange: null,
            timeRange: null,
            descriptorEdit: {
                name: 'Descriptor',
                member: 'descriptor',
                type: 'input',
                pattern: '([A-Z][a-z]*)+',
                attributes: ['type', 'text', 'title', 'Attribute Descriptor', 'required', 'required']
            },
            mnemonicEdit: {
                name: 'Mnemonic',
                member: 'mnemonic',
                type: 'input',
                pattern: '[A-Z]{3}',
                attributes: ['type', 'text', 'title', 'Attribute Mnemonic', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                member: 'dataRange',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Data Type', 'required', 'required']
            },
            timeRangeEdit: {
                name: 'Time range',
                member: 'timeRange',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Historization Type', 'required', 'required']
            },
            set historized(historized) {
                var index = this.editables.indexOf(this.timeRangeEdit);
                if(historized && index < 0)
                    this.editables.push(this.timeRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                this._historized = historized;
            },
            get historized() {
                return this._historized;
            },
            set knotted(knotted) {
                var index = this.editables.indexOf(this.dataRangeEdit);
                if(!knotted && index < 0)
                    this.editables.push(this.dataRangeEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                this._knotted = knotted;
            },
            get knotted() {
                return this._knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || '???';
                var descriptor = element.getAttribute("descriptor") || '!Unnamed!';
                var timeRange = element.getAttribute("timeRange") || null;
                var historized = timeRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || null;
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || null;
                var id = element.getAttribute("id");
                var parent = element.parentNode;
                var attribute = new Attribute(x, y, historized);
                attribute.fixed = fixed;
                attribute.knotted = knotted;
                attribute.timeRange = timeRange;
                attribute.dataRange = dataRange;
                attribute.description = description ? description.firstChild.nodeValue : null;
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                attribute.id = id;
                var anchor = Model.getNodeFromId(Number(parent.getAttribute("id")));
                Model.addEdge(new Edge(attribute, anchor, true));
                if(knotted) {
                    var grandparent = parent.parentNode;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(i = 0; i < knots.length; i++) {
                        if(knots[i].getAttribute("mnemonic") == knotRange) {
                            var knot = Model.getNodeFromId(Number(knots[i].getAttribute("id")));
                            Model.addEdge(new Edge(attribute, knot, false));
                            break; // only one should match
                        }
                    }                    
                }
                attribute.incomplete = attribute.isIncomplete();
                return attribute;
            },
            get name() {
                var anchor, edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.otherNode instanceof Anchor)
                        anchor = edge.otherNode;
                return anchor.mnemonic + "_" + this.mnemonic + "_" + anchor.descriptor + "_" + this.descriptor;
            },
            nameXOffset: function() {
                if(this.historized)
                    return 22;
                else
                    return 20;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("id", this.id);
                attribute.setAttribute("mnemonic", this.mnemonic);
                attribute.setAttribute("descriptor", this.descriptor);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.timeRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.edges[i]; i++)
                        if(edge.otherNode instanceof Knot)
                            knot = edge.otherNode;
                    attribute.setAttribute("knotRange", knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.dataRange);
                }
                this.addLayoutXML(attribute, schema);
                element.appendChild(attribute);
            },
            drawOutline: function(context) {
                // the outermost path
                context.beginPath();
                if(this.historized)
                    context.arc(this.xPosition, this.yPosition, 12, 0, 2*Math.PI, false);
                else
                    context.arc(this.xPosition, this.yPosition, 10, 0, 2*Math.PI, false);
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    // then we get back to drawing the actual symbol
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 7, 0, 2*Math.PI, false);
                    context.fill();
                    context.stroke();
                }
                else {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Attribute, AbstractNode);

        function Anchor(x, y) {
            AbstractNode.call(this, x, y);
            this.mnemonic = '?' + this.id;
            this.descriptor = '!Unnamed!';
            this.editables.push(this.descriptorEdit);
            this.editables.push(this.mnemonicEdit);
            this.editables.push(this.identityEdit);
            this.operations.push('addAttribute','addTie','addTieAndAnchor');
        }
        Anchor.prototype = {
            mnemonic: null,
            descriptor: null,
            identity: null,
            descriptorEdit: {
                name: 'Descriptor',
                member: 'descriptor',
                type: 'input',
                pattern: '([A-Z][a-z]*)+',
                attributes: ['type', 'text', 'title', 'Attribute Descriptor', 'required', 'required']
            },
            mnemonicEdit: {
                name: 'Mnemonic',
                member: 'mnemonic',
                type: 'input',
                pattern: '[A-Z]{2}',
                attributes: ['type', 'text', 'title', 'Attribute Mnemonic', 'required', 'required']
            },
            identityEdit: {
                name: 'Identity',
                member: 'identity',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Identity Type', 'required', 'required']
            },
            get name() {
                return this.mnemonic + "_" + this.descriptor;
            },
            nameXOffset: function() {
                return 20;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? false : fixed == "true";
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var id = element.getAttribute("id");
                var mnemonic = element.getAttribute("mnemonic") || "??";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || null;
                var anchor = new Anchor(x, y);
                anchor.fixed = fixed;
                anchor.description = description ? description.firstChild.nodeValue : null;
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                anchor.id = id;
                anchor.incomplete = anchor.isIncomplete();
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("id", this.id);
                anchor.setAttribute("mnemonic", this.mnemonic);
                anchor.setAttribute("descriptor", this.descriptor);
                anchor.setAttribute("identity", this.identity);

                var edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.node instanceof Attribute)
                        edge.node.addXML(anchor, schema);
                this.addLayoutXML(anchor, schema);
                return anchor;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition - 10);
                context.closePath();
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#bb5555';
                context.fill();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Anchor, AbstractNode);

        function Knot(x, y) {
            AbstractNode.call(this, x, y);
            this.mnemonic = '?' + this.id;
            this.descriptor = '!Unnamed!';
            this.editables.push(this.descriptorEdit);
            this.editables.push(this.mnemonicEdit);
            this.editables.push(this.dataRangeEdit);
            this.editables.push(this.identityEdit);
        }
        Knot.prototype = {
            mnemonic: null,
            descriptor: null,
            identity: null,
            dataRange: null,
            descriptorEdit: {
                name: 'Descriptor',
                member: 'descriptor',
                type: 'input',
                pattern: '([A-Z][a-z]*)+',
                attributes: ['type', 'text', 'title', 'Attribute Descriptor', 'required', 'required']
            },
            mnemonicEdit: {
                name: 'Mnemonic',
                member: 'mnemonic',
                type: 'input',
                pattern: '[A-Z]{3}',
                attributes: ['type', 'text', 'title', 'Attribute Mnemonic', 'required', 'required']
            },
            identityEdit: {
                name: 'Identity',
                member: 'identity',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Identity Type', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                member: 'dataRange',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Data Type', 'required', 'required']
            },
            get name() {
                return this.mnemonic + "_" + this.descriptor;
            },
            nameXOffset: function() {
                return 18;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var id = element.getAttribute("id");
                var mnemonic = element.getAttribute("mnemonic") || "???";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || null;
                var dataRange = element.getAttribute("dataRange") || null;
                var knot = new Knot(x, y);
                knot.fixed = fixed;
                knot.description = description ? description.firstChild.nodeValue : null;
                knot.mnemonic = mnemonic;
                knot.descriptor = descriptor;
                knot.identity = identity;
                knot.dataRange = dataRange;
                knot.id = id;
                knot.incomplete = knot.isIncomplete();
                return knot;
            },
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("id", this.id);
                knot.setAttribute("mnemonic", this.mnemonic);
                knot.setAttribute("descriptor", this.descriptor);
                knot.setAttribute("identity", this.identity);
                knot.setAttribute("dataRange", this.dataRange);
                this.addLayoutXML(knot, schema);
                return knot;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 6, this.yPosition - 9);
                context.lineTo(this.xPosition + 6, this.yPosition - 9);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition - 9, this.xPosition + 9, this.yPosition - 6);
                context.lineTo(this.xPosition + 9, this.yPosition + 6);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition + 9, this.xPosition + 6, this.yPosition + 9);
                context.lineTo(this.xPosition - 6, this.yPosition + 9);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition + 9, this.xPosition - 9, this.yPosition + 6);
                context.lineTo(this.xPosition - 9, this.yPosition - 6);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition - 9, this.xPosition - 6, this.yPosition - 9);
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#ffffff';
                context.fill();
                context.strokeStyle = '#ff8888';
                context.lineWidth = 1.5;
                context.stroke();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Knot, AbstractNode);

        function Tie(x, y, historized) {
            AbstractNode.call(this, x, y);
            this.historized = historized;
            this.incomplete = this.isIncomplete();
            this.operations.push('toggleHistorized','addKnot','addAnchor');
        }
        Tie.prototype = {
            timeRange: null,
            timeRangeEdit: {
                name: 'Time range',
                member: 'timeRange',
                type: 'input',
                pattern: '.*',
                attributes: ['type', 'text', 'title', 'Historization Type', 'required', 'required']
            },
            set historized(historized) {
                var index = this.editables.indexOf(this.timeRangeEdit);
                if(historized && index < 0)
                    this.editables.push(this.timeRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                this._historized = historized;
            },
            get historized() {
                return this._historized;
            },
            isIncomplete: function() {
                return AbstractNode.prototype.isIncomplete.apply(this, arguments) || !this.name.match(/^(_?[A-Z]+_[a-zA-Z]+)+$/);
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed == 'true' : false;
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName == 'description')
                        description = element.childNodes.item(i);
                var timeRange = element.getAttribute("timeRange") || null;
                var historized = timeRange ? true : false;
                var id = element.getAttribute("id");
                var tie = new Tie(x, y, historized);
                tie.fixed = fixed;
                tie.timeRange = timeRange;
                tie.description = description ? description.firstChild.nodeValue : null;
                tie.id = id;
                var grandparent = element.parentNode.parentNode;
                var j, type, edge, role, identifier, anchor, anchorRoles = element.getElementsByTagName("anchorRole");
                for(i = 0; i < anchorRoles.length; i++) {
                    type = anchorRoles[i].getAttribute("type") || "??";
                    role = anchorRoles[i].getAttribute("role") || "!unknown!";
                    identifier = anchorRoles[i].getAttribute("identifier") || false;
                    var anchors = grandparent.getElementsByTagName("anchor");
                    for(j = 0; j < anchors.length; j++) {
                        if(anchors[j].getAttribute("mnemonic") == type) {
                            anchor = Model.getNodeFromId(Number(anchors[j].getAttribute("id")));
                            edge = new Edge(tie, anchor, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            break; // only one should match
                        }
                    }
                }
                var knot, knotRoles = element.getElementsByTagName("knotRole");
                for(i = 0; i < knotRoles.length; i++) {
                    type = knotRoles[i].getAttribute("type") || "???";
                    role = knotRoles[i].getAttribute("role") || "!unknown!";
                    identifier = knotRoles[i].getAttribute("identifier") || false;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(j = 0; i < knots.length; j++) {
                        if(knots[j].getAttribute("mnemonic") == type) {
                            knot = Model.getNodeFromId(Number(knots[j].getAttribute("id")));
                            edge = new Edge(tie, knot, (identifier == "true"));
                            edge.role = role;
                            Model.addEdge(edge);
                            break; // only one should match
                        }
                    }
                }
                tie.incomplete = tie.isIncomplete();
                return tie;
            },
            get name() {
                var i, edge, name="";
                for(i = 0; edge = this.edges[i]; i++) {
                    if(i > 0)
                        name += "_";
                    name += edge.otherNode.mnemonic + "_" + edge.role;
                }
                return name;
            },
            nameXOffset: function() {
                if(this.historized)
                    return 26;
                else
                    return 24;
            },
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                tie.setAttribute("id", this.id);
                if(this.historized)
                    tie.setAttribute("timeRange", this.timeRange);
                for(var i = 0; i < this.edges.length; i++) {
                    var role;
                    var node = this.edges[i].otherNode;
                    if(this.edges[i].otherNode instanceof Anchor)
                        role = schema.createElement("anchorRole");
                    else if(this.edges[i].otherNode instanceof Knot)
                        role = schema.createElement("knotRole");
                    role.setAttribute("role", this.edges[i].role);
                    role.setAttribute("type", node.mnemonic);
                    role.setAttribute("identifier", this.edges[i].identifier);
                    tie.appendChild(role);
                }
                this.addLayoutXML(tie, schema);
                return tie;
            },
            drawOutline: function(context) {
                if(this.historized) {
                    context.beginPath();
                    context.moveTo(this.xPosition - 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 17);
                    context.lineTo(this.xPosition + 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 17);
                    context.lineTo(this.xPosition - 18, this.yPosition);
                    context.closePath();
                }
                else {
                    context.beginPath();
                    context.moveTo(this.xPosition - 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 14);
                    context.lineTo(this.xPosition + 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 14);
                    context.lineTo(this.xPosition - 15, this.yPosition);
                    context.closePath();
                }
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#a8a8a8';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.moveTo(this.xPosition - 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 11);
                    context.lineTo(this.xPosition + 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 11);
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                else {
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Tie, AbstractNode);

        function Edge(node, otherNode, identifier) {
            // assume that the control point and midway point coincide with the center point
            this.centerPoint = {
                xPosition: node.xPosition + (otherNode.xPosition - node.xPosition)/2,
                yPosition: node.yPosition + (otherNode.yPosition - node.yPosition)/2
            };
            this.controlPoint = {
                xPosition: this.centerPoint.xPosition,
                yPosition: this.centerPoint.yPosition
            };
            AbstractNode.call(this, this.controlPoint.xPosition, this.controlPoint.yPosition);
            this.role = '!unknown!';
            this.node = node;
            this.otherNode = otherNode;
            this.identifier = identifier;
            node.edges.push(this);
            otherNode.edges.push(this);
            this.edges.push(node);
            this.edges.push(otherNode);
            this.editables.push(this.roleEdit);
            this.operations.push('toggleIdentifier');
            this.incomplete = false;
        }
        Edge.prototype = {
            role: null,
            roleEdit: {
                name: 'Role',
                member: 'role',
                type: 'input',
                pattern: '([a-z][A-Z]*)+',
                attributes: ['type', 'text', 'title', 'Role of the Relationship', 'required', 'required']
            },
            node: null,
            otherNode: null,
            controlPoint: { xPosition: null, yPosition: null },
            centerPoint: { xPosition: null, yPosition: null },
            identifier: true,
            // overload to remove propagation of movement
            start: function() {
                this.moving = true;
            },
            // edges never fixate
            set fixed(fixed) {
                this._fixed = false;
            },
            get name() {
                return this.role;
            },
            drawMoving: function(context) {
                if((this.node.moving && !this.node.fixed) || (this.otherNode.moving && !this.otherNode.fixed)) {
                    var nodeShadowOffsetX = 0;
                    var nodeShadowOffsetY = 0;
                    if(this.node.moving && !this.node.fixed) {
                        nodeShadowOffsetX = 4 * ((this.node.velocity > 2) ? 2 : this.node.velocity);
                        nodeShadowOffsetY = 4 * ((this.node.velocity > 3) ? 3 : this.node.velocity);
                    }
                    var otherNodeShadowOffsetX = 0;
                    var otherNodeShadowOffsetY = 0;
                    if(this.otherNode.moving && !this.otherNode.fixed) {
                        otherNodeShadowOffsetX = 4 * ((this.otherNode.velocity > 2) ? 2 : this.otherNode.velocity);
                        otherNodeShadowOffsetY = 4 * ((this.otherNode.velocity > 3) ? 3 : this.otherNode.velocity);
                    }
                    var averageVelocity = (this.node.velocity + this.otherNode.velocity)/2;
                    var controlOffsetX = (nodeShadowOffsetX + otherNodeShadowOffsetX)/2;
                    var controlOffsetY = (nodeShadowOffsetY + otherNodeShadowOffsetY)/2;
                    context.beginPath();
                    context.moveTo(this.node.xPosition - nodeShadowOffsetX, this.node.yPosition + nodeShadowOffsetY);
                    context.quadraticCurveTo(this.controlPoint.xPosition - controlOffsetX, this.controlPoint.yPosition + controlOffsetY,
                            this.otherNode.xPosition - otherNodeShadowOffsetX, this.otherNode.yPosition + otherNodeShadowOffsetY);
                    var color = Math.floor(96 + 128 * (1 - 1/(1 + averageVelocity)));
                    // shift the color slightly towards red
                    context.strokeStyle = 'rgb(' + (color + 8) + ',' + (color + 4) + ',' + color + ')';
                    context.lineWidth = 1.0;
                    context.stroke();
                }
            },
            draw: function(context) {
                context.beginPath();
                context.moveTo(this.node.xPosition, this.node.yPosition);
                context.quadraticCurveTo(this.controlPoint.xPosition, this.controlPoint.yPosition, this.otherNode.xPosition, this.otherNode.yPosition);
                context.strokeStyle = '#000000';
                context.lineWidth = 1.0;
                context.stroke();
                if(DEBUG) {
                    context.beginPath();
                    context.arc(this.controlPoint.xPosition, this.controlPoint.yPosition, 4, 0, 2*Math.PI, false);
                    context.fillStyle = '#00bb00';
                    context.fill();
                    context.stroke();
                }
                // show if edges on ties are identifiers or not by drawing a filled or empty circle
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 6, 0, 2*Math.PI, false);
                    context.stroke();
                    if(this.identifier)
                        context.fillStyle = '#766';
                    else
                        context.fillStyle = '#fff';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
            },
            drawShadow: function(context) {
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 6, 0, 2*Math.PI, false);
                    context.fillStyle = this.shadowColor;
                    context.fill();
                }
            }
        };

        // inheritance
        extend(Edge, AbstractNode);


        // global function providing inheritance
        function extend(child, supertype){
           child.prototype.__proto__ = supertype.prototype;
        }

        function ModalBackground() {
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
            }
        };

        function CodePopover(documentFragment, preformatted) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var codePopover = document.createElement('div');
            codePopover.setAttribute("id", "codePopover");
            var padding = window.innerWidth * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            codePopover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            if(preformatted)
                content.setAttribute("class", "preformatted");
            content.style.width = (window.innerWidth - 2 * padding) + 'px';
            content.style.height = (window.innerHeight - 2 * padding) + 'px';
            content.appendChild(documentFragment);
            codePopover.appendChild(content);

            document.body.appendChild(codePopover);

            this.codePopover = codePopover;
            return this;
        }
        CodePopover.prototype = {
            codePopover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.codePopover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function ContextMenu(hoveredNode, selectedNodes) {
            var self = this;

            this.hoveredNode = hoveredNode;
            this.selectedNodes = selectedNodes;
            var contextMenu = document.createElement('div');
            contextMenu.setAttribute('id', 'contextMenu');
            this.toggler = document.createElement('div');
            this.toggler.setAttribute('class', 'toggler collapsed');
            this.toggler.addEventListener('click', function(event) { self.toggle() }, false);
            contextMenu.appendChild(this.toggler);
            this.contextMenu = contextMenu;

            var editable;
            this.table = document.createElement('table');
            this.table.setAttribute('class', 'items');

            var i, j, tr;
            // if we are operating a single node, show its editable fields
            if(selectedNodes.length == 0 || (selectedNodes.length == 1 && selectedNodes[0] == hoveredNode)) {
                for(i = 0; editable = hoveredNode.editables[i]; i++) {
                    var element = document.createElement(editable.type);
                    element.className = 'editable';
                    element.setAttribute('pattern', editable.pattern);
                    for(j = 0; j < editable.attributes.length;) {
                        var attribute = editable.attributes[j++];
                        var value = editable.attributes[j++];
                        element.setAttribute(attribute, value);
                    }
                    element.value = hoveredNode[editable.member];
                    element.member = editable.member;
                    element.addEventListener('blur', function() { self.edit(this, hoveredNode); }, false);
                    element.addEventListener('invalid', function() { self.invalid(this, hoveredNode); }, false);
                    tr = document.createElement('tr');
                    tr.setAttribute('valign', 'top');
                    var td1 = document.createElement('td');
                    td1.appendChild(document.createTextNode(editable.name + ":"));
                    tr.appendChild(td1);
                    var td2 = document.createElement('td');
                    td2.appendChild(element);
                    tr.appendChild(td2);
                    this.table.appendChild(tr);
                }
            }
            // operations are defines as 'method', 'display name'
            var allOperations = [
                ['erase', 'Delete'],
                ['toggleKnotted', 'Toggle Knotted'],
                ['toggleHistorized', 'Toggle Historized'],
                ['addAttribute', 'Add Attribute'],
                ['addTie', 'Add Tie'],
                ['addAnchor', 'Add Anchor'],
                ['addKnot', 'Add Knot'],    
                ['addTieAndAnchor', 'Add tied Anchor'],
                ['toggleIdentifier', 'Toggle Identifier']
            ];
            var supportedOperations = [];

            var allNodes = selectedNodes.slice(0);
            if(allNodes.indexOf(hoveredNode) < 0)
                allNodes.push(hoveredNode);

            for(i = 0; i < allOperations.length; i++)
                if(this.isSupported(allOperations[i][0], allNodes))
                    supportedOperations.push(allOperations[i]);

            for(i = 0; i < supportedOperations.length; i++) {
                var button = document.createElement('input');
                button.setAttribute('type', 'button');
                button.value = supportedOperations[i][1];
                button.method = supportedOperations[i][0];
                button.addEventListener('click', function() { self.operate(this, allNodes); }, false);
                tr = document.createElement('tr');
                var td = document.createElement('td');
                td.setAttribute('colspan', '2');
                td.appendChild(button);
                tr.appendChild(td);
                this.table.appendChild(tr);
            }

            this.updatePosition();
            document.body.appendChild(contextMenu);
            return this;
        }
        ContextMenu.prototype = {
            contextMenu: null,
            hoveredNode: null,
            selectedNodes: null,
            table: null,
            toggler: null,
            collapsed: true,
            modalBackground: null,
            operate: function(button, nodes) {
                Model[button.method](nodes);
                for(var i = 0; i < nodes.length; i++)
                    nodes[i].incomplete = nodes[i].isIncomplete();
                CanvasEventHandler.closeContextMenu();
            },
            edit: function(element, node) {
                node[element.member] = element.value;
                if(node.node instanceof Tie)
                    node.node.incomplete = node.node.isIncomplete();
                for(var i = 0; node.edges.length; i++)
                    if(node.edges[i].node instanceof Tie)
                        node.edges[i].node.incomplete = node.edges[i].node.isIncomplete();
                element.checkValidity();
            },
            invalid: function(element, node) {
                node.incomplete = true;
            },
            isSupported: function(operation, nodes) {
                for(var i = 0; i < nodes.length; i++)
                    if(nodes[i].operations.indexOf(operation) < 0)
                        return false;
                return true;
            },
            updatePosition: function() {
                var x = DrawingEngine.xScreen(this.hoveredNode.xPosition + LayoutEngine.normalDistance/2);
                var y = DrawingEngine.yScreen(this.hoveredNode.yPosition + LayoutEngine.normalDistance/2);

                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
            },
            toggle: function(node) {
                if(this.collapsed) {
                    this.toggler.className = 'toggler expanded';
                    this.collapsed = false;
                    this.modalBackground = new ModalBackground();
                    this.contextMenu.appendChild(this.table);
                }
                else {
                    this.toggler.className = 'toggler collapsed';
                    this.collapsed = true;
                    this.contextMenu.removeChild(this.table);
                    this.unmodal();
                    DrawingEngine.start(false);
                }
            },
            unmodal: function() {
                if(this.modalBackground) {
                    this.modalBackground.close();
                    this.modalBackground = null;
                }
                this.hoveredNode.incomplete = this.hoveredNode.isIncomplete();
            },
            close: function() {
                this.unmodal();
                document.body.removeChild(this.contextMenu);
            }
        };

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                // does not work in Safari, but works in Firefox 3.6 and Chrome 6.
                this.reader = new FileReader();
                this.reader.onload = function() { FileHandler.fileLoaded() };
                this.reader.readAsText(files[0]);
            },
            replaceInput: function(parent, input) {
                var newInput = document.createElement('input');
                newInput.className = 'invisible';
                newInput.setAttribute('type', 'file');
                newInput.addEventListener('change', function() { FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this); }, false);
                parent.replaceChild(newInput, input)
            },
            fileLoaded: function() {
                try {
                    var parser = new DOMParser();
                    var xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                }
                CanvasEventHandler.clearSelection();
                DrawingEngine.reset();
                Model.fromXML(xml);
                DrawingEngine.start(false);
            }
        };

        var ActionsMenu = {
            transform: function (xmlDocument, transformationURL) {
                var result;
                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET", transformationURL, false);
                    xmlhttp.send(null);
                    var processor = new XSLTProcessor();
                    processor.importStylesheet(xmlhttp.responseXML.documentElement);
                    result = processor.transformToFragment(xmlDocument, document);
                }
                catch(exception){
                    alert(exception);
                }
                return result;
            },
            loadFromURL: function (url) {
                try {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.open("GET", url, false);
                    xmlhttp.send(null);
                    Model.fromXML(xmlhttp.responseXML);
                    Model.recordState();
                    DrawingEngine.reset();
                    DrawingEngine.start(false);
                }
                catch(exception){
                    alert(exception);
                }
            },
            centerModel: function() {
                var xCenter = Model.leftmostNode.xPosition + (Model.rightmostNode.xPosition - Model.leftmostNode.xPosition)/2;
                var yCenter = Model.topmostNode.yPosition + (Model.bottommostNode.yPosition - Model.topmostNode.yPosition)/2;
                var xAdjust = DrawingEngine.xContext(DrawingEngine.canvas.width/2) - xCenter;
                var yAdjust = DrawingEngine.yContext(DrawingEngine.canvas.height/2) - yCenter;
                DrawingEngine.translate(xAdjust, yAdjust);
                DrawingEngine.start(false);
            },
            randomizeLayout: function () {
                for(var i = 0; i < Model.nodes.length; i++) {
                    if(!Model.nodes[i].fixed) {
                        Model.nodes[i].xPosition = Math.random() * window.innerWidth;
                        Model.nodes[i].yPosition = Math.random() * window.innerHeight;
                    }
                }
                DrawingEngine.start(true);
            },
            toggleFixation: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].fixed = !Model.nodes[i].fixed;
                DrawingEngine.start(true);
            },
            releaseAll: function () {
                for(var i = 0; i < Model.nodes.length; i++)
                    Model.nodes[i].fixed = false;
                DrawingEngine.start(true);
            },
            toggleNames: function () {
                DrawingEngine.showNames = !DrawingEngine.showNames;
                DrawingEngine.start(false);
            }
        };

        var SettingsMenu = {
            init: function() {
                document.getElementById('damping').value = ((1 - LayoutEngine.damping) * 100).toFixed(0);
                document.getElementById('normalDistance').value = LayoutEngine.normalDistance.toFixed(0);
                document.getElementById('stoppingVelocity').value = LayoutEngine.stoppingVelocity.toFixed(1);
                document.getElementById('minimumStartingVelocity').value = LayoutEngine.minimumStartingVelocity.toFixed(1);
                document.getElementById('maximumStartingVelocity').value = LayoutEngine.maximumStartingVelocity.toFixed(1);
                document.getElementById('influenceConstant').value = LayoutEngine.influenceConstant.toFixed(0);
                document.getElementById('stiffness').value = LayoutEngine.stiffness.toFixed(1);
                document.getElementById('metric').value = 'manhattan';
                document.getElementById('FPS').value = FPS;
                document.getElementById('MINIRATE').value = MINIRATE;
            },
            resetSettings: function() {
                this.setDamping(4);
                this.setNormalDistance(30);
                this.setStoppingVelocity(0.1);
                this.setMinimumStartingVelocity(1);
                this.setMaximumStartingVelocity(5);
                this.setInfluenceConstant(4);
                this.setStiffness(3);
                this.setMetric('manhattan');
                this.setFPS(100);
                this.setMiniRate(50);
                this.init();
            },
            storeSettings: function(storage) {
                storage.setItem("damping", (1 - LayoutEngine.damping) * 100);
                storage.setItem("normalDistance", LayoutEngine.normalDistance);
                storage.setItem("stoppingVelocity", LayoutEngine.stoppingVelocity);
                storage.setItem("minimumStartingVelocity", LayoutEngine.minimumStartingVelocity);
                storage.setItem("maximumStartingVelocity", LayoutEngine.maximumStartingVelocity);
                storage.setItem("influenceConstant", LayoutEngine.influenceConstant);
                storage.setItem("stiffness", LayoutEngine.stiffness);
                storage.setItem("metric", document.getElementById('metric').value);
                storage.setItem("FPS", FPS);
                storage.setItem("MINIRATE", MINIRATE);
            },
            loadSettings: function(storage) {
                this.setDamping(storage.getItem('damping') || 4);
                this.setNormalDistance(storage.getItem('normalDistance') || 30);
                this.setStoppingVelocity(storage.getItem('stoppingVelocity') || 0.1);
                this.setMinimumStartingVelocity(storage.getItem('minimumStartingVelocity') || 1);
                this.setMaximumStartingVelocity(storage.getItem('maximumStartingVelocity') || 5);
                this.setInfluenceConstant(storage.getItem('influenceConstant') || 4);
                this.setStiffness(storage.getItem('stiffness') || 3);
                this.setMetric(storage.getItem('metric') || 'manhattan');
                this.setFPS(storage.getItem('FPS') || 100);
                this.setMiniRate(storage.getItem('MINIRATE') || 50);
                this.init();
            },
            setDamping: function(value) {
                LayoutEngine.damping = (100 - value)/100;
            },
            setNormalDistance: function(value) {
                LayoutEngine.normalDistance = 1 * value;
                LayoutEngine.attractionConstant = 1/value/value/value;
            },
            setStoppingVelocity: function(value) {
                LayoutEngine.stoppingVelocity = 1 * value;
            },
            setMinimumStartingVelocity: function(value) {
                LayoutEngine.minimumStartingVelocity = 1 * value;
            },
            setMaximumStartingVelocity: function(value) {
                LayoutEngine.maximumStartingVelocity = 1 * value;
            },
            setInfluenceConstant: function(value) {
                LayoutEngine.influenceConstant = 1 * value;
            },
            setStiffness: function(value) {
                LayoutEngine.stiffness = 1 * value;
                LayoutEngine.stiffnessBound = value * value;
            },
            setMetric: function(value) {
                LayoutEngine.metric = LayoutEngine[value];
            },
            setFPS: function(value) {
                FPS = 1 * value;
            },
            setMiniRate: function(value) {
                MINIRATE = 1 * value;
            },
            toggleDebug: function () {
                DEBUG = !DEBUG;
                DrawingEngine.start(false);
            }
        };

        var ControlButtons = {
            playPauseButton: null,
            nudgeButton: null,
            undoButton: null,
            redoButton: null,
            zoomInButton: null,
            zoomOutButton: null,
            zoomFactor: 1.75,
            init: function() {
                this.playPauseButton = document.getElementById('playpause');
                this.undoButton = document.getElementById('undo');
                this.redoButton = document.getElementById('redo');
                this.zoomInButton = document.getElementById('zoomin');
                this.zoomOutButton = document.getElementById('zoomout');

                // voodoo
                var self = this;

                this.playPauseButton.addEventListener('click', function(event) { return self.togglePlayPause(event) },  false);
                this.undoButton.addEventListener('click', function(event) { return self.undo(event) }, false);
                this.redoButton.addEventListener('click', function(event) { return self.redo(event) }, false);
                this.zoomInButton.addEventListener('click', function(event) { return self.zoomIn(event) }, false);
                this.zoomOutButton.addEventListener('click', function(event) { return self.zoomOut(event) }, false);
            },
            togglePlayPause: function (event) {
                if(DrawingEngine.running) {
                    DrawingEngine.stop();
                }
                else if (LayoutEngine.equilibrium) {
                    this.invalidateLayout();
                }
                else {
                    DrawingEngine.start(false);
                }
            },
            setUndoLevels: function(numberOfLevels) {
                var undos = '';
                if(numberOfLevels)
                    undos = ' (' + numberOfLevels + ')';
                this.undoButton.firstChild.nodeValue = 'Undo' + undos;
            },
            setRedoLevels: function(numberOfLevels) {
                var redos = '';
                if(numberOfLevels)
                    redos = ' (' + numberOfLevels + ')';
                this.redoButton.firstChild.nodeValue = 'Redo' + redos;
            },
            undo: function() {
                Model.undoState();
                DrawingEngine.start(false);
            },
            redo: function() {
                Model.redoState();
                DrawingEngine.start(false);
            },
            setPlayState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Play';
                this.playPauseButton.className = 'pausing';
            },
            setPauseState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Pause';
                this.playPauseButton.className = 'playing';
            },
            invalidateLayout: function () {
                for(var i = 0; i < Model.nodes.length; i++) {
                    Model.nodes[i].start();
                }
                DrawingEngine.start(true);
            },
            doZoom: function (zoom) {
                DrawingEngine.scale(zoom);
                var xx = window.innerWidth/2;
                var yy = window.innerHeight/2;
                DrawingEngine.translate(DrawingEngine.xContext(xx) - DrawingEngine.xContext(xx) * zoom,
                        DrawingEngine.yContext(yy) - DrawingEngine.yContext(yy) * zoom);
                DrawingEngine.start(false);
            },
            zoomIn: function (event) {
                this.doZoom(this.zoomFactor);
            },
            zoomOut: function (event) {
                this.doZoom(1/this.zoomFactor);
            }
        };        

        // make sure our init function is called when the page is loaded
        window.onload = function() { try { init(this); } catch(e) { alert(e); } };

        // implementation of our init function
        function init(window) {
            // assign event handlers to buttons
            ControlButtons.init();

            // set values in the settings input fields
            SettingsMenu.init();

            var canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext;

            // get the canvas element
            canvas = document.getElementById('canvas');
            if (!canvas || !canvas.getContext) {
                alert("Cannot find the canvas!");
                return;
            }
            // get the canvas 2d context
            context = canvas.getContext('2d');
            if (!context) {
                alert("The canvas has no 2d context!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(canvas, context);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(canvas, context) }, false);

            shadowCanvas = document.getElementById('shadow');
            if (!shadowCanvas || !shadowCanvas.getContext) {
                alert("Cannot find the shadow canvas!");
                return;
            }
            // get the shadow canvas 2d context
            shadowContext = shadowCanvas.getContext('2d');
            if (!shadowContext) {
                alert("The shadow canvas has no 2d context!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(shadowCanvas, shadowContext);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(shadowCanvas, shadowContext) }, false);

            miniatureCanvas = document.getElementById('miniature');
            if (!miniatureCanvas || !miniatureCanvas.getContext) {
                alert("Cannot find the miniature canvas!");
                return;
            }
            // get the shadow canvas 2d context
            miniatureContext = miniatureCanvas.getContext('2d');
            if (!miniatureContext) {
                alert("The miniature canvas has no 2d context!");
                return;
            }

            DrawingEngine.init(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext);

            canvas.CanvasEventHandler = CanvasEventHandler;
            // attach the mousedown, mousemove and mouseup event listeners to the visible canvas
            canvas.addEventListener('mousedown', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousemove', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mouseup', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousewheel', CanvasEventHandler.handleEvent, false); // Safari and Chrome
            canvas.addEventListener('DOMMouseScroll', CanvasEventHandler.handleEvent, false); // Firefox

            // setting a listener on the canvas did not work, so this is a workaround
            // we are currently not listening to keyboard events
            // window.onkeydown = CanvasEventHandler.handleEvent;

            miniatureCanvas.MiniatureEventHandler = MiniatureEventHandler;
            miniatureCanvas.addEventListener('mousedown', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mousemove', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mouseup', MiniatureEventHandler.handleEvent, false);

            var model;
            if(model = window.localStorage.getItem("model"))
                Model.fromXML(new DOMParser().parseFromString(model, 'text/xml'));
            else
                ActionsMenu.loadFromURL('example.xml');

            SettingsMenu.loadSettings(window.localStorage);
            DrawingEngine.loadSettings(window.localStorage);
            DrawingEngine.start(true);
        }

        // make sure our exit function is called when the page is unloaded
        window.onbeforeunload = function() {
            return "Are you absolutely sure you want to leave?\nAny unsaved changes will be lost!";
        };

        window.onunload = function() { try { exit(this); } catch(e) { alert(e); } };
        
        function exit(window) {
            window.localStorage.setItem("model", new XMLSerializer().serializeToString(Model.toXML()));
            SettingsMenu.storeSettings(window.localStorage);
            DrawingEngine.storeSettings(window.localStorage);
        }
        
        // -->
    </script>
</head>
<body>
    <canvas id="canvas" class="unselectable">
        Your browser does not support HTML5 canvas!
    </canvas>
    <canvas id="shadow" class="unselectable">
        <!-- we paint objects in "false" colors on this canvas and use that to identify them with mouse clicks -->
    </canvas>

    <div id="header" class="unselectable">
        <div id="actions">
            <ul class="menu">
                <li>Actions
                    <ul class="submenu">
                        <li onclick="Model.setupMinimal()">Empty model...</li>
                        <li>Load XML file...<input class="invisible" type="file" onchange="FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this);"/></li>
                        <li onclick="ActionsMenu.toggleNames()">Toggle names</li>
                        <li onclick="ActionsMenu.toggleFixation()">Toggle fixation</li>
                        <li onclick="ActionsMenu.releaseAll()">Release all fixed</li>
                        <li onclick="ActionsMenu.centerModel()">Center model</li>
                        <li onclick="ActionsMenu.randomizeLayout()">Randomize layout</li>
                        <li onclick="ActionsMenu.loadFromURL('example.xml')">Load example model</li>
                        <li onclick="new CodePopover(ActionsMenu.transform(Model.toXML(), 'xml2html.xsl'), false)">Generate XML representation</li>
                        <li onclick="new CodePopover(ActionsMenu.transform(Model.toXML(), 'SQLServer.xsl'), true)">Generate SQL code</li>
                        <li onclick="window.open(DrawingEngine.canvas.toDataURL('image/png'), '_newtab')">Generate PNG image</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div id="controls">
            <ul class="control">
                <li id="playpause">Pause</li>
                <li id="undo">Undo</li>
                <li id="redo">Redo</li>
                <li id="zoomin">Zoom In</li>
                <li id="zoomout">Zoom Out</li>
            </ul>
        </div>

        <!-- TODO: focus gets "stuck" on the input fields below sometimes, annoying! -->
        <div id="settings" class="unselectable" title="Expert settings">
            <ul class="menu">
                <li>Settings
                    <ul class="submenu">
                        <li><input id="damping" type="number" min="0" max="99" step="1" size="4" onblur="SettingsMenu.setDamping(this.value)"/> % Damping</li>
                        <li><input id="normalDistance" type="number" min="10" max="90" step="5" size="4" onblur="SettingsMenu.setNormalDistance(this.value)"/> px Normal distance</li>
                        <li><input id="stoppingVelocity" type="number" min="0" max="9" step="0.1" size="4" onblur="SettingsMenu.setStoppingVelocity(this.value)"/> px/s Stopping velocity</li>
                        <li><input id="minimumStartingVelocity" type="number" min="0" max="9" step="0.1" size="4" onblur="SettingsMenu.setMinimumStartingVelocity(this.value)"/> px/s Minimum starting velocity</li>
                        <li><input id="maximumStartingVelocity" type="number" min="0" max="9" step="0.1" size="4" onblur="SettingsMenu.setMaximumStartingVelocity(this.value)"/> px/s Maximum starting velocity</li>
                        <li><input id="influenceConstant" type="number" min="0" max="10" step="1" size="4" onblur="SettingsMenu.setInfluenceConstant(this.value)"/> Node influence factor</li>
                        <li><input id="stiffness" type="number" min="1" max="9" step="0.5" size="4" onblur="SettingsMenu.setStiffness(this.value)"/> Edge stiffness factor</li>
                        <li><select id="metric" onchange="SettingsMenu.setMetric(this.value)"><option value="manhattan" selected="selected">Manhattan</option><option value="euclidean">Euclidean</option></select> Metric</li>
                        <li><input id="FPS" type="number" min="10" max="1000" step="10" size="4" onblur="SettingsMenu.setFPS(this.value)"/> fps Target frame rate</li>
                        <li><input id="MINIRATE" type="number" min="1" max="99" step="1" size="4" onblur="SettingsMenu.setMiniRate(this.value)"/> Miniature refresh interval</li>
                        <li onclick="SettingsMenu.resetSettings()">Reset settings to default values</li>
                        <li onclick="SettingsMenu.toggleDebug()">Toggle debug</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>


    <canvas id="miniature" class="unselectable" title="This is the Navigation Window.&#10;It will always show the whole model&#10;with the current viewport shown by&#10;a red outline. Click and drag to&#10;move the viewport.">
        <!-- shows a navigatable miniature of the model -->
    </canvas>
</body>
</html>