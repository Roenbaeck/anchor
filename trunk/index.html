<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <title>Anchor Modeler</title>
    <style type="text/css">
    body {
        font:               75% georgia, sans-serif;
        line-height:        1.88889;
        color:              #000000;
        background:         #f9f8f7;
        overflow:           hidden;
        margin:             0;
        padding:            0;
    }

    .closebutton {
        display:            none;
        background-image:   url(deleteButton.png);
        position:           absolute;
        left:               -15px;
        top:                -15px;
        height:             30px;
        width:              30px;
        z-index:            999;
    }
    .closebutton:active {
        background-image:   url(deleteButtonPressed.png);
    }
    
    /* visible canvas - at the bottom of the visible layers */
    #canvas {
        position:           absolute;
        top:                0;
        left:               0;
        z-index:            1;
    }

    /* invisible canvas - at the very bottom */
    #shadow {
        position:           absolute;
        top:                0;
        left:               0;
        display:            none;
        z-index:            0;
    }

    /* minature canvas - positioned in the southeast corner */
    #miniature {
        position:           absolute;
        bottom:             30px;
        right:              30px;
        background-color:   rgba(255, 255, 255, 0.8);
        z-index:            2;
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }

    /* the leftmost part of the header - on top of the background */
    #header {
        position:           absolute;
        top:                0;
        left:               0;
        width:              98%; /* have no idea why, but 100% is too wide */
        border-bottom:      1px dotted;
        background-color:   rgba(255, 255, 255, 0.8);
        color:              black;
        padding:            5px 10px;
        margin:             0;
        text-align:         left;
        z-index:            3;
    }

    #menu {
        position:           absolute;
        top:                0;
        left:               0;
        display:            none;
        background-color:   rgba(255, 255, 255, 0.8);
        color:              black;
        padding:            5px 10px;
        margin:             0;
        text-align:         left;
        border:             1px dotted;
        z-index:            4;
        -webkit-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5);
        -moz-box-shadow:    0px 5px 10px rgba(0, 0, 0, 0.5);
    }

    #modalBackground {
        position:           absolute;
        top:                0;
        left:               0;
        background-color:   rgba(16, 0, 0, 0.2);
        margin:             0;
        padding:            0;
        overflow:           hidden;
        z-index:            10;
    }

    /* these classes style the xml representation */
    #codePopover {
        position:           relative;
        border:             2px solid black;
        margin:             auto;
        display:            table;
        background-color:   rgba(8, 0, 0, 0.8);
        z-index:            6;
        -webkit-box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.5);        
        -moz-box-shadow:    0px 10px 20px rgba(0, 0, 0, 0.5);
        z-index:            11;
    }
    #codePopover:hover .closebutton {
        display:            block;
    }
    
    #content {
        position:           relative;
        text-align:         left;
        font:               125% Andale Mono, monospace;
        padding:            15px 20px;
        overflow:           auto;
        background-color:   transparent;
        z-index:            7;
    }
    #content .tabs {
        visibility:         hidden;
    }
    #content .brackets {
        color:              white;
    }
    #content .elements {
        color:              #ffffc0;
    }
    #content .attributes {
        color:              #c0c0c0;
        font-weight:        bold;
    }
    #content .values {
        color:              #ffc0c0;
        font-style:         italic;
    }
    </style>

    <script type="text/javascript">
        <!--
        // set to true to show debugging information
        var DEBUG = false;

        // frames per second - set low when debugging
        var FPS = 1000;

        // draw the miniature every minirate frames
        var MINIRATE = 50;

        // create a singleton
        var LayoutEngine = {
            // normal distance in pixels
            normalDistance: 30,
            // 4 percent damping (simulated friction)
            damping: 0.96,
            // stopping velocity is one tenth of a pixel per second
            stoppingVelocity: 0.1,
            // minimum starting velocity is a whole pixel
            minimumStartingVelocity: 1,
            // maximum starting velocity is higher (to remove "twitching" when few nodes are moving)
            maximumStartingVelocity: 5,
            // calculated as 1/normalDistance^3, assuming that the repelling factor is -1
            attractionConstant: 0.00003703703704,
            // adjusts the size of the influence square by this factor
            influenceConstant: 4,
            // when the layout has reached equilibrium
            equilibrium: true,

            // for some reason Math.abs is slower than this
            absolute: function(value) {
                return value < 0 ? -value : value;
            },

            // use our own squaring algorithm rather than Math.pow
            square: function(value) {
                return value * value;
            },
            // measures distance between two nodes
            distance: function(node, otherNode) {
                var d = this.metric(node.xPosition, node.yPosition, otherNode.xPosition, otherNode.yPosition);
                if(d > 0)
                    return d;
                // move one node a pixel to the right if both nodes overlap
                node.xPosition +=1;
                return 1;
            },
            // use the taxi cab metric for measuring distances
            metric: function(x1, y1, x2, y2) {
                return this.absolute(x2 - x1) + this.absolute(y2 - y1);
            },
            // x component of the repelling force formula
            xRepelling: function(node, otherNode) {
                return (node.xPosition - otherNode.xPosition)/this.square(this.distance(node, otherNode));
            },

            // y component of the repelling force formula
            yRepelling: function(node, otherNode) {
                return (node.yPosition - otherNode.yPosition)/this.square(this.distance(node, otherNode));
            },

            // x component of the attracting force formula
            xAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.xPosition - node.xPosition) * this.distance(node, otherNode);
            },

            // y component of the attracting force formula
            yAttracting: function (node, otherNode) {
                return this.attractionConstant * (otherNode.yPosition - node.yPosition) * this.distance(node, otherNode);
            },
            // create the square of influence
            createSquare: function(node, offset) {
                return {
                    xMin: node.xPosition - offset,
                    xMax: node.xPosition + offset,
                    yMin: node.yPosition - offset,
                    yMax: node.yPosition + offset
                };
            },
            // check if a node falls within the square of influence
            withinSquare: function(otherNode, square) {
                return  otherNode.xPosition >= square.xMin &&
                        otherNode.xPosition <= square.xMax &&
                        otherNode.yPosition >= square.yMin &&
                        otherNode.yPosition <= square.yMax;
            },

            // calculate all forces and change the velocity and position of the node
            layout: function(model) {
                // assume equilibrium - set to false below if a node moves
                this.equilibrium = true;

                var i, j, node, otherNode, edge, absoluteVelocity, curvature, square;
                var numberOfNodes = model.nodes.length;
                var numberOfStoppedNodes = 0;
                var startingVelocityDelta = this.maximumStartingVelocity - this.minimumStartingVelocity;

                for(i = 0; node = model.nodes[i]; i++) {
                    square = this.createSquare(node, this.influenceConstant * this.normalDistance);
                    for(j = 0; otherNode = model.nodes[j]; j++) {
                        // not the same node
                        if(i != j) {
                            // for nodes within range, add the repelling velocity
                            if(this.withinSquare(otherNode, square)) {
                                node.xVelocity += this.xRepelling(node, otherNode);
                                node.yVelocity += this.yRepelling(node, otherNode);
                            }
                        }
                        // the first iteration we count the number of stopped nodes
                        if(j == 0 && (!otherNode.moving || otherNode.fixed)) {
                            numberOfStoppedNodes++;
                        }
                    }
                    // bending force (straightens out edges)
                    if(node instanceof Edge) {
                        // update the control and center points
                        node.controlPoint.xPosition = 2 * node.xPosition - node.node.xPosition / 2 - node.otherNode.xPosition / 2;
                        node.controlPoint.yPosition = 2 * node.yPosition - node.node.yPosition / 2 - node.otherNode.yPosition / 2;
                        node.centerPoint.xPosition = node.node.xPosition + (node.otherNode.xPosition - node.node.xPosition) / 2;
                        node.centerPoint.yPosition = node.node.yPosition + (node.otherNode.yPosition - node.node.yPosition) / 2;
                        curvature = this.square(3 * this.distance(node.centerPoint, node.controlPoint)/this.distance(node.node, node.otherNode));
                        // safeguard
                        curvature = curvature > 9 ? 9 : curvature;
                        // flexure force moves the midway point toward the center point
                        node.xVelocity -= curvature * this.xRepelling(node, node.centerPoint);
                        node.yVelocity -= curvature * this.yRepelling(node, node.centerPoint);
                    }
                    // for all edges, add the attracting velocity
                    for(j = 0; edge = node.edges[j]; j++) {
                        node.xVelocity += this.xAttracting(node, edge)/node.edges.length;
                        node.yVelocity += this.yAttracting(node, edge)/node.edges.length;
                    }
                    // apply damping
                    node.xVelocity *= this.damping;
                    node.yVelocity *= this.damping;
                    absoluteVelocity = this.absolute(node.xVelocity) + this.absolute(node.yVelocity);
                    // check to see if the node has stopped moving
                    if(absoluteVelocity <= this.stoppingVelocity)
                        node.stop();
                    // the more nodes that have stopped, the larger the starting velocity must be
                    if(absoluteVelocity >= this.minimumStartingVelocity + startingVelocityDelta * numberOfStoppedNodes / numberOfNodes)
                        node.start();
                    // if the node is moving and not fixed then calculate the new position
                    if(node.moving && !node.fixed) {
                        this.equilibrium = false;
                        node.xPosition += node.xVelocity;
                        node.yPosition += node.yVelocity;
                    }
                    if(node.yPosition < model.topmostNode.yPosition)
                        model.topmostNode = node;
                    if(node.xPosition > model.rightmostNode.xPosition)
                        model.rightmostNode = node;
                    if(node.yPosition > model.bottommostNode.yPosition)
                        model.bottommostNode = node;
                    if(node.xPosition < model.leftmostNode.xPosition)
                        model.leftmostNode = node;
                }
            }
        };

        var UniqueColor = {
            // note that #000000 is reserved for the background and never assigned
            takenColors: {},
            formatColor: function(red, green, blue) {
                return '#' +
                        ('0' + red.toString(16)).slice(-2) +
                        ('0' + green.toString(16)).slice(-2) +
                        ('0' + blue.toString(16)).slice(-2);
            },
            reserveUniqueColor: function() {
                var r = Math.random() * 255;
                var g = Math.random() * 255;
                var b = Math.random() * 255;
                var color = this.formatColor(r, g, b);
                if(this.takenColors[color] || (r + g + b) == 0)
                    return this.reserveUniqueColor();
                return color;
            },
            releaseUniqueColor: function(color) {
                delete this.takenColors[color];
            }
        };

        var Model = {
            nodes: [],
            edges: [],
            shadowToNode: {},
            topmostNode: null,
            rightmostNode: null,
            bottommostNode: null,
            leftmostNode: null,
            empty: function() {
                this.nodes = [];
                this.edges = [];
                this.shadowToNode = {};
                this.topmostNode = null;
                this.rightmostNode = null;
                this.bottommostNode = null;
                this.leftmostNode = null;                
            },
            sort: function() {
                this.nodes.sort(function(a, b) {
                    if (a instanceof Edge)
                        return -1;
                    if (a instanceof Knot && !(b instanceof Edge))
                        return -1;
                    if (a instanceof Anchor && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    if (a instanceof Attribute && !(b instanceof Anchor) && !(b instanceof Edge) && !(b instanceof Knot))
                        return -1;
                    return 1;
                });
            },
            addNode: function(node) {
                // add node at the end of the array
                if(node) {
                    this.nodes[this.nodes.length] = node;
                    this.sort();
                    this.shadowToNode[node.shadowColor] = node;
                    if(this.topmostNode == null || node.yPosition < this.topmostNode.yPosition)
                        this.topmostNode = node;
                    if(this.rightmostNode == null || node.xPosition > this.rightmostNode.xPosition)
                        this.rightmostNode = node;
                    if(this.bottommostNode == null || node.yPosition > this.bottommostNode.yPosition)
                        this.bottommostNode = node;
                    if(this.leftmostNode == null || node.xPosition < this.leftmostNode.xPosition)
                        this.leftmostNode = node;
                    this.invalidateNode(node);                    
                }
            },
            removeNode: function(node) {
                UniqueColor.releaseUniqueColor(node.shadowColor);
                delete this.shadowToNode[node.shadowColor];
                this.deleteElementFromArray(this.nodes, node);
            },
            addEdge: function(edge) {
                // the edge is also a node
                if(edge) {
                    this.addNode(edge);
                    this.edges[this.edges.length] = edge;                    
                }
            },
            removeEdge: function(edge) {
                this.removeNode(edge);
                this.deleteElementFromArray(this.edges, edge);
                this.deleteElementFromArray(edge.node.edges, edge);
                this.deleteElementFromArray(edge.otherNode.edges, edge);
            },
            getNodeFromShadow: function(shadow) {
                return this.shadowToNode[shadow];
            },
            deleteElementFromArray: function(array, element) {
                for(var i = 0; element != array[i]; i++);
                array.splice(i, 1);
            },
            invalidateNode: function(node) {
                var square = LayoutEngine.createSquare(node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.nodes.length; i++)
                    if(LayoutEngine.withinSquare(this.nodes[i], square))
                        this.nodes[i].start();
            },
            toXML: function() {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                for(var i = 0; i < this.nodes.length; i++) {
                    var node = this.nodes[i].toXML(schema);
                    if(node != null)
                        schema.documentElement.appendChild(node);
                }
                return schema;
            },
            fromXML: function(xml) {
                if(xml) {
                    this.empty();
                    var i, knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addNode(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addNode(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addNode(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addNode(Tie.prototype.fromXML(ties[i]));
                }
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            canvas: null,
            shadowCanvas: null,
            miniatureCanvas: null,
            context: null,
            shadowContext: null,
            miniatureContext: null,
            running: false,
            hoveredNodes: {},
            xyScale: 1,
            xTranslation: 0,
            yTranslation: 0,
            miniScale: 0.3,
            miniPadding: 50,
            miniWidth: 0,
            miniHeight: 0,
            miniCounter: 0,
            miniature: null,
            init: function(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext) {
                this.canvas = canvas;
                this.shadowCanvas = shadowCanvas;
                this.miniatureCanvas = miniatureCanvas;
                this.context = context;
                this.shadowContext = shadowContext;
                this.miniatureContext = miniatureContext;
                this.miniature = document.getElementById('miniature');
            },
            scale: function(scale) {
                this.xyScale *= scale;
                this.context.scale(scale, scale);
                this.shadowContext.scale(scale, scale);
            },
            translate: function(x, y) {
                this.xTranslation += x * this.xyScale;
                this.yTranslation += y * this.xyScale;
                this.context.translate(x, y);
                this.shadowContext.translate(x, y);
            },
            xContext: function(xScreen) {
                return Math.round((xScreen - this.xTranslation) / this.xyScale);
            },
            yContext: function(yScreen) {
                return Math.round((yScreen - this.yTranslation) / this.xyScale);
            },
            xScreen: function(xContext) {
                return Math.round(xContext * this.xyScale + this.xTranslation);
            },
            yScreen: function(yContext) {
                return Math.round(yContext * this.xyScale + this.yTranslation);
            },
            addHovered: function(hoveredNode) {
                this.hoveredNodes[hoveredNode.id] = hoveredNode;
            },
            removeHovered: function(hoveredNode) {
                delete this.hoveredNodes[hoveredNode.id];
            },
            getNodeAt: function(x, y) {
                // clear the shadow context
                this.shadowContext.fillStyle = '#000000';
                this.shadowContext.fillRect(0, 0, this.shadowCanvas.width, this.shadowCanvas.height);

                var i, node;
                // draw all nodes on the shadow context
                for(i = 0; node = Model.nodes[i]; i++)
                    node.drawShadow(this.shadowContext);

                var data = this.shadowContext.getImageData(x, y, 1, 1).data;
                return Model.getNodeFromShadow(UniqueColor.formatColor(data[0], data[1], data[2]));
            },
            start: function() {
                this.invalidateMiniature();
                if(!this.running) {
                    this.running = true;
                    this.drawId = setInterval(function() { DrawingEngine.draw(); }, 1000 / FPS);
                }
            },
            stop: function() {
                if(this.running) {
                    clearInterval(this.drawId);
                    this.running = false;
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            draw: function() {
                // layout nodes
                LayoutEngine.layout(Model);
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    clearInterval(this.drawId);
                    this.running = false;
                    this.invalidateMiniature();
                }

                // clear the visible context
                this.context.clearRect(-this.xTranslation/this.xyScale, -this.yTranslation/this.xyScale, this.canvas.width/this.xyScale, this.canvas.height/this.xyScale);

                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % MINIRATE;
                if(this.miniCounter == 1)
                    this.drawMiniature(Model);

                var i, node, nodeId;
                // draw palette around hovering nodes
                for(nodeId in this.hoveredNodes) {
                    node = this.hoveredNodes[nodeId];
                    this.drawPalette(node.xPosition, node.yPosition);
                }

                // draw all nodes and edges on the visible context
                for(i = 0; node = Model.nodes[i]; i++) {
                    node.drawMoving(this.context);
                    node.draw(this.context);
                    if(this.miniCounter == 1)
                        node.draw(this.miniatureContext);
                }
            },
            drawMiniature: function(model) {
                this.miniWidth = model.rightmostNode.xPosition - model.leftmostNode.xPosition + 2 * this.miniPadding;
                this.miniHeight = model.bottommostNode.yPosition - model.topmostNode.yPosition + 2 * this.miniPadding;
                this.miniatureCanvas.width = this.miniScale * this.miniWidth;
                this.miniatureCanvas.height = this.miniScale * this.miniHeight;
                this.miniature.style.width = this.miniatureCanvas.width;
                this.miniature.style.height = this.miniatureCanvas.height;
                this.miniatureContext.setTransform(this.miniScale, 0, 0, this.miniScale, this.miniScale * (this.miniPadding - Model.leftmostNode.xPosition), this.miniScale * (this.miniPadding - Model.topmostNode.yPosition));

                // show the viewport on the miniature
                this.miniatureContext.strokeStyle = '#bb5555';
                this.miniatureContext.lineWidth = 1/this.miniScale;
                this.miniatureContext.strokeRect(-this.xTranslation/this.xyScale, -this.yTranslation/this.xyScale, this.canvas.width/this.xyScale, this.canvas.height/this.xyScale);
            },
            drawPalette: function(x, y) {
                this.context.beginPath();
                this.context.arc(x, y, LayoutEngine.normalDistance, 0, 2*Math.PI, false);
                this.context.strokeStyle = '#ebe8e8';
                this.context.lineWidth = 10;
                this.context.stroke();
            }
        };

        var ResizeHandler = {
            resizeCanvas: function(canvas, context) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                // apparently changing the canvas width or height resets the transform
                context.setTransform(DrawingEngine.xyScale, 0, 0, DrawingEngine.xyScale, DrawingEngine.xTranslation, DrawingEngine.yTranslation);
                DrawingEngine.start();
            }
        };

        var CanvasEventHandler = {
            dragging: false,
            menu: false,
            focusedNode: null,
            xLastKnown: 0,
            yLastKnown: 0,
            hoveringPrepared: false,
            hoveringId: null,
            hoveredNode: null,
            mousedown: function(event) {
                this.focusedNode = DrawingEngine.getNodeAt(event.xScreen, event.yScreen);
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    // if we are dragging a node, we must also be hovering over it
                    if(this.focusedNode) {
                        this.focusedNode.xPosition = DrawingEngine.xContext(event.xScreen);
                        this.focusedNode.yPosition = DrawingEngine.yContext(event.yScreen);
                        this.focusedNode.fixed = true;
                        Model.invalidateNode(this.focusedNode);
                    }
                    // if the dragging started over an empty part of the canvas
                    else {
                        DrawingEngine.translate((event.xScreen - this.xLastKnown)/DrawingEngine.xyScale, (event.yScreen - this.yLastKnown)/DrawingEngine.xyScale);
                    }
                    DrawingEngine.start();
                }
                else {
                    // we are hovering, but not dragging
                    if(this.hoveredNode && !this.menu) {
                        if(LayoutEngine.distance(this.hoveredNode, {xPosition: DrawingEngine.xContext(event.xScreen), yPosition: DrawingEngine.yContext(event.yScreen)}) > 1.5 * LayoutEngine.normalDistance) {
                            DrawingEngine.removeHovered(this.hoveredNode);
                            this.hoveredNode = null;
                            this.hoveringPrepared = false;
                            DrawingEngine.start();
                        }
                    }
                    // if we are not hovering, set up a check in half a second
                    else if (!this.hoveringPrepared) {
                        this.hoveringPrepared = true;
                        this.hoveringId = setTimeout(function(reallyThis) { reallyThis.mousehover(event); }, 500, this);
                    }
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mousehover: function(event) {
                this.hoveredNode = DrawingEngine.getNodeAt(this.xLastKnown, this.yLastKnown);
                // mouse pointer over node
                if(this.hoveredNode) {
                    DrawingEngine.addHovered(this.hoveredNode);
                    DrawingEngine.start();
                    this.keydown(event);
                }
                // mouse pointer not over node, trigger a new check
                else {
                    this.hoveringPrepared = false;
                }
            },
            keydown: function(event) {
                if(event.shiftKey && this.hoveredNode) {
                    if(this.menu) {
                        this.menu = false;
                        MenuHandler.hide();
                    }
                    else {
                        MenuHandler.show(this.hoveredNode);
                        this.menu = true;
                    }
                }
            },
            // this is special Firefox handling
            DOMMouseScroll: function(event) {
                event.wheelDelta = event.detail * 120;
                this.mousewheel(event);
            },
            mousewheel: function(event) {
                var zoom = 1 + 10/event.wheelDelta;
                DrawingEngine.scale(zoom);
                DrawingEngine.translate(DrawingEngine.xContext(event.xScreen) - DrawingEngine.xContext(event.xScreen) * zoom, DrawingEngine.yContext(event.yScreen) - DrawingEngine.yContext(event.yScreen) * zoom);
                DrawingEngine.start();
            },
            mouseup: function(event) {
                // the dragging started over a node
                if(this.focusedNode) {
                    if(event.altKey)
                        this.focusedNode.fixed = !this.focusedNode.fixed;
                    this.focusedNode = null;
                }
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.start();
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.CanvasEventHandler[event.type])
                    this.CanvasEventHandler[event.type](event);
            },
            toggleKnotted: function() {
                var knot, edge;
                if(this.hoveredNode.knotted) {
                    for(var i = 0; edge = this.hoveredNode.edges[i]; i++) {
                        if(edge.otherNode instanceof Knot) {
                            Model.removeNode(edge.otherNode);
                            Model.removeEdge(edge);
                        }
                    }
                    this.hoveredNode.knotted = false;
                }
                else {
                    knot = new Knot(this.hoveredNode.xPosition + 2 * LayoutEngine.normalDistance, this.hoveredNode.yPosition - 2 * LayoutEngine.normalDistance, "Unnamed");
                    Model.addNode(knot);
                    edge = new Edge(this.hoveredNode, knot, this.hoveredNode + "_Unnamed", true);
                    Model.addEdge(edge);
                    this.hoveredNode.knotted = true;
                }
                DrawingEngine.start();
            },
            toggleHistorized: function() {
                if(this.hoveredNode) {
                    this.hoveredNode.historized = !this.hoveredNode.historized;
                    DrawingEngine.start();
                }
            },
            addAttribute: function() {
                var attribute = new Attribute(this.hoveredNode.xPosition + 2 * LayoutEngine.normalDistance, this.hoveredNode.yPosition - 3 * LayoutEngine.normalDistance, "Unnamed", false);
                Model.addNode(attribute);
                var edge = new Edge(this.hoveredNode, attribute, this.hoveredNode + "_Unnamed", true);
                Model.addEdge(edge);
                DrawingEngine.start();
            }
        };

        var MiniatureEventHandler = {
            dragging: false,
            xLastKnown: 0,
            yLastKnown: 0,
            mousedown: function(event) {
                // TODO: Position the viewport under mousepointer on click
                this.dragging = true;
            },
            mousemove: function(event) {
                if (this.dragging) {
                    DrawingEngine.translate((this.xLastKnown - event.xScreen)/DrawingEngine.miniScale, (this.yLastKnown - event.yScreen)/DrawingEngine.miniScale);
                    DrawingEngine.start();
                }
                this.xLastKnown = event.xScreen;
                this.yLastKnown = event.yScreen;
            },
            mouseup: function(event) {
                if (this.dragging)
                    this.dragging = false;
                DrawingEngine.start();
            },
            handleEvent: function(event) {
                // note that "this" refers to the object on which we attached the event handler
                event.xScreen = event.clientX
                        + document.body.scrollLeft
                        + document.documentElement.scrollLeft
                        - this.offsetLeft;
                event.yScreen = event.clientY
                        + document.body.scrollTop
                        + document.documentElement.scrollTop
                        - this.offsetTop;

                if(this.MiniatureEventHandler[event.type])
                    this.MiniatureEventHandler[event.type](event);
            }
        };


        var MenuHandler = {
            menu: null,
            init: function () {
                menu = document.getElementById('menu');
                this.hide();
            },
            show: function(node) {
                var x = DrawingEngine.xScreen(node.xPosition + LayoutEngine.normalDistance/2);
                var y = DrawingEngine.yScreen(node.yPosition + LayoutEngine.normalDistance/2);

                var action, content;
                content = "Node: <input type=\"text\" value=\"" + node + "\" autofocus/>";
                for(var i = 0; action = node.actions[i]; i++)
                    content += "<br/>" + action;

                menu.innerHTML = content;
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
                // show the menu
                menu.style.display = 'block';
            },
            hide: function() {
                menu.style.display = 'none';
            }
        };


        function AbstractNode(x, y, name) {
            this.name = name;
            this.xPosition = x;
            this.yPosition = y;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.moving = true;
            this.fixed = false;
            this.shadowColor = UniqueColor.reserveUniqueColor();
            this.id = this.shadowColor;
            this.edges = [];
            this.actions = [];
        }
        AbstractNode.prototype = {
            id: null,
            name: null,
            description: null,
            xPosition: null,
            yPosition: null,
            xVelocity: null,
            yVelocity: null,
            edges: null,
            moving: true,
            fixed: false,
            shadowColor: '#ffffff',
            actions: null,
            // override toString in order to provide a unique identifier to be used when emulating hash maps
            toString: function() {
                return this.name.toString();
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addLayoutXML: function(element, schema) {
                if(this.description != null) {
                    var description = schema.createElement("description");
                    description.innerHTML = this.description;
                    element.appendChild(description);
                }
                var layout = schema.createElement("layout");
                layout.setAttribute("x", this.xPosition.toFixed(2));
                layout.setAttribute("y", this.yPosition.toFixed(2));
                layout.setAttribute("fixed", this.fixed);
                element.appendChild(layout);
            },
            stop: function() {
                this.moving = false;
            },
            // movement is propagated to the edges of a node
            start: function() {
                this.moving = true;
                for(var i = 0; i < this.edges.length; i++)
                    this.edges[i].start();
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(context) {
                if(DEBUG) {
                    context.beginPath();
                    context.moveTo(this.xPosition, this.yPosition);
                    // draw an exaggerated velocity vector
                    context.lineTo(this.xPosition + LayoutEngine.normalDistance * this.xVelocity, this.yPosition + LayoutEngine.normalDistance * this.yVelocity);
                    context.strokeStyle = '#008800';
                    context.lineWidth = 0.5;
                    context.stroke();
                    context.fillStyle = '#ffffff';
                    context.fillRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                    context.strokeRect(this.xPosition + LayoutEngine.normalDistance * this.xVelocity - 3, this.yPosition + LayoutEngine.normalDistance * this.yVelocity - 3, 6, 6);
                }
            },
            // this is how a node draws itself on the shadow context
            drawShadow: function(context) {
                this.drawOutline(context);
                context.fillStyle = this.shadowColor;
                context.fill();
            },
            // this is used to draw the outline of a node, used in the shadow context
            drawOutline: function(context) { },
            // this is how to draw a graphical representation of the fact that a node is moving
            drawMoving: function(context) {
                if(this.moving && !this.fixed) {
                    var velocity = LayoutEngine.absolute(this.xVelocity) + LayoutEngine.absolute(this.yVelocity);
                    var shadowOffsetX = 4 * ((velocity > 2) ? 2 : velocity);
                    var shadowOffsetY = 4 * ((velocity > 3) ? 3 : velocity);
                    context.save();
                    context.translate(-shadowOffsetX, shadowOffsetY);
                    this.drawOutline(context);
                    context.fillStyle = 'rgba(150, 120, 100, ' + ((1/velocity > 0.5 ? 0.5 : 1/velocity) - LayoutEngine.stoppingVelocity) + ')';
                    context.fill();
                    context.restore();
                }
            },
            drawFixed: function(context) {
                if(this.fixed) {
                    context.fillStyle = '#000000';
                    context.fillRect(this.xPosition - 1, this.yPosition - 1, 2, 2);
                }
            }
        };

        function Attribute(x, y, name, historized) {
            AbstractNode.call(this, x, y, name);
            this.historized = historized;
            this.actions.push("<input type=\"button\" value=\"toggle knotted\" onclick=\"CanvasEventHandler.toggleKnotted()\"/>");
            this.actions.push("<input type=\"button\" value=\"toggle historized\" onclick=\"CanvasEventHandler.toggleHistorized()\"/>");
        }
        Attribute.prototype = {
            historized: false,
            knotted: false,
            mnemonic: null,
            descriptor: null,
            dataRange: null,
            timeRange: null,
            fromXML: function(element) {
                var x, y, fixed;
                var layouts = element.getElementsByTagName("layout");
                if(layouts[0]) {
                    x = layouts[0].getAttribute("x");
                    y = layouts[0].getAttribute("y");
                    fixed = layouts[0].getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? false : Boolean(fixed);
                var descriptions = element.getElementsByTagName("description");
                var mnemonic = element.getAttribute("mnemonic") || "YYY";
                var descriptor = element.getAttribute("descriptor") || "Unnamed";
                var timeRange = element.getAttribute("timeRange") || null;
                var historized = timeRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || null;
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || null;
                var parent = element.parentNode;
                var anchorMnemonic = parent.getAttribute("mnemonic") || "XX";
                var anchorDescriptor = parent.getAttribute("descriptor") || "Unnamed";
                var name = anchorMnemonic + "_" + mnemonic + "_" + anchorDescriptor + "_" + descriptor;
                var attribute = new Attribute(x, y, name, historized);
                attribute.fixed = fixed;
                attribute.knotted = knotted;
                attribute.timeRange = timeRange;
                attribute.dataRange = dataRange;
                attribute.description = descriptions[0] ? descriptions[0].innerText : null;
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                return attribute;
            },
            addXML: function(element, schema) {
                // create an anchor element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("mnemonic", this.mnemonic);
                attribute.setAttribute("descriptor", this.descriptor);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.timeRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.edges[i]; i++)
                        if(edge.otherNode instanceof Knot)
                            knot = edge.otherNode;
                    attribute.setAttribute("knotRange", knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.dataRange);
                }
                this.addLayoutXML(attribute, schema);
                element.appendChild(attribute);
            },
            drawOutline: function(context) {
                // the outermost path
                context.beginPath();
                if(this.historized)
                    context.arc(this.xPosition, this.yPosition, 12, 0, 2*Math.PI, false);
                else
                    context.arc(this.xPosition, this.yPosition, 10, 0, 2*Math.PI, false);
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    // then we get back to drawing the actual symbol
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 7, 0, 2*Math.PI, false);
                    context.fill();
                    context.stroke();
                }
                else {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#ff8888';
                    context.lineWidth = 1.5;
                    context.stroke();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Attribute, AbstractNode);

        function Anchor(x, y, name) {
            AbstractNode.call(this, x, y, name);
            this.actions.push("<input type=\"button\" value=\"add a new attribute\" onclick=\"CanvasEventHandler.addAttribute()\"/>");
        }
        Anchor.prototype = {
            mnemonic: null,
            descriptor: null,
            identity: null,
            fromXML: function(element) {
                var x, y, fixed;
                var layouts = element.getElementsByTagName("layout");
                if(layouts[0]) {
                    x = layouts[0].getAttribute("x");
                    y = layouts[0].getAttribute("y");
                    fixed = layouts[0].getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? false : Boolean(fixed);
                var descriptions = element.getElementsByTagName("description");
                var mnemonic = element.getAttribute("mnemonic") || "XX";
                var descriptor = element.getAttribute("descriptor") || "Unnamed";
                var identity = element.getAttribute("identity") || "untyped";
                var name = mnemonic + "_" + descriptor;
                var anchor = new Anchor(x, y, name);
                anchor.fixed = fixed;
                anchor.description = descriptions[0] ? descriptions[0].innerText : null;
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("mnemonic", this.mnemonic);
                anchor.setAttribute("descriptor", this.descriptor);
                anchor.setAttribute("identity", this.identity);

                var edge;
                for(var i = 0; edge = this.edges[i]; i++)
                    if(edge.otherNode instanceof Attribute)
                        edge.otherNode.addXML(anchor, schema);
                this.addLayoutXML(anchor, schema);
                return anchor;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition - 10);
                context.lineTo(this.xPosition + 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition + 10);
                context.lineTo(this.xPosition - 10, this.yPosition - 10);
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#bb5555';
                context.fill();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Anchor, AbstractNode);

        function Knot(x, y, name) {
            AbstractNode.call(this, x, y, name);
            this.actions.push("<input type=\"button\" value=\"remove this knot\" onclick=\"CanvasEventHandler.removeKnot()\"/>");
        }
        Knot.prototype = {
            mnemonic: null,
            descriptor: null,
            identity: null,
            dataRange: null,
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("mnemonic", this.mnemonic);
                knot.setAttribute("descriptor", this.descriptor);
                knot.setAttribute("identity", this.identity);
                knot.setAttribute("dataRange", this.dataRange);
                this.addLayoutXML(knot, schema);
                return knot;
            },
            drawOutline: function(context) {
                context.beginPath();
                context.moveTo(this.xPosition - 6, this.yPosition - 9);
                context.lineTo(this.xPosition + 6, this.yPosition - 9);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition - 9, this.xPosition + 9, this.yPosition - 6);
                context.lineTo(this.xPosition + 9, this.yPosition + 6);
                context.quadraticCurveTo(this.xPosition + 9, this.yPosition + 9, this.xPosition + 6, this.yPosition + 9);
                context.lineTo(this.xPosition - 6, this.yPosition + 9);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition + 9, this.xPosition - 9, this.yPosition + 6);
                context.lineTo(this.xPosition - 9, this.yPosition - 6);
                context.quadraticCurveTo(this.xPosition - 9, this.yPosition - 9, this.xPosition - 6, this.yPosition - 9);
            },
            draw: function(context) {
                this.drawOutline(context);
                context.fillStyle = '#ffffff';
                context.fill();
                context.strokeStyle = '#ff8888';
                context.lineWidth = 1.5;
                context.stroke();
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Knot, AbstractNode);

        function Tie(x, y, name, historized) {
            AbstractNode.call(this, x, y, name);
            this.historized = historized;
            this.actions.push("<input type=\"button\" value=\"add a new anchor\" onclick=\"CanvasEventHandler.addAnchor()\"/>");
            this.actions.push("<input type=\"button\" value=\"toggle knotted\" onclick=\"CanvasEventHandler.toggleKnotted()\"/>");
            this.actions.push("<input type=\"button\" value=\"toggle historized\" onclick=\"CanvasEventHandler.toggleHistorized()\"/>");
        }
        Tie.prototype = {
            historized: false,
            timeRange: null,
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                if(this.historized)
                    tie.setAttribute("timeRange", this.timeRange);
                for(var i = 0; i < this.edges.length; i++) {
                    var role;
                    var node = this.edges[i].otherNode;
                    if(this.edges[i].otherNode instanceof Anchor)
                        role = schema.createElement("anchorRole");
                    else if(this.edges[i].otherNode instanceof Knot)
                        role = schema.createElement("knotRole");
                    role.setAttribute("role", this.edges[i].role);
                    role.setAttribute("type", node.mnemonic);
                    role.setAttribute("identifier", this.edges[i].identifier);
                    tie.appendChild(role);
                }
                this.addLayoutXML(tie, schema);
                return tie;
            },
            drawOutline: function(context) {
                if(this.historized) {
                    context.beginPath();
                    context.moveTo(this.xPosition - 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 17);
                    context.lineTo(this.xPosition + 18, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 17);
                    context.lineTo(this.xPosition - 18, this.yPosition);
                    context.closePath();
                }
                else {
                    context.beginPath();
                    context.moveTo(this.xPosition - 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 14);
                    context.lineTo(this.xPosition + 15, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 14);
                    context.lineTo(this.xPosition - 15, this.yPosition);
                    context.closePath();
                }
            },
            draw: function(context) {
                this.drawOutline(context);
                if(this.historized) {
                    context.fillStyle = '#ffffff';
                    context.fill();
                    context.strokeStyle = '#a8a8a8';
                    context.lineWidth = 1.5;
                    context.stroke();
                    context.beginPath();
                    context.moveTo(this.xPosition - 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition + 11);
                    context.lineTo(this.xPosition + 12, this.yPosition);
                    context.lineTo(this.xPosition, this.yPosition - 11);
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                else {
                    context.fillStyle = '#a8a8a8';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
                this.drawFixed(context);
            }
        };

        // inheritance
        extend(Tie, AbstractNode);

        function Edge(node, otherNode, name, identifier) {
            // assume that the control point and midway point coincide with the center point
            this.centerPoint = {
                xPosition: node.xPosition + (otherNode.xPosition - node.xPosition)/2,
                yPosition: node.yPosition + (otherNode.yPosition - node.yPosition)/2
            };
            this.controlPoint = {
                xPosition: this.centerPoint.xPosition,
                yPosition: this.centerPoint.yPosition
            };
            AbstractNode.call(this, this.controlPoint.xPosition, this.controlPoint.yPosition, name);
            this.node = node;
            this.otherNode = otherNode;
            this.identifier = identifier;
            node.edges.push(this);
            otherNode.edges.push(this);
            this.edges.push(node);
            this.edges.push(otherNode);
        }
        Edge.prototype = {
            role: null,
            node: null,
            otherNode: null,
            controlPoint: { xPosition: null, yPosition: null },
            centerPoint: { xPosition: null, yPosition: null },
            identifier: true,
            // overload to remove propagation of movement
            start: function() {
                this.moving = true;
            },
            drawMoving: function(context) {
                if((this.node.moving && !this.node.fixed) || (this.otherNode.moving && !this.otherNode.fixed)) {
                    var nodeVelocity = 0;
                    var nodeShadowOffsetX = 0;
                    var nodeShadowOffsetY = 0;
                    if(this.node.moving && !this.node.fixed) {
                        nodeVelocity = LayoutEngine.absolute(this.node.xVelocity) + LayoutEngine.absolute(this.node.yVelocity);
                        nodeShadowOffsetX = 4 * ((nodeVelocity > 2) ? 2 : nodeVelocity);
                        nodeShadowOffsetY = 4 * ((nodeVelocity > 3) ? 3 : nodeVelocity);
                    }
                    var otherNodeVelocity = 0;
                    var otherNodeShadowOffsetX = 0;
                    var otherNodeShadowOffsetY = 0;
                    if(this.otherNode.moving && !this.otherNode.fixed) {
                        otherNodeVelocity = LayoutEngine.absolute(this.otherNode.xVelocity) + LayoutEngine.absolute(this.otherNode.yVelocity);
                        otherNodeShadowOffsetX = 4 * ((otherNodeVelocity > 2) ? 2 : otherNodeVelocity);
                        otherNodeShadowOffsetY = 4 * ((otherNodeVelocity > 3) ? 3 : otherNodeVelocity);
                    }
                    var averageVelocity = (nodeVelocity + otherNodeVelocity)/2;
                    var controlOffsetX = (nodeShadowOffsetX + otherNodeShadowOffsetX)/2;
                    var controlOffsetY = (nodeShadowOffsetY + otherNodeShadowOffsetY)/2;
                    context.beginPath();
                    context.moveTo(this.node.xPosition - nodeShadowOffsetX, this.node.yPosition + nodeShadowOffsetY);
                    context.quadraticCurveTo(this.controlPoint.xPosition - controlOffsetX, this.controlPoint.yPosition + controlOffsetY,
                            this.otherNode.xPosition - otherNodeShadowOffsetX, this.otherNode.yPosition + otherNodeShadowOffsetY);
                    context.strokeStyle = 'rgba(150, 120, 100, ' + ((1/averageVelocity > 0.5 ? 0.5 : 1/averageVelocity) - LayoutEngine.stoppingVelocity) + ')';
                    context.lineWidth = 1.0;
                    context.stroke();
                }
            },
            draw: function(context) {
                context.beginPath();
                context.moveTo(this.node.xPosition, this.node.yPosition);
                context.quadraticCurveTo(this.controlPoint.xPosition, this.controlPoint.yPosition, this.otherNode.xPosition, this.otherNode.yPosition);
                context.strokeStyle = '#000000';
                context.lineWidth = 1.0;
                context.stroke();
                if(DEBUG) {
                    context.beginPath();
                    context.arc(this.controlPoint.xPosition, this.controlPoint.yPosition, 4, 0, 2*Math.PI, false);
                    context.fillStyle = '#00bb00';
                    context.fill();
                    context.stroke();
                }
                // show if edges on ties are identifiers or not by drawing a filled or empty circle
                if(this.node instanceof Tie || this.otherNode instanceof Tie) {
                    context.beginPath();
                    context.arc(this.xPosition, this.yPosition, 6, 0, 2*Math.PI, false);
                    context.stroke();
                    if(this.identifier)
                        context.fillStyle = '#565656';
                    else
                        context.fillStyle = '#ffffff';
                    context.fill();
                }
                AbstractNode.prototype.draw.apply(this, arguments);
            }
        };

        // inheritance
        extend(Edge, AbstractNode);


        // global function providing inheritance
        function extend(child, supertype){
           child.prototype.__proto__ = supertype.prototype;
        }

        // make sure our init function is called when the page is loaded
        window.onload = function() { try { init(this); } catch(e) { alert(e); } };

        // implementation of our init function
        function init(window) {
            var canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext;

            // get the canvas element
            canvas = document.getElementById('canvas');
            if (!canvas || !canvas.getContext) {
                alert("Cannot find the canvas!");
                return;
            }
            // get the canvas 2d context
            context = canvas.getContext('2d');
            if (!context) {
                alert("The canvas has no 2d context!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(canvas, context);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(canvas, context) }, false);

            shadowCanvas = document.getElementById('shadow');
            if (!shadowCanvas || !shadowCanvas.getContext) {
                alert("Cannot find the shadow canvas!");
                return;
            }
            // get the shadow canvas 2d context
            shadowContext = shadowCanvas.getContext('2d');
            if (!shadowContext) {
                alert("The shadow canvas has no 2d context!");
                return;
            }
            // make this a full screen canvas, that can be resized
            ResizeHandler.resizeCanvas(shadowCanvas, shadowContext);
            window.addEventListener('resize', function() { ResizeHandler.resizeCanvas(shadowCanvas, shadowContext) }, false);

            miniatureCanvas = document.getElementById('miniature');
            if (!miniatureCanvas || !miniatureCanvas.getContext) {
                alert("Cannot find the miniature canvas!");
                return;
            }
            // get the shadow canvas 2d context
            miniatureContext = miniatureCanvas.getContext('2d');
            if (!miniatureContext) {
                alert("The miniature canvas has no 2d context!");
                return;
            }

            DrawingEngine.init(canvas, shadowCanvas, miniatureCanvas, context, shadowContext, miniatureContext);

            canvas.CanvasEventHandler = CanvasEventHandler;
            // attach the mousedown, mousemove and mouseup event listeners to the visible canvas
            canvas.addEventListener('mousedown', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousemove', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mouseup', CanvasEventHandler.handleEvent, false);
            canvas.addEventListener('mousewheel', CanvasEventHandler.handleEvent, false); // Safari and Chrome
            canvas.addEventListener('DOMMouseScroll', CanvasEventHandler.handleEvent, false); // Firefox

            // setting a listener on the canvas did not work, so this is a workaround
            window.onkeydown = CanvasEventHandler.handleEvent;

            miniatureCanvas.MiniatureEventHandler = MiniatureEventHandler;
            miniatureCanvas.addEventListener('mousedown', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mousemove', MiniatureEventHandler.handleEvent, false);
            miniatureCanvas.addEventListener('mouseup', MiniatureEventHandler.handleEvent, false);

            function r() {
                return {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
            }

            var A1 = new Anchor(r().x, r().y, "A1");
            Model.addNode(A1);
            var A1B01 = new Attribute(r().x, r().y, "A1B01", true);
            Model.addNode(A1B01);
            var A1B02 = new Attribute(r().x, r().y, "A1B02", false);
            Model.addNode(A1B02);
            var A1B03 = new Attribute(r().x, r().y, "A1B03", true);
            Model.addNode(A1B03);
            var A1_A1B01 = new Edge(A1, A1B01, "A1_A1B01");
            Model.addEdge(A1_A1B01);
            var A1_A1B02 = new Edge(A1, A1B02, "A1_A1B02");
            Model.addEdge(A1_A1B02);
            var A1_A1B03 = new Edge(A1, A1B03, "A1_A1B03");
            Model.addEdge(A1_A1B03);

            var A2 = new Anchor(r().x, r().y, "A2");
            Model.addNode(A2);
            var A2B01 = new Attribute(r().x, r().y, "A2B01", false);
            Model.addNode(A2B01);
            var A2B02 = new Attribute(r().x, r().y, "A2B02", true);
            Model.addNode(A2B02);
            var A2B03 = new Attribute(r().x, r().y, "A2B03", false);
            Model.addNode(A2B03);
            var A2B04 = new Attribute(r().x, r().y, "A2B04", true);
            Model.addNode(A2B04);
            var A2B05 = new Attribute(r().x, r().y, "A2B05", false);
            Model.addNode(A2B05);
            var A2B06 = new Attribute(r().x, r().y, "A2B06", true);
            Model.addNode(A2B06);
            var A2_A2B01 = new Edge(A2, A2B01, "A2_A2B01");
            Model.addEdge(A2_A2B01);
            var A2_A2B02 = new Edge(A2, A2B02, "A2_A2B02");
            Model.addEdge(A2_A2B02);
            var A2_A2B03 = new Edge(A2, A2B03, "A2_A2B03");
            Model.addEdge(A2_A2B03);
            var A2_A2B04 = new Edge(A2, A2B04, "A2_A2B04");
            Model.addEdge(A2_A2B04);
            var A2_A2B05 = new Edge(A2, A2B05, "A2_A2B05");
            Model.addEdge(A2_A2B05);
            var A2_A2B06 = new Edge(A2, A2B06, "A2_A2B06");
            Model.addEdge(A2_A2B06);

            var A1A2 = new Tie(r().x, r().y, "A1A2", false);
            Model.addNode(A1A2);
            var A1_A1A2 = new Edge(A1A2, A1, "A1_A1A2", false);
            Model.addEdge(A1_A1A2);
            var A2_A1A2 = new Edge(A1A2, A2, "A2_A1A2", true);
            Model.addEdge(A2_A1A2);

            var A1A1 = new Tie(r().x, r().y, "A1A1", false);
            Model.addNode(A1A1);
            var A1_a_A1A1 = new Edge(A1A1, A1, "A1_a_A1A1", false);
            Model.addEdge(A1_a_A1A1);
            var A1_b_A1A1 = new Edge(A1A1, A1, "A1_b_A1A1", true);
            Model.addEdge(A1_b_A1A1);

            var A1A1C = new Knot(r().x, r().y, "A1A1C");
            Model.addNode(A1A1C);
            var A1A1_C = new Edge(A1A1, A1A1C, "A1A1_C", true);
            Model.addEdge(A1A1_C);


            var A3 = new Anchor(r().x, r().y, "A3");
            Model.addNode(A3);
            var A3B01 = new Attribute(r().x, r().y, "A3B01", false);
            Model.addNode(A3B01);
            var A3B02 = new Attribute(r().x, r().y, "A3B02", true);
            Model.addNode(A3B02);
            var A3B03 = new Attribute(r().x, r().y, "A3B03", false);
            Model.addNode(A3B03);
            var A3_A3B01 = new Edge(A3, A3B01, "A3_A3B01");
            Model.addEdge(A3_A3B01);
            var A3_A3B02 = new Edge(A3, A3B02, "A3_A3B02");
            Model.addEdge(A3_A3B02);
            var A3_A3B03 = new Edge(A3, A3B03, "A3_A3B03");
            Model.addEdge(A3_A3B03);

            var A3B01C = new Knot(r().x, r().y, "A3B01C");
            Model.addNode(A3B01C);
            var A3B01_C = new Edge(A3B01, A3B01C, "A3B01_C");
            Model.addEdge(A3B01_C);

            var A1A3 = new Tie(r().x, r().y, "A1A3", true);
            Model.addNode(A1A3);
            var A1_A1A3 = new Edge(A1A3, A1, "A1_A1A3", false);
            Model.addEdge(A1_A1A3);
            var A3_A1A3 = new Edge(A1A3, A3, "A3_A1A3", true);
            Model.addEdge(A3_A1A3);

            var A2A3 = new Tie(r().x, r().y, "A2A3", true);
            Model.addNode(A2A3);
            var A2_A2A3 = new Edge(A2A3, A2, "A2_A2A3", true);
            Model.addEdge(A2_A2A3);
            var A3_A2A3 = new Edge(A2A3, A3, "A3_A2A3", false);
            Model.addEdge(A3_A2A3);


            MenuHandler.init();
            DrawingEngine.start();
        }

        function toggleDebug(button) {
            DEBUG = !DEBUG;
            if(DEBUG)
                button.value = 'NORMAL MODE';
            else
                button.value = 'DEBUG MODE';
            DrawingEngine.start();
        }
        function togglePause(button) {
            if(DrawingEngine.running) {
                button.value = 'PAUSE';
                DrawingEngine.stop();
            }
            else {
                button.value = 'PLAY';
                DrawingEngine.start();                
            }
        }
        function invalidateLayout() {
            for(var i = 0; i < Model.nodes.length; i++) {
                Model.nodes[i].start();
                DrawingEngine.start();
            }
        }
        function randomizeLayout() {
            for(var i = 0; i < Model.nodes.length; i++) {
                Model.nodes[i].xPosition = Math.random() * window.innerWidth;
                Model.nodes[i].yPosition = Math.random() * window.innerHeight;
                DrawingEngine.start();
            }
        }
        function toggleFixation() {
            for(var i = 0; i < Model.nodes.length; i++) {
                Model.nodes[i].fixed = !Model.nodes[i].fixed;
                DrawingEngine.start();
            }
        }

        function ModalBackground() {
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;            
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
            }
        };

        function CodePopover() {
            var self = this;

            this.modalBackground = new ModalBackground();

            var codePopover = document.createElement('div');
            codePopover.setAttribute("id", "codePopover");
            var padding = window.innerWidth * 0.1;
            codePopover.style.top = (padding - 16) + 'px';

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * padding) + 'px';
            content.style.height = (window.innerHeight - 2 * padding) + 'px';
            DrawingEngine.stop();
            var html = transform(Model.toXML(), 'xml2html.xsl');
            content.appendChild(html);
            codePopover.appendChild(content);

            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event) }, false);
            codePopover.appendChild(close);

            document.body.appendChild(codePopover);

            this.codePopover = codePopover;
            return this;
        }
        CodePopover.prototype = {
            codePopover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.codePopover);
                this.modalBackground.close();
                DrawingEngine.start();
            }
        };


        function transform(xmlDocument, transformationURL) {
            var result;
            try {
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.open("GET", transformationURL, false);
                xmlhttp.send(null);
                var processor = new XSLTProcessor();
                processor.importStylesheet(xmlhttp.responseXML.documentElement);
                result = processor.transformToFragment(xmlDocument, document);
            }
            catch(exception){
                alert(exception);
            }
            return result;
        }

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                // does not work in Safari, but works in Firefox 3.6 and Chrome 6.
                this.reader = new FileReader();
                this.reader.onload = function() { FileHandler.fileLoaded() };
                this.reader.readAsText(files[0]);
            },
            fileLoaded: function() {
                try {
                    var parser = new DOMParser();
                    var xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                }
                Model.fromXML(xml);
                DrawingEngine.start();
            }
        };

        function DatabaseManager() {
            var version = ""; // database version needed, leave empty
            var size = 65536; // 65kB size
            this.db = window.openDatabase("AnchorModeler", version, "Storage for the Anchor Modeler", size);
        }
        DatabaseManager.prototype = {
            db: null,
            init: function() {
                this.db.transaction(function(tx) {
                    tx.executeSql("SELECT * FROM Batches", [], function(result) {
                        loadModel(result);
                    }, function(tx, error) {
                        tx.executeSql("CREATE TABLE Batches (id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, timestamp TIMESTAMP)", [], function(result) {
                            loadModel(result);
                        });
                    });
                });
            }
        };
        // -->
    </script>
</head>
<body>
    <canvas id="canvas">
        Your browser does not support HTML5 canvas!
    </canvas>
    <canvas id="shadow">
        <!-- nothing to see here -->
    </canvas>
    <div id="header">
        Anchor Modeler: Click and hold to drag nodes, Alt + click to fixate or release a node, or Shift + hover to toggle a context menu.
        <br/>
        <input type="button" value="DEBUG MODE" onclick="toggleDebug(this)"/>
        <input type="button" value="TOGGLE FIXATION" onclick="toggleFixation()"/>
        <input type="button" value="INVALIDATE LAYOUT" onclick="invalidateLayout()"/>
        <input type="button" value="RANDOMIZE" onclick="randomizeLayout()"/>
        <input type="button" value="PAUSE" onclick="togglePause(this)"/>
        <input type="button" value="SCHEMA XML" onclick="new CodePopover()"/>
        <input type="file" onchange="FileHandler.handleFiles(this.files)"/>
    </div>
    <div id="menu">
        <!-- this will be filled and shown dynamically -->
    </div>
    <canvas id="miniature">
        <!-- shows a navigatable miniature of the model -->
    </canvas>
</body>
</html>