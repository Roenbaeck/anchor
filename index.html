<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="user-scalable=no, shrink-to-fit=no" />
    <meta name="HandheldFriendly" content="true">    
    <title>Anchor Modeler</title>
    <!-- web fonts -->
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'>
    <!-- styling -->
    <link href='application.css' rel='stylesheet' type='text/css'/>
    <!-- icon -->
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <!-- datalists -->
    <datalist id='integerList'>
        <option value='tinyint'>
        <option value='smallint'>
        <option value='integer'>
        <option value='bigint'>        
    </datalist>
    <datalist id='datetimeList'>
        <option value='date'>
        <option value='datetime'>
        <option value='datetime2'>
        <option value='timestamp'>                
    </datalist>
    <datalist id='datatypeList'>
        <option value='bigint'>  
        <option value='binary'>    
        <option value='bit'>
        <option value='blob'>
        <option value='boolean'>
        <option value='char()'>
        <option value='clob'>
        <option value='date'>   
        <option value='datetime'>  
        <option value='datetime2'>
        <option value='decimal(,)'>    
        <option value='double'>  
        <option value='float'>
        <option value='integer'>      
        <option value='json'>
        <option value='money'>
        <option value='nchar()'>
        <option value='nclob'>
        <option value='nvarchar()'>   
        <option value='numeric(,)'>
        <option value='real'>    
        <option value='smallint'>
        <option value='text'>    
        <option value='time'>
        <option value='timestamp'>
        <option value='tinyint'>
        <option value='varchar()'>    
        <option value='xml'>                         
    </datalist>
    <!-- polyfill for the functionality going to be removed in SVG 2 -->
    <script src="pathseg.js"></script>
    <!-- import required modules -->
    <script type="text/javascript" src="modules/Inheritance.js"></script>    
    <script type="text/javascript" src="modules/DataTypeConverter.js"></script>
    <script type="text/javascript" src="modules/Defaults.js"></script>    
    <script type="text/javascript" src="modules/LayoutEngine.js"></script>    
    <script type="text/javascript" src="modules/Map.js"></script>    
    <script type="text/javascript" src="modules/Sisulator.js"></script>    
    <!-- run some checks first -->
    <script type="text/javascript">
        // <!--
        // check low level management SVG support
        var testElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        if (!testElement || !testElement.viewBox)
            unsupported('No low level SVG API available.');

        // check binding support
        if(!Function.prototype.bind)
            unsupported('Functions cannot be rebound with respect to "this".');

        var browser = window.navigator.userAgent;
        // check that it's not IE
        if(browser.indexOf('MSIE ') >= 0 || browser.indexOf('Trident/') >= 0)
            unsupported('Internet Explorer is not supported.');

        function unsupported(msg) {
            console.error(msg);
            // disable handlers and leave
            window.init = null;
            window.onbeforeunload = null;
            window.onunload = null;
            window.location = "unsupported.html";
        }
        // -->
    </script>

    <script type="text/javascript">
        // <!--
        "use strict"; // be safe!

        var VERSION = '0.99.10';

        // change to false in beta
        var RELEASE = false;

        // set to true to show debugging information
        var DEBUG = false;

        // used when creating svg elements
        var SVGNS = "http://www.w3.org/2000/svg";
        var XLINKNS = "http://www.w3.org/1999/xlink";
        // the svg root and graph elements
        var SVG, SVGLayer;
        // the navigation miniature
        var NAV, NAVLayer;

        // global variables for the cloud stuff
        var ASKBEFOREUNLOAD = true;
        var LOGGED_IN = false;
        var PARAMETERS = {};
        var USER_ID = "";

        // in many languages (UTF-8) http://difnet.com.br/opensource/unicode_hack.js and https://ideone.com/04llh4
        var UPPER = '[' +
                // Unicode Lu class (upper case letter)
                '\u0041-\u005a\u00c0-\u00d6\u00d8-\u00de\u0100\u0102\u0104\u0106\u0108\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136\u0139\u013b\u013d\u013f\u0141\u0143\u0145\u0147\u014a\u014c\u014e\u0150\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178\u0179\u017b\u017d\u0181\u0182\u0184\u0186\u0187\u0189-\u018b\u018e-\u0191\u0193\u0194\u0196-\u0198\u019c\u019d\u019f\u01a0\u01a2\u01a4\u01a6\u01a7\u01a9\u01ac\u01ae\u01af\u01b1-\u01b3\u01b5\u01b7\u01b8\u01bc\u01c4\u01c7\u01ca\u01cd\u01cf\u01d1\u01d3\u01d5\u01d7\u01d9\u01db\u01de\u01e0\u01e2\u01e4\u01e6\u01e8\u01ea\u01ec\u01ee\u01f1\u01f4\u01f6-\u01f8\u01fa\u01fc\u01fe\u0200\u0202\u0204\u0206\u0208\u020a\u020c\u020e\u0210\u0212\u0214\u0216\u0218\u021a\u021c\u021e\u0220\u0222\u0224\u0226\u0228\u022a\u022c\u022e\u0230\u0232\u023a\u023b\u023d\u023e\u0241\u0243-\u0246\u0248\u024a\u024c\u024e\u0370\u0372\u0376\u0386\u0388-\u038a\u038c\u038e\u038f\u0391-\u03a1\u03a3-\u03ab\u03cf\u03d2-\u03d4\u03d8\u03da\u03dc\u03de\u03e0\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03f9\u03fa\u03fd-\u042f\u0460\u0462\u0464\u0466\u0468\u046a\u046c\u046e\u0470\u0472\u0474\u0476\u0478\u047a\u047c\u047e\u0480\u048a\u048c\u048e\u0490\u0492\u0494\u0496\u0498\u049a\u049c\u049e\u04a0\u04a2\u04a4\u04a6\u04a8\u04aa\u04ac\u04ae\u04b0\u04b2\u04b4\u04b6\u04b8\u04ba\u04bc\u04be\u04c0\u04c1\u04c3\u04c5\u04c7\u04c9\u04cb\u04cd\u04d0\u04d2\u04d4\u04d6\u04d8\u04da\u04dc\u04de\u04e0\u04e2\u04e4\u04e6\u04e8\u04ea\u04ec\u04ee\u04f0\u04f2\u04f4\u04f6\u04f8\u04fa\u04fc\u04fe\u0500\u0502\u0504\u0506\u0508\u050a\u050c\u050e\u0510\u0512\u0514\u0516\u0518\u051a\u051c\u051e\u0520\u0522\u0524\u0526\u0531-\u0556\u10a0-\u10c5\u1e00\u1e02\u1e04\u1e06\u1e08\u1e0a\u1e0c\u1e0e\u1e10\u1e12\u1e14\u1e16\u1e18\u1e1a\u1e1c\u1e1e\u1e20\u1e22\u1e24\u1e26\u1e28\u1e2a\u1e2c\u1e2e\u1e30\u1e32\u1e34\u1e36\u1e38\u1e3a\u1e3c\u1e3e\u1e40\u1e42\u1e44\u1e46\u1e48\u1e4a\u1e4c\u1e4e\u1e50\u1e52\u1e54\u1e56\u1e58\u1e5a\u1e5c\u1e5e\u1e60\u1e62\u1e64\u1e66\u1e68\u1e6a\u1e6c\u1e6e\u1e70\u1e72\u1e74\u1e76\u1e78\u1e7a\u1e7c\u1e7e\u1e80\u1e82\u1e84\u1e86\u1e88\u1e8a\u1e8c\u1e8e\u1e90\u1e92\u1e94\u1e9e\u1ea0\u1ea2\u1ea4\u1ea6\u1ea8\u1eaa\u1eac\u1eae\u1eb0\u1eb2\u1eb4\u1eb6\u1eb8\u1eba\u1ebc\u1ebe\u1ec0\u1ec2\u1ec4\u1ec6\u1ec8\u1eca\u1ecc\u1ece\u1ed0\u1ed2\u1ed4\u1ed6\u1ed8\u1eda\u1edc\u1ede\u1ee0\u1ee2\u1ee4\u1ee6\u1ee8\u1eea\u1eec\u1eee\u1ef0\u1ef2\u1ef4\u1ef6\u1ef8\u1efa\u1efc\u1efe\u1f08-\u1f0f\u1f18-\u1f1d\u1f28-\u1f2f\u1f38-\u1f3f\u1f48-\u1f4d\u1f59\u1f5b\u1f5d\u1f5f\u1f68-\u1f6f\u1fb8-\u1fbb\u1fc8-\u1fcb\u1fd8-\u1fdb\u1fe8-\u1fec\u1ff8-\u1ffb\u2102\u2107\u210b-\u210d\u2110-\u2112\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u2130-\u2133\u213e\u213f\u2145\u2183\u2c00-\u2c2e\u2c60\u2c62-\u2c64\u2c67\u2c69\u2c6b\u2c6d-\u2c70\u2c72\u2c75\u2c7e-\u2c80\u2c82\u2c84\u2c86\u2c88\u2c8a\u2c8c\u2c8e\u2c90\u2c92\u2c94\u2c96\u2c98\u2c9a\u2c9c\u2c9e\u2ca0\u2ca2\u2ca4\u2ca6\u2ca8\u2caa\u2cac\u2cae\u2cb0\u2cb2\u2cb4\u2cb6\u2cb8\u2cba\u2cbc\u2cbe\u2cc0\u2cc2\u2cc4\u2cc6\u2cc8\u2cca\u2ccc\u2cce\u2cd0\u2cd2\u2cd4\u2cd6\u2cd8\u2cda\u2cdc\u2cde\u2ce0\u2ce2\u2ceb\u2ced\ua640\ua642\ua644\ua646\ua648\ua64a\ua64c\ua64e\ua650\ua652\ua654\ua656\ua658\ua65a\ua65c\ua65e\ua660\ua662\ua664\ua666\ua668\ua66a\ua66c\ua680\ua682\ua684\ua686\ua688\ua68a\ua68c\ua68e\ua690\ua692\ua694\ua696\ua722\ua724\ua726\ua728\ua72a\ua72c\ua72e\ua732\ua734\ua736\ua738\ua73a\ua73c\ua73e\ua740\ua742\ua744\ua746\ua748\ua74a\ua74c\ua74e\ua750\ua752\ua754\ua756\ua758\ua75a\ua75c\ua75e\ua760\ua762\ua764\ua766\ua768\ua76a\ua76c\ua76e\ua779\ua77b\ua77d\ua77e\ua780\ua782\ua784\ua786\ua78b\ua78d\ua790\ua7a0\ua7a2\ua7a4\ua7a6\ua7a8\uff21-\uff3a' +
        ']';
        var LOWER = '[' +
                // Unicode Ll class (lower case letter)
                '\u0061-\u007a\u00aa\u00b5\u00ba\u00df-\u00f6\u00f8-\u00ff\u0101\u0103\u0105\u0107\u0109\u010b\u010d\u010f\u0111\u0113\u0115\u0117\u0119\u011b\u011d\u011f\u0121\u0123\u0125\u0127\u0129\u012b\u012d\u012f\u0131\u0133\u0135\u0137\u0138\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148\u0149\u014b\u014d\u014f\u0151\u0153\u0155\u0157\u0159\u015b\u015d\u015f\u0161\u0163\u0165\u0167\u0169\u016b\u016d\u016f\u0171\u0173\u0175\u0177\u017a\u017c\u017e-\u0180\u0183\u0185\u0188\u018c\u018d\u0192\u0195\u0199-\u019b\u019e\u01a1\u01a3\u01a5\u01a8\u01aa\u01ab\u01ad\u01b0\u01b4\u01b6\u01b9\u01ba\u01bd-\u01bf\u01c6\u01c9\u01cc\u01ce\u01d0\u01d2\u01d4\u01d6\u01d8\u01da\u01dc\u01dd\u01df\u01e1\u01e3\u01e5\u01e7\u01e9\u01eb\u01ed\u01ef\u01f0\u01f3\u01f5\u01f9\u01fb\u01fd\u01ff\u0201\u0203\u0205\u0207\u0209\u020b\u020d\u020f\u0211\u0213\u0215\u0217\u0219\u021b\u021d\u021f\u0221\u0223\u0225\u0227\u0229\u022b\u022d\u022f\u0231\u0233-\u0239\u023c\u023f\u0240\u0242\u0247\u0249\u024b\u024d\u024f-\u0293\u0295-\u02af\u0371\u0373\u0377\u037b-\u037d\u0390\u03ac-\u03ce\u03d0\u03d1\u03d5-\u03d7\u03d9\u03db\u03dd\u03df\u03e1\u03e3\u03e5\u03e7\u03e9\u03eb\u03ed\u03ef-\u03f3\u03f5\u03f8\u03fb\u03fc\u0430-\u045f\u0461\u0463\u0465\u0467\u0469\u046b\u046d\u046f\u0471\u0473\u0475\u0477\u0479\u047b\u047d\u047f\u0481\u048b\u048d\u048f\u0491\u0493\u0495\u0497\u0499\u049b\u049d\u049f\u04a1\u04a3\u04a5\u04a7\u04a9\u04ab\u04ad\u04af\u04b1\u04b3\u04b5\u04b7\u04b9\u04bb\u04bd\u04bf\u04c2\u04c4\u04c6\u04c8\u04ca\u04cc\u04ce\u04cf\u04d1\u04d3\u04d5\u04d7\u04d9\u04db\u04dd\u04df\u04e1\u04e3\u04e5\u04e7\u04e9\u04eb\u04ed\u04ef\u04f1\u04f3\u04f5\u04f7\u04f9\u04fb\u04fd\u04ff\u0501\u0503\u0505\u0507\u0509\u050b\u050d\u050f\u0511\u0513\u0515\u0517\u0519\u051b\u051d\u051f\u0521\u0523\u0525\u0527\u0561-\u0587\u1d00-\u1d2b\u1d62-\u1d77\u1d79-\u1d9a\u1e01\u1e03\u1e05\u1e07\u1e09\u1e0b\u1e0d\u1e0f\u1e11\u1e13\u1e15\u1e17\u1e19\u1e1b\u1e1d\u1e1f\u1e21\u1e23\u1e25\u1e27\u1e29\u1e2b\u1e2d\u1e2f\u1e31\u1e33\u1e35\u1e37\u1e39\u1e3b\u1e3d\u1e3f\u1e41\u1e43\u1e45\u1e47\u1e49\u1e4b\u1e4d\u1e4f\u1e51\u1e53\u1e55\u1e57\u1e59\u1e5b\u1e5d\u1e5f\u1e61\u1e63\u1e65\u1e67\u1e69\u1e6b\u1e6d\u1e6f\u1e71\u1e73\u1e75\u1e77\u1e79\u1e7b\u1e7d\u1e7f\u1e81\u1e83\u1e85\u1e87\u1e89\u1e8b\u1e8d\u1e8f\u1e91\u1e93\u1e95-\u1e9d\u1e9f\u1ea1\u1ea3\u1ea5\u1ea7\u1ea9\u1eab\u1ead\u1eaf\u1eb1\u1eb3\u1eb5\u1eb7\u1eb9\u1ebb\u1ebd\u1ebf\u1ec1\u1ec3\u1ec5\u1ec7\u1ec9\u1ecb\u1ecd\u1ecf\u1ed1\u1ed3\u1ed5\u1ed7\u1ed9\u1edb\u1edd\u1edf\u1ee1\u1ee3\u1ee5\u1ee7\u1ee9\u1eeb\u1eed\u1eef\u1ef1\u1ef3\u1ef5\u1ef7\u1ef9\u1efb\u1efd\u1eff-\u1f07\u1f10-\u1f15\u1f20-\u1f27\u1f30-\u1f37\u1f40-\u1f45\u1f50-\u1f57\u1f60-\u1f67\u1f70-\u1f7d\u1f80-\u1f87\u1f90-\u1f97\u1fa0-\u1fa7\u1fb0-\u1fb4\u1fb6\u1fb7\u1fbe\u1fc2-\u1fc4\u1fc6\u1fc7\u1fd0-\u1fd3\u1fd6\u1fd7\u1fe0-\u1fe7\u1ff2-\u1ff4\u1ff6\u1ff7\u210a\u210e\u210f\u2113\u212f\u2134\u2139\u213c\u213d\u2146-\u2149\u214e\u2184\u2c30-\u2c5e\u2c61\u2c65\u2c66\u2c68\u2c6a\u2c6c\u2c71\u2c73\u2c74\u2c76-\u2c7c\u2c81\u2c83\u2c85\u2c87\u2c89\u2c8b\u2c8d\u2c8f\u2c91\u2c93\u2c95\u2c97\u2c99\u2c9b\u2c9d\u2c9f\u2ca1\u2ca3\u2ca5\u2ca7\u2ca9\u2cab\u2cad\u2caf\u2cb1\u2cb3\u2cb5\u2cb7\u2cb9\u2cbb\u2cbd\u2cbf\u2cc1\u2cc3\u2cc5\u2cc7\u2cc9\u2ccb\u2ccd\u2ccf\u2cd1\u2cd3\u2cd5\u2cd7\u2cd9\u2cdb\u2cdd\u2cdf\u2ce1\u2ce3\u2ce4\u2cec\u2cee\u2d00-\u2d25\ua641\ua643\ua645\ua647\ua649\ua64b\ua64d\ua64f\ua651\ua653\ua655\ua657\ua659\ua65b\ua65d\ua65f\ua661\ua663\ua665\ua667\ua669\ua66b\ua66d\ua681\ua683\ua685\ua687\ua689\ua68b\ua68d\ua68f\ua691\ua693\ua695\ua697\ua723\ua725\ua727\ua729\ua72b\ua72d\ua72f-\ua731\ua733\ua735\ua737\ua739\ua73b\ua73d\ua73f\ua741\ua743\ua745\ua747\ua749\ua74b\ua74d\ua74f\ua751\ua753\ua755\ua757\ua759\ua75b\ua75d\ua75f\ua761\ua763\ua765\ua767\ua769\ua76b\ua76d\ua76f\ua771-\ua778\ua77a\ua77c\ua77f\ua781\ua783\ua785\ua787\ua78c\ua78e\ua791\ua7a1\ua7a3\ua7a5\ua7a7\ua7a9\ua7fa\ufb00-\ufb06\ufb13-\ufb17\uff41-\uff5a' +
                // Unicode Nd class (decimal digit number)
                '\u0030-\u0039\u0660-\u0669\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\uaa50-\uaa59\uabf0-\uabf9\uff10-\uff19' +
        ']';

        // helpers for UTF-8, credits to Johan SundstrÃ¶m and the Mozilla Developer Network
        function utf8_to_b64( str ) {
            return window.btoa(unescape(encodeURIComponent( str )));
        }
        function b64_to_utf8( str ) {
            return decodeURIComponent(escape(window.atob( str )));
        }

        var Model = {
            // these are used in the cloud
            name: null,
            scope: 'private',
            keywords: null,
            id: null,
            description:null,
            // other members
            components: [],
            visibleNodes: [],
            idToComponent: {},
            version: -1,
            versions: [],
            // WIP: keys model
            routes: {},
            interactive: false,
            // in interactive mode keys are added on the fly, in non-interactive mode they need to be prepared
            setInteractive: function(interactive) {
                this.interactive = interactive || false;
            },
            prepareKeys: function() {
                var component; 
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component.keys && component.keys.length > 0) {
                        for(var j = 0; j < component.keys.length; j++)
                            this.addKey(component, component.keys[j]);
                    }
                }                
            },
            addKey: function(component, key) {
                var hash = key.of + '|' + key.route; // ugly concat, but that's life
                var anchorLookup = this.getAnchorLookup();
                if(!this.routes[hash]) {
                    this.routes[hash] = {
                        name: key.route,
                        start: anchorLookup[key.of],
                        stops: {}
                    };
                }
                this.routes[hash].stops[key.stop] = {
                    component: component, 
                    branch: key.branch, // the branch this stop belongs to
                    key: key // this is the key as represented in the component
                };
            },
            changeRouteName: function(route, name) {
                var oldHash = route.start.mnemonic + '|' + route.name;
                if(this.routes[oldHash]) 
                    delete this.routes[oldHash];
                route.name = name;
                var newHash = route.start.mnemonic + '|' + route.name;
                this.routes[newHash] = route;
                for(var stopNumber in route.stops) {
                    var stop = route.stops[stopNumber];
                    stop.key.route = name;
                }
            },
            getAnchorLookup: function() {
                var anchorLookup = Object.create(null);
                var component;
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component instanceof Anchor)
                        anchorLookup[component.mnemonic] = component;
                }
                return anchorLookup;
            },
            getKnotLookup: function() {
                var knotLookup = Object.create(null);
                var component;
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component instanceof Knot)
                        knotLookup[component.mnemonic] = component;
                }
                return knotLookup;
            },
            nodeToComponent: function(node) {
                return this.idToComponent[node.id];
            },
            uncloud: function() {
                this.name = null;
                this.scope = 'private';
                this.keywords = null;
                this.id = null;
            },
            isEmpty: function() {
                return this.components.length === 0;
            },
            empty: function() {
                this.components = [];
                this.visibleNodes = [];
                this.routes = {};
                this.idToComponent = Object.create(null);
                SVGLayer.clearAll();
                NAVLayer.clearAll();
            },
            refresh: function() {
                // create a new visibleNodes
                this.visibleNodes = [];
                var component;
                for(var i = 0; component = this.components[i]; i++) {
                    // reset all incompleteness
                    component.updateIncompleteness();
                    if(component.node.visible)
                        this.visibleNodes.push(component.node);
                }
            },
            // TODO: We probably should have a maximum number of versions
            recordState: function() {
                this.refresh();
                // only record if there is something to record
                if(this.components.length) {
                    this.version++;
                    this.versions[this.version] = this.toXML(false);
                    ControlButtons.setUndoLevels(this.version);
                    ControlButtons.setRedoLevels(0);
                }
            },
            clearStates: function() {
                this.version = -1;
                this.versions = [];
                ControlButtons.setUndoLevels(0);
                ControlButtons.setRedoLevels(0);
            },
            undoState: function() {
                this.version -= (this.version === 0 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                EventHandler.clearSelection();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            redoState: function() {
                this.version += (this.version === this.versions.length - 1 ? 0 : 1);
                this.fromXML(this.versions[this.version]);
                DrawingEngine.stop();
                ControlButtons.setUndoLevels(this.version);
                ControlButtons.setRedoLevels(this.versions.length - this.version - 1);
            },
            setupMinimal: function(ask) {
                var go = ask ? confirm("Are you sure you want to clear the current model?\n" +
                                       "Any unsaved changes will be lost!") : true;
                if(go) {
                    this.uncloud();
                    this.empty();
                    this.addComponent(new Anchor(window.innerWidth/2, window.innerHeight/2));
                    this.refresh();
                    EventHandler.clearSelection();
                    Actions.setModelStatus();
                    Actions.resetZoom();
                    Actions.centerModel();
                    DrawingEngine.start(false);
                }
            },
            isConforming: function() {
                var i, component;
                for(i = 0; component = Model.components[i]; i++)
                    if(!component.isConforming())
                        return false;
                return true;
            },
            addComponent: function(component) {
                // add node at the end of the array
                if(component) {
                    this.components.push(component);
                    this.idToComponent[component.id] = component;
                    // WIP: keys
                    if(this.interactive && component.keys && component.keys.length > 0) {
                        for(var i = 0; i < component.keys.length; i++)
                            this.addKey(component, component.keys[i]);
                    }
                    // this.sort();
                    this.invalidateComponent(component);
                    this.refresh();
                }
            },
            removeComponent: function(component) {
                var edge;
                if(component.node.type === NodeType.KNOT) {
                    for(var j = 0; edge = component.node.edges[j]; j++) {
                        var otherNode = edge.node === this ? edge.otherNode : edge.node;
                        if(otherNode.type === NodeType.ATTRIBUTE || otherNode.type === NodeType.TIE) {
                            var otherComponent = this.nodeToComponent(otherNode);
                            otherComponent.setKnotted(false);
                        }
                    }
                }
                else if (component.node.type === NodeType.EDGE) {
                    edge = component.node;
                    this.deleteElementFromArray(edge.node.edges, edge);
                    this.deleteElementFromArray(edge.otherNode.edges, edge);
                }
                component.hide();
                this.deleteElementFromArray(this.components, component);
                delete this.idToComponent[component.id];
                this.refresh();
            },
            deleteElementFromArray: function(array, element) {
                array.splice(array.indexOf(element), 1);
            },
            invalidateComponent: function(component) {
                var square = LayoutEngine.createSquare(component.node, LayoutEngine.normalDistance);
                for(var i = 0; i < this.visibleNodes.length; i++)
                    if(LayoutEngine.withinSquare(this.visibleNodes[i], square))
                        this.visibleNodes[i].start();
            },
            formatDate: function(date, dateOrTime) {
                function z(str) {
                    return ('0' + str).substr(-2, 2);
                }
                var theDate = date.getFullYear() + '-' + z(date.getMonth() + 1) + '-' + z(date.getDate());
                var theTime = z(date.getHours()) + ':' + z(date.getMinutes()) + ':' + z(date.getSeconds());
                if(dateOrTime.toLowerCase() === 'd')
                    return theDate;
                if(dateOrTime.toLowerCase() === 't')
                    return theTime;
                return theDate + ' ' + theTime;
            },
            toXML: function(serialize) {
                // create the xml document (not using a namespace simplifies the transformations)
                var schema = document.implementation.createDocument("", "schema", null);
                var schemaElement = schema.documentElement;
                schemaElement.setAttribute('format', VERSION);
                schemaElement.setAttribute('date', this.formatDate(new Date(), 'd'));
                schemaElement.setAttribute('time', this.formatDate(new Date(), 't'));
                var metadata = schema.createElement('metadata');
                for(var def in Defaults)
                    if(Defaults.hasOwnProperty(def) && Defaults[def])
                        metadata.setAttribute(def, Defaults[def]);
                schemaElement.appendChild(metadata);
                for(var i = 0; i < this.components.length; i++) {
                    var componentElement = this.components[i].toXML(schema);
                    if(componentElement !== null)
                        schemaElement.appendChild(componentElement);
                }
                if(serialize) {
                    var serializationElement = schema.createElement('serialization');
                    var serialization = schema.createTextNode(new XMLSerializer().serializeToString(schema));
                    serializationElement.appendChild(serialization);
                    schemaElement.appendChild(serializationElement);
                }
                return schema;
            },
            fromXML: function(xml) {
                if(xml) {
                    this.setInteractive(false);
                    this.empty();
                    var schemaElement = xml.documentElement;
                    var metadata = schemaElement.getElementsByTagName('metadata');
                    var i, def, val, defaults, listOfChanges = [];
                    if(metadata && metadata.length > 0) {
                        metadata = metadata[0]; // from NodeList to Node
                        if(metadata && metadata.hasAttributes && metadata.hasAttributes()) {
                            defaults = metadata.attributes;
                            for(i = 0; i < defaults.length; i++) {
                                def = defaults[i].name;
                                val = defaults[i].value;
                                if(Defaults.hasOwnProperty(def) && Defaults[def] != val)
                                    listOfChanges.push(def + ': ' + Defaults[def] + ' -> ' + val);
                            }
                            if(listOfChanges.length > 0) {
                                if(confirm(
                                    "The loaded model wants to change these defaults:\n\n" +
                                    listOfChanges.join('\n') + '\n\n' +
                                    "Would you like to accept these changes?\n" +
                                    "Accepting overwrites your current settings!"
                                )) {
                                    for(i = 0; i < defaults.length; i++) {
                                        def = defaults[i].name;
                                        val = defaults[i].value;
                                        if(Defaults.hasOwnProperty(def) && Defaults[def] != val)
                                            Defaults[def] = val;
                                    }
                                    // backwards compatibility
                                    switch (Defaults.temporalization) {
                                        case "mono":
                                            Defaults.temporalization = "uni";
                                            break;
                                        /*
                                        case "bi":
                                            Defaults.temporalization = "crt";
                                            break;
                                        */
                                    }
                                    Settings.storeSettings(window.localStorage);
                                    Settings.loadSettings(window.localStorage);
                                }
                            }
                        }
                    }
                    // the order in which we add these are important (attributes create edges to anchors)
                    var knots = xml.getElementsByTagName('knot');
                    for (i = 0; i < knots.length; i++)
                        this.addComponent(Knot.prototype.fromXML(knots[i]));
                    var anchors = xml.getElementsByTagName('anchor');
                    for (i = 0; i < anchors.length; i++)
                        this.addComponent(Anchor.prototype.fromXML(anchors[i]));
                    var attributes = xml.getElementsByTagName('attribute');
                    for (i = 0; i < attributes.length; i++)
                        this.addComponent(Attribute.prototype.fromXML(attributes[i]));
                    var ties = xml.getElementsByTagName('tie');
                    for (i = 0; i < ties.length; i++)
                        this.addComponent(Tie.prototype.fromXML(ties[i]));
                    // keys must be added last since they may provide a path through many of the above
                    this.prepareKeys();
                    // and after keys, identifiers
                    var identifiers = xml.getElementsByTagName('identifier');
                    for (i = 0; i < identifiers.length; i++)
                        this.addComponent(Identifier.prototype.fromXML(identifiers[i]));
                    // implode nodes
                    var component, allComponents = [];
                    for(i = 0; component = this.components[i]; i++) {
                        if(component.imploded) {
                            component.imploded = false;
                            allComponents.push(component);
                        }
                    }
                    this.explode(allComponents, false);
                    this.setInteractive(true);
                    this.refresh();
                    if(DEBUG) console.log(this);
                }
            },
            erase: function(components) {
                DrawingEngine.stop();
                var i, j, component, role, node, otherNode, otherComponent, edge, affectedComponents = [];
                for(i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.EDGE && affectedComponents.indexOf(component) < 0)
                        affectedComponents.push(component);
                    else if (node.type === NodeType.ANCHOR && affectedComponents.indexOf(component) < 0) {
                        affectedComponents.push(component);
                        for(j = 0; edge = node.edges[j]; j++) {
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(role) < 0)
                                affectedComponents.push(role);
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            if(otherNode.type === NodeType.ATTRIBUTE && affectedComponents.indexOf(otherComponent) < 0)
                                affectedComponents.push(otherComponent);
                        }
                    }
                    else if ((node.type === NodeType.TIE ||
                            node.type === NodeType.ATTRIBUTE ||
                            node.type === NodeType.KNOT) &&
                            affectedComponents.indexOf(component) < 0) {
                        affectedComponents.push(component);
                        for(j = 0; edge = node.edges[j]; j++) {
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(role) < 0)
                                affectedComponents.push(role);
                        }
                    }
                }
                // check for ties in violation
                for(i = 0; component = this.components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.TIE) {
                        var anchors = 0;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(otherComponent) < 0 && affectedComponents.indexOf(role) < 0)
                                if(otherNode.type === NodeType.ANCHOR)
                                    anchors++;
                        }
                        if(anchors < 2 && affectedComponents.indexOf(component) < 0) {
                            affectedComponents.push(component);
                            for(j = 0; edge = node.edges[j]; j++) {
                                role = this.nodeToComponent(edge);
                                if(affectedComponents.indexOf(role) < 0)
                                    affectedComponents.push(role);
                            }
                        }
                    }
                }
                // check for dangling knots
                for(i = 0; component = this.components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.KNOT) {
                        var dangling = true;
                        for(j = 0; edge = node.edges[j]; j++) {
                            otherNode = (node === edge.otherNode ? edge.node : edge.otherNode);
                            otherComponent = this.nodeToComponent(otherNode);
                            role = this.nodeToComponent(edge);
                            if(affectedComponents.indexOf(otherComponent) < 0 && affectedComponents.indexOf(role) < 0)
                                dangling = false;
                        }
                        if(dangling && affectedComponents.indexOf(component) < 0) {
                            affectedComponents.push(component);
                            for(j = 0; edge = node.edges[j]; j++) {
                                role = this.nodeToComponent(edge);
                                if(affectedComponents.indexOf(role) < 0)
                                    affectedComponents.push(role);
                            }
                        }
                    }
                }
                // need to remove nodes before edges
                affectedComponents.sort(function(firstComponent, secondComponent) {
                    return firstComponent.node.type - secondComponent.node.type;
                });
                if(confirm("Are you sure you want to delete the following\n-------- " +
                        affectedComponents.length + " nodes and edges --------\n" + affectedComponents.join('\n'))) {
                    for(i = 0; component = affectedComponents[i]; i++)
                        this.removeComponent(component);
                    EventHandler.clearSelection();
                    this.recordState();
                    this.refresh();
                    DrawingEngine.start(true);
                }
                return true; // close menu
            },
            connect: function(components) {
                var node, anchor, attribute, tie, knot;
                for(var i = 0; i < components.length; i++) {
                    node = components[i].node;
                    if(node.type === NodeType.ANCHOR)
                        anchor = components[i];
                    else if(node.type === NodeType.ATTRIBUTE)
                        attribute = components[i];
                    else if(node.type === NodeType.TIE)
                        tie = components[i];
                    else if(node.type === NodeType.KNOT)
                        knot = components[i];
                }
                if(anchor && tie) {
                    this.addComponent(new Role(tie, anchor, false));
                }
                else if (attribute && knot) {
                    attribute.setKnotted(true);
                    this.addComponent(new Role(attribute, knot, false));
                }
                else if (tie && knot) {
                    tie.setKnotted(true);
                    this.addComponent(new Role(tie, knot, false));
                }
                this.recordState();
                DrawingEngine.start(true);
                return true; // close menu
            },
            toggleKnotted: function(components) {
                var dx, dy;
                for(var i = 0; i < components.length; i++) {
                    var knot, role, edge;
                    var component = components[i];
                    var node = component.node;
                    if(component.getKnotted()) {
                        for(var j = 0; edge = node.edges[j]; j++) {
                            if(edge.otherNode.type === NodeType.KNOT) {
                                knot = this.nodeToComponent(edge.otherNode);
                                if(edge.otherNode.edges.length === 1) {
                                    if(!confirm("This will also delete the knot: " + knot +
                                            ".\nDo you still want to un-knot the attribute?"))
                                        break;
                                }
                                this.removeComponent(knot);
                                role = this.nodeToComponent(edge);
                                this.removeComponent(role);
                                if(knot.dataRange)
                                    component.dataRange = knot.dataRange;
                                component.setKnotted(false);
                            }
                        }
                    }
                    else {
                        this.lastAngle = (this.lastAngle + 0.5) % 14;
                        dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                        dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                        knot = new Knot(node.xPosition + dx, node.yPosition + dy);
                        if(component.dataRange)
                            knot.dataRange = component.dataRange;
                        this.addComponent(knot);
                        this.addComponent(new Role(component, knot, true));
                        component.setKnotted(true);
                    }
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return true; // close menu
            },
            toggleHistorized: function(components) {
                var component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    component.setHistorized(!component.getHistorized());
                    node = component.node;
                    if(node.type === NodeType.TIE)
                        component.checkIdentifiers();
                }
                this.recordState();
                DrawingEngine.start(false);
                return true; // close menu
            },
            // WIP: keys operations
            createKey: function(components) {
                var i, id, anchor, component, stopComponents = [];
                for(i = 0; component = components[i]; i++) {
                    if(component.node.type === NodeType.ANCHOR) 
                        anchor = component;
                    else
                        stopComponents.push(component);
                }
                if(stopComponents.length > 0)
                    id = UniqueIdentity.nextId();
                for(i = 0; component = stopComponents[i]; i++) {
                    var stopNumber = (i + 1).toString();
                    var key = {
                        id: id,
                        stop: stopNumber,
                        route: '?Route ' + id + '?',
                        of: anchor.mnemonic, 
                        branch: 1 // creation always leads to the first branch
                    };
                    component.keys.push(key);
                    this.addKey(component, key);
                }
                this.recordState();
                EventHandler.clearSelection();
                DrawingEngine.start(false);
                return true; // close menu
            },
            addToKey: function(components) {
                var i, route = EventHandler.selectedRoute;
                if(route) {
                    var component, anchor, stopComponents = [];
                    for(i = 0; component = components[i]; i++) {
                        if(component.node.type === NodeType.ANCHOR) 
                            anchor = component;
                        else
                            stopComponents.push(component);
                    }
                    var stop, maxStopNumber = 0, maxBranchNumber = 0;
                    for(i = 0; i < stopComponents.length; i++) {
                        component = stopComponents[i];
                        for(var stopNumber in route.stops) {
                            stop = route.stops[stopNumber];
                            if(parseInt(stopNumber) > maxStopNumber)
                                maxStopNumber = parseInt(stopNumber);
                            if(parseInt(stop.branch) > maxBranchNumber) 
                                maxBranchNumber = parseInt(stop.branch);
                        }
                    }
                    var actualBranchNumber = maxBranchNumber;
                    if(anchor) // start a new branch if an anchor was in the selection
                        actualBranchNumber = maxBranchNumber + 1;  
                    for(i = 0; i < stopComponents.length; i++) {
                        component = stopComponents[i];
                        // last stop cannot be the same stop
                        if(route.stops[maxStopNumber.toString()].component !== component) {
                            maxStopNumber++;
                            var key = {
                                stop: maxStopNumber.toString(),
                                route: route.name,
                                of: route.start.mnemonic,
                                branch: actualBranchNumber.toString()
                            };
                            component.keys.push(key);
                            component.postfixes.push(maxStopNumber);
                            route.stops[maxStopNumber] = {
                                component: component,
                                branch: key.branch, 
                                key: key // this is the key as represented in the component
                            }
                        }
                    }
                    this.recordState();
                    EventHandler.clearSelection();
                    DrawingEngine.start(false);
                }
                return true; // close menu
            },         
            removeFromKey: function(components) {
                var route = EventHandler.selectedRoute;
                if(route) {
                    var component, deletesHaveBeenMade = false, maxStopNumber = 0;
                    for(var i = 0; i < components.length; i++) {
                        component = components[i];
                        for(var stopNumber in route.stops) {
                            if(parseInt(stopNumber) > maxStopNumber)
                                maxStopNumber = parseInt(stopNumber);
                            if(route.stops[stopNumber].component == component) {
                                var keyIndex = component.keys.indexOf(route.stops[stopNumber].key);
                                component.keys.splice(keyIndex, 1);
                                var postfixIndex = component.postfixes.indexOf(stopNumber);
                                if(postfixIndex >= 0)
                                    component.postfixes.splice(postfixIndex, 1);
                                component.postfixes.splice
                                delete route.stops[stopNumber];
                                deletesHaveBeenMade = true;
                            }
                        }
                    }
                    // renumbering of stops
                    if(deletesHaveBeenMade) {
                        var stops = [];
                        for(var stopNumber = 1; stopNumber <= maxStopNumber; stopNumber++) {
                            if(route.stops[stopNumber]) 
                                stops.push(route.stops[stopNumber]);
                        }
                        if(stops.length > 0) {
                            route.stops = {};
                            for(var s = 0; s < stops.length; s++) {
                                var newStopNumber = (s + 1).toString();
                                stops[s].key.stop = newStopNumber;
                                route.stops[newStopNumber] = stops[s];
                            }
                        }
                        // we removed the last stop of the route
                        else {
                            route.remove();
                            var hash = route.start.mnemonic + '|' + route.name;
                            delete Model.routes[hash];
                        }
                    }
                    this.recordState();
                    EventHandler.clearSelection();
                    DrawingEngine.start(false);                    
                }                
                return true; // close menu
            },   
            toggleIdentifier: function(components) {
                var ties = [], component, node, edge;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    if(node.type === NodeType.EDGE) {
                        edge = node;
                        component.setIdentifier(!component.identifier);
                        if(edge.node.type === NodeType.TIE && ties.indexOf(edge.node) < 0)
                            ties.push(this.nodeToComponent(edge.node));
                        if(edge.otherNode.type === NodeType.TIE && ties.indexOf(edge.otherNode) < 0)
                            ties.push(this.nodeToComponent(edge.otherNode));
                    }
                }
                for(i = 0; i < ties.length; i++)
                    ties[i].checkIdentifiers();
                this.recordState();
                DrawingEngine.start(false);
                return false; // do not close menu
            },
            makeFirstRole: function(components) {
                var tie, component, node, edge;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    if(node.type === NodeType.EDGE) {
                        edge = node;
                        if(tie = edge.node.type === NodeType.TIE ? this.nodeToComponent(edge.node) :
                                 edge.otherNode.type === NodeType.TIE ? this.nodeToComponent(edge.otherNode) :
                                 null) {
                            tie.setFirstRole(component);
                        }
                    }
                }
                this.recordState();
                DrawingEngine.start(false);
                return false; // do not close menu
            },
            lastAngle: 0,
            addAttribute: function(components) {
                var dx, dy, node, component;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var attribute = new Attribute(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(attribute);
                    this.addComponent(new Role(attribute, component, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return false; // do not close menu
            },
            addTie: function(components) {
                var tie, node;
                // multiple anchors selected
                if(components.length > 1) {
                    var i, xAverage = 0, yAverage = 0;
                    for(i = 0; i < components.length; i++) {
                        node = components[i].node;
                        xAverage += node.xPosition;
                        yAverage += node.yPosition;
                    }
                    xAverage /= components.length;
                    yAverage /= components.length;
                    tie = new Tie(xAverage, yAverage, false);
                    this.addComponent(tie);
                    for(i = 0; i < components.length; i++)
                        this.addComponent(new Role(tie, components[i], true));
                }
                // single anchor selected
                else {
                    var anchor = components[0];
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    var dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    var dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    tie = new Tie(anchor.node.xPosition + dx, anchor.node.yPosition + dy, false);
                    this.addComponent(tie);
                    var role = new Role(tie, anchor, true);
                    this.addComponent(role);
                    role = new Role(tie, anchor, true);
                    this.addComponent(role);
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return false; // do not close menu
            },
            addAnchor: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var anchor = new Anchor(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(anchor);
                    this.addComponent(new Role(component, anchor, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return false; // do not close menu
            },
            addTieAndAnchor: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var tie = new Tie(node.xPosition + dx, node.yPosition + dy, false);
                    this.addComponent(tie);
                    var role = new Role(tie, component, true);
                    this.addComponent(role);
                    var anchor = new Anchor(node.xPosition + 2*dx, node.yPosition + 2*dy);
                    this.addComponent(anchor);
                    role = new Role(tie, anchor, true);
                    this.addComponent(role);
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return false; // do not close menu
            },
            addKnot: function(components) {
                var dx, dy, component, node;
                for(var i = 0; i < components.length; i++) {
                    component = components[i];
                    node = component.node;
                    this.lastAngle = (this.lastAngle + 0.5) % 14;
                    dx = 2 * LayoutEngine.normalDistance * Math.cos(this.lastAngle);
                    dy = 2 * LayoutEngine.normalDistance * Math.sin(this.lastAngle);
                    var knot = new Knot(node.xPosition + dx, node.yPosition + dy);
                    this.addComponent(knot);
                    this.addComponent(new Role(component, knot, true));
                }
                this.recordState();
                this.refresh();
                DrawingEngine.start(true);
                return false; // do not close menu
            },
            explode: function(components, startEngine) {
                var node, component, i, j, k, edge, otherNode, otherComponent;
                var role, knot, knotComponent, knotEdge, knotEdgeComponent, visibleEdges;
                for(i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(node.type === NodeType.ANCHOR) {
                        if(component.imploded) {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node === node ? edge.otherNode : edge.node;
                                if(otherNode.type === NodeType.ATTRIBUTE) {
                                    var dx = 2 * LayoutEngine.normalDistance * Math.cos(j);
                                    var dy = 2 * LayoutEngine.normalDistance * Math.sin(j);
                                    otherComponent = this.nodeToComponent(otherNode);
                                    if(otherComponent.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node === otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot.type === NodeType.KNOT) {
                                                break;
                                            }
                                        }
                                        knotComponent = this.nodeToComponent(knot);
                                        if(!knot.visible) {
                                            knot.xPosition = node.xPosition + 2*dx;
                                            knot.yPosition = node.yPosition + 2*dy;
                                            knot.start();
                                            knot.visible = true;
                                            knotComponent.setFixed(false);
                                            knotComponent.show();
                                        }
                                        knotEdgeComponent = this.nodeToComponent(knotEdge);
                                        knotEdge.start();
                                        knotEdge.visible = true;
                                        knotEdgeComponent.show();
                                    }
                                    otherComponent = this.nodeToComponent(otherNode);
                                    otherNode.xPosition = node.xPosition + dx;
                                    otherNode.yPosition = node.yPosition + dy;
                                    otherNode.start();
                                    otherComponent.setFixed(false);
                                    otherComponent.show();
                                    otherNode.visible = true;
                                    role = this.nodeToComponent(edge);
                                    edge.start();
                                    role.show();
                                    edge.visible = true;
                                }
                            }
                        }
                        else {
                            for(j = 0; edge = node.edges[j]; j++) {
                                otherNode = edge.node === node ? edge.otherNode : edge.node;
                                if(otherNode.type === NodeType.ATTRIBUTE) {
                                    otherComponent = this.nodeToComponent(otherNode);
                                    if(otherComponent.knotted) {
                                        for(k = 0; knotEdge = otherNode.edges[k]; k++) {
                                            knot = knotEdge.node === otherNode ? knotEdge.otherNode : knotEdge.node;
                                            if(knot.type === NodeType.KNOT) {
                                                break;
                                            }
                                        }
                                        knotComponent = this.nodeToComponent(knot);
                                        knotEdgeComponent = this.nodeToComponent(knotEdge);
                                        knotEdgeComponent.hide();
                                        knotEdge.stop();
                                        knotEdge.visible = false;
                                        visibleEdges = 0;
                                        for(k = 0; knotEdge = knot.edges[k]; k++)
                                            if(knotEdge.visible)
                                                visibleEdges++;
                                        if(visibleEdges === 0) {
                                            knotEdgeComponent.hide();
                                            knotComponent.hide();
                                            knot.stop();
                                            knot.visible = false;
                                        }
                                    }
                                    otherComponent.hide();
                                    otherNode.stop();
                                    otherNode.visible = false;
                                    role = this.nodeToComponent(edge);
                                    role.hide();
                                    edge.stop();
                                    edge.visible = false;
                                }
                            }
                        }
                        component.setImploded(!component.imploded);
                    }
                }
                // if at least one imploded component exists
                // hide key layer, otherwise show key layer
                var allExloded = true;
                for(var i = 0; i < this.components.length; i++) {
                    component = this.components[i];
                    if(component.imploded) {
                        SVGLayer.hide('keys');
                        allExloded = false;
                        break;
                    }
                }                
                if(allExloded) {
                    SVGLayer.show('keys');
                }
                this.refresh();
                if(startEngine == null || startEngine)
                    DrawingEngine.start(true);
                return false; // do not close menu
            }
        };

        var DrawingEngine = {
            // holds the "thread" id when the drawing engine is running
            drawId: null,
            initialized: false,
            running: false,
            miniCounter: 0,
            miniature: null,
            showNames: true,
            showKeys: true,
            coloring: true,
            newState: true,
            miniatureFramesBetweenRefresh: 50,
            layout: false,
            viewport: null,
            screenCircumference: 0,
            partitionElements: [],
            init: function() {
                var requestAnimationFrame =
                        window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        window.oRequestAnimationFrame;
                window.requestAnimationFrame = requestAnimationFrame;
                if(!window.requestAnimationFrame) {
                    window.requestAnimationFrame = function(callback, image) {
                        return setTimeout(callback, 10);
                    };
                }
                var cancelRequestAnimationFrame =
                        window.cancelRequestAnimationFrame ||
                        window.webkitCancelRequestAnimationFrame ||
                        window.mozCancelRequestAnimationFrame ||
                        window.msCancelRequestAnimationFrame ||
                        window.oCancelRequestAnimationFrame;
                window.cancelRequestAnimationFrame = cancelRequestAnimationFrame;
                if(!window.cancelRequestAnimationFrame) {
                    window.cancelRequestAnimationFrame = function(id) {
                        return clearTimeout(id);
                    };
                }
                this.viewport = document.createElementNS(SVGNS, 'rect');
                this.viewport.setAttributeNS(null, 'id', 'viewport');
                this.viewport.setAttributeNS(null, 'x', SVG.viewBox.baseVal.x);
                this.viewport.setAttributeNS(null, 'y', SVG.viewBox.baseVal.y);
                this.viewport.setAttributeNS(null, 'width', SVG.viewBox.baseVal.width);
                this.viewport.setAttributeNS(null, 'height', SVG.viewBox.baseVal.height);
                this.viewport.setAttributeNS(null, 'style', 'stroke: red; stroke-width: 2px; fill: none;');
                this.initialized = true;
            },
            taint: function() {
                this.partitionElements = [];
            },
            storeSettings: function(storage) {
                storage.setItem("viewportX", SVG.viewBox.baseVal.x);
                storage.setItem("viewportY", SVG.viewBox.baseVal.y);
                storage.setItem("viewportWidth", SVG.viewBox.baseVal.width);
                storage.setItem("viewportHeight", SVG.viewBox.baseVal.height);
            },
            loadSettings: function(storage) {
                SVG.viewBox.baseVal.x = 1 * storage.getItem("viewportX") || 0;
                SVG.viewBox.baseVal.y = 1 * storage.getItem("viewportY") || 0;
                SVG.viewBox.baseVal.width = 1 * storage.getItem("viewportWidth") || window.innerWidth;
                SVG.viewBox.baseVal.height = 1 * storage.getItem("viewportHeight") || window.innerHeight;
                this.invalidateMiniature();
                this.start(false);
            },
            setCursor: function(cursor) {
                document.body.style.cursor = cursor;
            },
            start: function(layoutModel) {
                if(this.initialized) {
                    this.layout = layoutModel;
                    if(!this.running) {
                        this.running = true;
                        this.drawId = window.requestAnimationFrame(DrawingEngine.engine, SVG);
                        if(this.layout)
                            ControlButtons.setPauseState();
                    }
                }
            },
            stop: function() {
                if(this.running) {
                    window.cancelRequestAnimationFrame(this.drawId);
                    this.running = false;
                    ControlButtons.setPlayState();
                }
            },
            engine: function() {
                // layout nodes
                if(DrawingEngine.layout || !LayoutEngine.equilibrium) {
                    LayoutEngine.layout(Model.visibleNodes);
                    DrawingEngine.newState = true;
                }
                DrawingEngine.draw();
                // check if all nodes have stopped moving and that we may stop
                if(LayoutEngine.equilibrium) {
                    DrawingEngine.stop();
                    DrawingEngine.invalidateMiniature();
                    if(DrawingEngine.newState) {
                        DrawingEngine.newState = false;
                        Model.recordState();
                    }
                    DrawingEngine.layout = false;
                    ControlButtons.setPlayState();
                }
                else if(DrawingEngine.running) {
                    window.requestAnimationFrame(DrawingEngine.engine, SVG);
                }
            },
            invalidateMiniature: function() {
                this.miniCounter = 0;
            },
            drawPartitions: function() {
                var partition, partitionElement, centerElement, k, key;
                var keys = Object.keys(LayoutEngine.partitions);
                var lost = this.partitionElements.filter(function(i) {return !(keys.indexOf(i) > -1);});
                k = lost.length;
                while(k--) {
                    key = lost[k];
                    partitionElement = document.getElementById(key);
                    SVGLayer.debugPartitions.removeChild(partitionElement);
                    this.partitionElements.splice(this.partitionElements.indexOf(key),1);
                    centerElement = document.getElementById('c' + key);
                    SVGLayer.debugPartitions.removeChild(centerElement);
                }
                k = keys.length;
                while(k--) {
                    key = keys[k];
                    partition = LayoutEngine.partitions[key];
                    partitionElement = document.getElementById(key);
                    centerElement = document.getElementById('c' + key);
                    if(!partitionElement) {
                        partitionElement = document.createElementNS(SVGNS, 'rect');
                        partitionElement.setAttributeNS(null, 'id', key);
                        SVGLayer.debugPartitions.appendChild(partitionElement);
                        this.partitionElements.push(key);
                        centerElement = document.createElementNS(SVGNS, 'circle');
                        centerElement.setAttributeNS(null, 'id', 'c' + key);
                        centerElement.style.strokeWidth = 2;
                        SVGLayer.debugPartitions.appendChild(centerElement);
                    }
                    partitionElement.x.baseVal.value = partition.xMin;
                    partitionElement.y.baseVal.value = partition.yMin;
                    partitionElement.width.baseVal.value = partition.xMax - partition.xMin;
                    partitionElement.height.baseVal.value = partition.yMax - partition.yMin;
                    centerElement.cx.baseVal.value = partition.xPosition;
                    centerElement.cy.baseVal.value = partition.yPosition;
                    centerElement.r.baseVal.value = 100*(Math.abs(partition.xVelocity) + Math.abs(partition.yVelocity));
                }
            },
            // WIP: keys draw
            drawRoutes: function() {
                var route;
                for(var hash in Model.routes) {  
                    route = Model.routes[hash];
                    // create some utility functions on the route
                    if(!route.toggleHighlight) {
                        route.hightlighted = false;
                        route.toggleHighlight = function() {
                            if(this.svgKeyRoute) {
                                var hash = this.svgKeyRoute.getAttribute('id');
                                if(!this.hightlighted) {
                                    this.svgKeyRoute.setAttributeNS(null, 'class', 'routeSelected'); 
                                    if(!this.svgKeyRouteText) {
                                        this.svgKeyRouteText = document.createElementNS(SVGNS, 'text');
                                        this.svgKeyRouteText.setAttributeNS(null, 'class', 'routeText');
                                        this.svgKeyRouteText.textPath = document.createElementNS(SVGNS, 'textPath');
                                        this.svgKeyRouteText.text = document.createTextNode(this.name);
                                        this.svgKeyRouteText.textPath.appendChild(this.svgKeyRouteText.text);
                                        this.svgKeyRouteText.textPath.setAttributeNS(null, 'href', '#' + hash);
                                        this.svgKeyRouteText.textPath.setAttributeNS(null, 'startOffset', '17');
                                        this.svgKeyRouteText.appendChild(this.svgKeyRouteText.textPath);
                                        SVGLayer.keys.appendChild(this.svgKeyRouteText);
                                    }
                                    // add a text box for the route name
                                    this.routeInput = document.createElement('input');
                                    this.routeInput.setAttribute('id', 'route');
                                    this.routeInput.value = this.name;
                                    this.routeInput.addEventListener('input', function(e) {
                                        var route = EventHandler.routeSelected();
                                        Model.changeRouteName(route, e.target.value.trim());
                                        var hash = (route.start.mnemonic + '|' + route.name).trim();
                                        route.svgKeyRoute.setAttributeNS(null, 'id', hash);
                                        route.svgKeyRouteText.textPath.setAttributeNS(null, 'href', '#' + hash);
                                        route.svgKeyRouteText.text.nodeValue = e.target.value;
                                    }, false);
                                    document.body.appendChild(this.routeInput);                                    
                                    for(var stopNumber in this.stops) 
                                        this.stops[stopNumber].component.postfixes.push(stopNumber);
                                    this.hightlighted = true;
                                    DrawingEngine.start(false);
                                }   
                                else {
                                    if(this.svgKeyRouteText) {
                                        if(SVGLayer.keys.contains(this.svgKeyRouteText))
                                            SVGLayer.keys.removeChild(this.svgKeyRouteText);
                                        delete this.svgKeyRouteText;
                                    }
                                    if(this.routeInput) {
                                        if(document.body.contains(this.routeInput))
                                            document.body.removeChild(this.routeInput);
                                        delete this.routeInput;
                                    }
                                    for(var stopNumber in this.stops) 
                                        this.stops[stopNumber].component.postfixes = [];
                                    this.svgKeyRoute.setAttributeNS(null, 'class', 'route'); 
                                    this.hightlighted = false;
                                    DrawingEngine.start(false);
                                }                         
                            }
                        }
                    }
                    if(!route.remove) {
                        route.remove = function() {
                            if(this.hightlighted)
                                this.toggleHighlight();
                            if(this.routeInput) {
                                if(document.body.contains(this.routeInput))
                                    document.body.removeChild(this.routeInput);
                                delete this.routeInput;
                            }
                            if(this.svgKeyRouteText) {
                                if(SVGLayer.keys.contains(this.svgKeyRouteText))
                                    SVGLayer.keys.removeChild(this.svgKeyRouteText);
                                delete this.svgKeyRouteText;
                            }
                            if(this.svgKeyRoute) {
                                if(SVGLayer.keys.contains(this.svgKeyRoute))
                                    SVGLayer.keys.removeChild(this.svgKeyRoute);
                                delete this.svgKeyRoute;
                            }
                            var hash = this.start.mnemonic + '|' + this.name;
                            delete Model.routes[hash];                            
                        }
                    }
                    // this is the actual svg element
                    if(!route.svgKeyRoute) {
                        route.svgKeyRoute = document.createElementNS(SVGNS, 'path');
                        route.svgKeyRoute.component = route; // for use in captured events
                        route.svgKeyRoute.setAttributeNS(null, 'id', hash);
                        route.svgKeyRoute.setAttributeNS(null, 'class', 'route');
                        route.svgKeyRoute.addEventListener('mouseover', function(e) { 
                            if(!EventHandler.routeSelected() && !this.component.hightlighted) 
                                this.component.toggleHighlight();
                        }, false);
                        route.svgKeyRoute.addEventListener('mouseout', function(e) { 
                            if(!EventHandler.routeSelected() && this.component.hightlighted) 
                                this.component.toggleHighlight(); 
                        }, false);
                        route.svgKeyRoute.addEventListener('click', function(e) {
                            EventHandler.clearInteraction(); // remove the click that would otherwise result in panning
                            var hash = this.getAttribute('id');
                            var route = Model.routes[hash];                            
                            if(!EventHandler.routeSelected()) {
                                if(!route.hightlighted) route.toggleHighlight();
                                EventHandler.selectRoute(route);
                            }
                            else if(EventHandler.routeSelected() == route) {
                                if(route.hightlighted) route.toggleHighlight();
                                EventHandler.clearSelection();
                            }
                        }, false);
                        SVGLayer.keys.appendChild(route.svgKeyRoute);
                    }
                    var stops = route.start.node.xPosition.toFixed(2) + ',' + route.start.node.yPosition.toFixed(2);
                    var stop, currentBranch; 
                    for(var stopNumber in route.stops) {
                        stop = route.stops[stopNumber];
                        if(stop.branch != currentBranch) {
                            stops += ' M' + 
                                route.start.node.xPosition.toFixed(2) + ',' + 
                                route.start.node.yPosition.toFixed(2);
                            currentBranch = stop.branch;
                        }
                        stops += ' ' + 
                            stop.component.node.xPosition.toFixed(2) + ',' + 
                            stop.component.node.yPosition.toFixed(2);
                    }
                    route.svgKeyRoute.setAttributeNS(null, 'd', 'M' + stops);
                }
            },
            draw: function() {
                if(DEBUG)
                    this.drawPartitions();
                if(this.showKeys)
                    this.drawRoutes();
                // draw the miniature every minirate frames
                this.miniCounter = (this.miniCounter + 1) % this.miniatureFramesBetweenRefresh;
                var component, node;
                var i = Model.components.length;
                while(i--) {
                    component = Model.components[i];
                    node = component.node;
                    if(node.visible) {
                        if(node.moving)
                            component.draw(component.svg);
                        if(DEBUG)
                            component.drawForce(component.svg);
                        if(this.miniCounter === 1)
                            component.draw(component.nav);
                        if(this.showNames)
                            component.drawName(node.xPosition, node.yPosition);
                    }
                }
                if(this.miniCounter === 1)
                    this.updateMiniature();
            },
            updateMiniature: function() {
                if(!NAVLayer.viewport.contains(this.viewport))
                    NAVLayer.viewport.appendChild(this.viewport);
                this.viewport.x.baseVal.value = SVG.viewBox.baseVal.x;
                this.viewport.y.baseVal.value = SVG.viewBox.baseVal.y;
                this.viewport.width.baseVal.value = SVG.viewBox.baseVal.width || window.innerWidth;
                this.viewport.height.baseVal.value = SVG.viewBox.baseVal.height || window.innerHeight;
                var nodeBox = NAV.getElementById('nodes').getBBox();
                var pad = 50;
                var width = nodeBox.width + 2 * pad;
                var height = nodeBox.height + 2 * pad;
                var screenCircumference = window.innerWidth + window.innerHeight;
                var viewportCircumference = width + height;
                var scale;
                if(viewportCircumference < screenCircumference/6) {
                    scale = screenCircumference/6/viewportCircumference;
                    width *= scale;
                    height *= scale;
                }
                else if(viewportCircumference > screenCircumference/4) {
                    scale = screenCircumference/4/viewportCircumference;
                    height *= scale;
                    width *= scale;
                }
                NAV.width.baseVal.value = width;
                NAV.height.baseVal.value = height;
                NAV.viewBox.baseVal.x = nodeBox.x - pad;
                NAV.viewBox.baseVal.y = nodeBox.y - pad;
                NAV.viewBox.baseVal.width = nodeBox.width + 2 * pad;
                NAV.viewBox.baseVal.height = nodeBox.height + 2 * pad;
            }
        };

        var UniqueIdentity = {
            lastId: 0,
            usedIds: [],
            nextId: function() {
                while(this.usedIds[++this.lastId]);
                this.usedIds[this.lastId] = true;
                return this.lastId;
            },
            takeId: function(id) {
                this.usedIds[id] = true;
                return id;
            }
        };

        function createOption(value, text) {
            var o = document.createElement('option');
            o.value = value;
            if(!text) text = value;
            o.text = text;
            return o;
        };

        var Editables = {
            setEditability: function(edit, isEditable) { edit.editable = isEditable; },
            descriptorEdit: {
                name: 'Descriptor',
                description:
                       'Should be a descriptive name of that which you are creating. ' +
                       'An understandable description of something found in the domain ' +
                       'you are modeling, for example "CoffeeMachine".',
                setMember: function (element, component) { component.descriptor = element.value; },
                getMember: function (component) { return component.descriptor; },
                setElement: function (element, component) { element.value = component.descriptor; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '(' + UPPER + LOWER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            twoMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A two letter mnemonic, that needs to be unique within the entire ' +
                       'model. If an anchor is named "CoffeeMachine" for example, then ' +
                       '"CM" is a suitable mnemonic.',
                setMember: function (element, component) { component.mnemonic = element.value; },
                getMember: function (component) { return component.mnemonic; },
                setElement: function (element, component) { element.value = component.mnemonic; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: UPPER + '{2}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            threeMnemonicEdit: {
                name: 'Mnemonic',
                description:
                       'A three letter mnemonic, that needs to be unique within the entire ' +
                       'model for knots, but only within the anchor for attributes. If an ' +
                       'attribute is named "Capacity" for example, then "CAP" is a ' +
                       'suitable mnemonic.',
                setMember: function (element, component) { component.mnemonic = element.value; },
                getMember: function (component) { return component.mnemonic; },
                setElement: function (element, component) { element.value = component.mnemonic; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: UPPER + '{3}',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            dataRangeEdit: {
                name: 'Data range',
                description: 'The data type of the column in the resulting implementation.',
                setMember: function (element, component) { component.dataRange = element.value; },
                getMember: function (component) { return component.dataRange; },
                setElement: function (element, component) { element.value = component.dataRange; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required','list','datatypeList']
            },
            changingRangeEdit: {
                name: 'Time range',
                description:
                       'Changing time data type. Versions of data are stored over changing time ' +
                       'and this data type should be granular enough to handle the expected ' +
                       'update frequency.',
                setMember: function (element, component) { component.changingRange = element.value; },
                getMember: function (component) { return component.changingRange; },
                setElement: function (element, component) { element.value = component.changingRange; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required','list','datetimeList']
            },
            positIdentityEdit: {
                name: 'Posit identity',
                description:
                        'Posit identity data type. This should be at large enough to be able to give ' +
                        'identities to all posits that will be stored. With rapidly changing ' +
                        'data this may be much larger than the other involved identities.',
                setMember: function (element, component) { component.positIdentity = element.value; },
                getMember: function (component) { return component.positIdentity; },
                setElement: function (element, component) { element.value = component.positIdentity; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required','list','integerList']
            },
            identityEdit: {
                name: 'Identity',
                description:
                       'Identity data type. The identity is an abstract and immutable property ' +
                       'that uniquely identifies an entity. If you expect to store very many ' +
                       'entities you also need an appropriately large data type.',
                setMember: function (element, component) { component.identity = element.value; },
                getMember: function (component) { return component.identity; },
                setElement: function (element, component) { element.value = component.identity; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '.*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required','list','integerList']
            },
            positGeneratorEdit: {
                name: 'Posit generator',
                description:
                        'Posit identity generator. Check this if you would like the database to generate ' +
                        ' posit identities for you through some auto incremented sequence. Uncheck if you ' +
                        'intend to manage your identities somewhere else.',
                setMember: function (element, component) { component.positGenerator = element.checked; },
                getMember: function (component) { return component.positGenerator; },
                setElement: function (element, component) { element.checked = component.positGenerator; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            generatorEdit: {
                name: 'Generator',
                description:
                       'Identity generator. Check this if you would like the database to generate ' +
                       'identities for you through some auto incremented sequence. Uncheck if you ' +
                       'intend to manage your identities somewhere else.',
                setMember: function (element, component) { component.generator = element.checked; },
                getMember: function (component) { return component.generator; },
                setElement: function (element, component) { element.checked = component.generator; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            deletabilityEdit: {
                name: 'Deletable',
                description:
                       'Check this if you want to be able to "delete" values using an update statement ' +
                       'with a null value and a later changing time then of the latest existing value. ' +
                       'Affected rows will be moved to a deletion table.',
                setMember: function (element, component) { component.deletable = element.checked; },
                getMember: function (component) { return component.deletable; },
                setElement: function (element, component) { element.checked = component.deletable; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            restatabilityEdit: {
                name: 'Restatable',
                description:
                       'Check this if you want to allow temporal restatements. A temporal restatement ' +
                       'is when two consecutive values over changing time are identical. Uncheck this ' +
                       'to introduce a constraint preventing restatements from being made.',
                setMember: function (element, component) { component.restatable = element.checked; },
                getMember: function (component) { return component.restatable; },
                setElement: function (element, component) { element.checked = component.restatable; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            idempotencyEdit: {
                name: 'Idempotent',
                description:
                       'Checking this modifies the insert and update triggers such that changed values ' +
                       'must be different in order to be recorded. Idempotency is not recommended when ' +
                       'data can arrive asynchronously with respect to changing time.',
                setMember: function (element, component) { component.idempotent = element.checked; },
                getMember: function (component) { return component.idempotent; },
                setElement: function (element, component) { element.checked = component.idempotent; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            assertivenessEdit: {
                name: 'Assertive',
                description:
                       'Checking this modifies the insert and update triggers such that the annex will ' +
                       'get new rows everytime a posit is made with a different positing time. Otherwise ' +
                       'the annex will only get new rows if the reliability changes as well.',
                setMember: function (element, component) { component.assertive = element.checked; },
                getMember: function (component) { return component.assertive; },
                setElement: function (element, component) { element.checked = component.assertive; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            equivalenceEdit: {
                name: 'Equivalent',
                description:
                        'Checking this makes it possible to store several equivalent values, ' +
                        'which for example is useful when multilingualism or multitenancy is desired.',
                setMember: function (element, component) { component.equivalent = element.checked; },
                getMember: function (component) { return component.equivalent; },
                setElement: function (element, component) { element.checked = component.equivalent; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            checksumEdit: {
                name: 'Checksum',
                description:
                        'Checking this indicates that your data type is too large to fit in ' +
                        'indexes, and a calculated checksum column will be added that can be  ' +
                        'used instead.',
                setMember: function (element, component) { component.checksum = element.checked; },
                getMember: function (component) { return component.checksum; },
                setElement: function (element, component) { element.checked = component.checksum; },
                getElement: function (element) { return element.checked; },
                editable: true,
                type: 'input',
                event: 'click',
                attributes: ['type', 'checkbox']
            },
            encryptionGroupEdit: {
                name: 'Encryption group',
                description:
                        'Setting this to anything but an empty string indicates that your data should be encrypted at rest. ' +
                        'When encryption is used, data is encrypted according to different encryption gruoups. These ' +
                        'groups are identified by the strings you assign here.',
                setMember: function (element, component) { component.encryptionGroup = element.value; },
                getMember: function (component) { return component.encryptionGroup; },
                setElement: function (element, component) { element.value = component.encryptionGroup; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: null, // anything and nothing are all fine
                event: 'blur',
                attributes: ['type', 'text']
            },
            roleEdit: {
                name: 'Role',
                description:
                       'The role of the connected entity in the relationship. The same entity may, for example ' +
                       'participate more than once in the same relationship and must therefore be distinguished ' +
                       'through which role it plays. Because of this, roles must be unique within a tie.',
                setMember: function (element, component) { component.role = element.value; },
                getMember: function (component) { return component.role; },
                setElement: function (element, component) { element.value = component.role; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '(' + LOWER + UPPER + '*)+',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            coloringEdit: {
                name: 'Coloring',
                description:
                        'Coloring can be used to create your own visual separation of the components in a model. It ' +
                        'has no effect on the implementation.',
                setMember: function (element, component) { component.setColoring(element.value); },
                getMember: function (component) { return component.coloring; },
                setElement: function (element, component) { element.value = component.coloring; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: '#[0-9A-Fa-f]{6}',
                event: 'change',
                attributes: ['type', 'color', 'required', 'required']
            },
            encapsulationEdit: {
                name: 'Capsule',
                description:
                       'In order to achieve separation of concerns, different parts of the model can be encapsulated ' +
                       'in different "capsules", which translate to schemas in the relational database implementation.',
                setMember: function (element, component) { component.encapsulation = element.value; },
                getMember: function (component) { return component.encapsulation; },
                setElement: function (element, component) { element.value = component.encapsulation; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'input',
                pattern: LOWER + '*',
                event: 'blur',
                attributes: ['type', 'text', 'required', 'required']
            },
            descriptionEdit: {
                name: 'Description',
                description:
                        'A textual description of this item.',
                setMember: function (element, component) { component.description = element.value; },
                getMember: function (component) { return component.description; },
                setElement: function (element, component) { element.value = component.description; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'textarea',
                pattern: null, // anything and nothing are all fine
                event: 'blur',
                attributes: ['rows', '3', 'cols', '16']
            },
            privacyEdit: {
                name: 'Privacy action',
                description:
                        'Determines the action to take when data in this attribute becomes subject to ' +
                        'privacy regulations, such as being "forgotten" according to GDPR. This is so ' +
                        'far only of informational character and is stored in the model metadata, but ' +
                        'can be used to create your own automation procedures.',
                setMember: function (element, component) { component.privacy = element.value; },
                getMember: function (component) { return component.privacy; },
                setElement: function (element, component) { element.value = component.privacy; },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'select',
                pattern: null, // anything and nothing are all fine
                event: 'click',
                attributes: [],
                elements: [
                    createOption('Ignore'),
                    createOption('Delete'),
                    createOption('Anonymize'),
                    createOption('Pseudonymize'),
                    createOption('Encrypt')
                ]
            },
            keySelectEdit: {
                name: 'Select key',
                description:
                        'Selects which key this identifier should be built from.',
                setMember: function (element, component) { component.setRoute(element.value); },
                getMember: function (component) { return component.getRoute(); },
                setElement: function (element, component) { element.value = component.getRoute(); },
                getElement: function (element) { return element.value; },
                editable: true,
                type: 'select',
                pattern: null, // anything and nothing are all fine
                event: 'click',
                attributes: [],
                prepare: function(component) { component.prepareEditing(this) },
                elements: [] // needs to be set by the creating component in prepareEditing()
            }
        };

        var EventHandler = {
            selectedComponents: [], // may be larger than interacted with SHIFT clicks
            interactedComponents: [], // currently "touched" components
            interaction: null,
            previousInteraction: null,
            lastX: null,
            lastY: null,
            scaleX: null,
            scaleY: null,
            // WIP: keys event
            selectedRoute: null,
            selectRoute: function(key) {
                this.selectedRoute = key;
            },
            routeSelected: function() {
                return this.selectedRoute;
            },
            addComponentToSelection: function(component) {
                if(this.selectedComponents.indexOf(component) < 0)
                    this.selectedComponents.push(component);
                component.setSelection(true);
            },
            removeComponentFromSelection: function(component) {
                if(this.selectedComponents.indexOf(component) >= 0)
                    this.selectedComponents.splice(this.selectedComponents.indexOf(component), 1);
                component.setSelection(false);
            },
            clearSelection: function() {
                var component;
                while(component = this.selectedComponents.pop()) {
                    this.removeComponentFromSelection(component);
                }
                if(this.selectedRoute) {
                    if(this.selectedRoute.highlighed)
                        this.selectedRoute.toggleHighlight();
                    this.selectedRoute = null;
                }
                this.setInteraction(null);
            },
            escape: function (event) {
                if (event.keyCode == 27) {
                    EventHandler.clearSelection();
                    var component = EventHandler.interactedComponents[0];
                    if(component) {
                        component.hideContextMenu();
                    }
                }
            },
            isSelected: function(component) {
                return this.selectedComponents.indexOf(component) >= 0;
            },
            setInteraction: function(interaction) {
                if(this.interaction) this.previousInteraction = this.interaction;
                this.interaction = interaction;
            },
            getInteraction: function() {
                return this.interaction;
            },
            getPreviousInteraction: function() {
                return this.previousInteraction;
            },
            addComponentToInteraction: function(component) {
                if(this.interactedComponents.indexOf(component) < 0)
                    this.interactedComponents.push(component);
                component.setHighlight(true);
            },
            removeComponentFromInteraction: function(component) {
                if(this.interactedComponents.indexOf(component) >= 0)
                    this.interactedComponents.splice(this.interactedComponents.indexOf(component), 1);
                component.setHighlight(false);
            },
            clearInteraction: function() {
                var component;
                while(component = this.interactedComponents.pop()) {
                    this.removeComponentFromInteraction(component);
                }
                this.setInteraction(null);
            },
            isInteracted: function(component) {
                return this.interactedComponents.indexOf(component) >= 0;
            },
            hasOngoingInteractions: function() {
                return this.interaction != null;
            },
            beginInteraction: function(event) {
                event.preventDefault();
                var component = this.component; // note that _this_ refers to the SVG element here
                if(!EventHandler.hasOngoingInteractions() && component.isInteractive()) {
                    EventHandler.setInteraction("beginInteraction");
                    if(!EventHandler.isInteracted(component))
                        EventHandler.addComponentToInteraction(component);
                    window.addEventListener('keypress', EventHandler.keypress, false);
                    SVG.addEventListener('mouseover', EventHandler.endInteraction, false);
                    component.svg.graphicsElement.addEventListener('mousedown', EventHandler.prepareDragging, false);
                    component.svg.graphicsElement.addEventListener('click', EventHandler.clickComponent, false);
                    component.showContextMenu(component, EventHandler.selectedComponents, EventHandler.selectedRoute);
                    DrawingEngine.setCursor('pointer');
                }
                event.stopPropagation();
            },
            prepareDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "beginInteraction") {
                    EventHandler.setInteraction("prepareDragging");
                    var component, i;
                    for(i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        if(event.shiftKey) {
                            if(EventHandler.isSelected(component)) {
                                EventHandler.removeComponentFromSelection(component);
                                component.setHighlight(true);
                            }
                            else {
                                EventHandler.addComponentToSelection(component);
                                component.setHighlight(false);
                            }
                        }
                        component.hideContextMenu();
                        component.svg.graphicsElement.removeEventListener('mousedown', EventHandler.prepareDragging, false);
                    }
                    SVG.addEventListener('mousemove', EventHandler.whileDragging, false);
                }
                event.stopPropagation();
            },
            whileDragging: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileDragging" ||
                        EventHandler.getInteraction() === "prepareDragging") {
                    var component, i, svgPoint;
                    for(i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        if(component.isInteractive() && component.isDraggable()) {
                            svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY);
                            if(EventHandler.getInteraction() === "whileDragging") {
                                component.node.xPosition = svgPoint.x;
                                component.node.yPosition = svgPoint.y;
                                component.setFixed(true);
                                component.node.setUnstoppable(true);
                                Model.invalidateComponent(component);
                                DrawingEngine.start(true);
                            }
                            else if(EventHandler.getInteraction() === "prepareDragging") {
                                if(LayoutEngine.manhattanDistance(component.node, {
                                    xPosition: svgPoint.x,
                                    yPosition: svgPoint.y
                                }) > 10) {
                                    EventHandler.setInteraction("whileDragging");
                                    DrawingEngine.setCursor('move');
                                }
                            } // switch behavior if we actually move the thing a fair distance
                        }
                    }
                }
                event.stopPropagation();
            },
            clickComponent: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() !== "whileDragging" && !event.shiftKey) {
                    var component, i = EventHandler.interactedComponents.length;
                    while(i--) {
                        component = EventHandler.interactedComponents[i];
                        component.setFixed(!component.getFixed());
                    }
                    EventHandler.setInteraction("toggledFixation");
                }
                else {
                    EventHandler.setInteraction("completeDragging");
                }
                event.stopPropagation();
            },
            clickHighlight: function(event) {
                // nothing assigned to this action right now
            },
            clickSelection: this.clickHighlight,
            endInteraction: function(event) {
                if(event) event.preventDefault();
                var component = EventHandler.interactedComponents[EventHandler.interactedComponents.length - 1];
                if(!event || (event.toElement !== component.svg.graphicsElement &&
                        EventHandler.getInteraction() !== "whileDragging")) {
                    for(var i = 0; component = EventHandler.interactedComponents[i]; i++) {
                        component.hideContextMenu();
                        component.node.setUnstoppable(false);
                        component.svg.graphicsElement.removeEventListener('click', EventHandler.clickComponent, false);
                    }
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whileDragging, false);
                    SVG.removeEventListener('mouseover', EventHandler.endInteraction, false);
                    window.removeEventListener('keypress', EventHandler.keypress, false);
                    DrawingEngine.setCursor('default');
                }
                if(event) event.stopPropagation();
            },
            preparePanning: function(event) {
                event.preventDefault();
                if(event.shiftKey) {
                    // we are shift clicking the background
                    EventHandler.clearSelection();
                }
                else if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("preparePanning");
                    var screenWidth = window.innerWidth;
                    var screenHeight = window.innerHeight;
                    var viewBoxWidth = SVG.viewBox.baseVal.width || screenWidth;
                    var viewBoxHeight = SVG.viewBox.baseVal.height || screenHeight;
                    EventHandler.scaleX = viewBoxWidth / screenWidth;
                    EventHandler.scaleY = viewBoxHeight / screenHeight;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                    SVG.addEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.addEventListener('mouseup', EventHandler.completePanning, false);
                    DrawingEngine.setCursor('move');
                }
                event.stopPropagation();
            },
            whilePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning" ||
                        EventHandler.getInteraction() === "preparePanning") {
                    EventHandler.setInteraction("whilePanning");
                    SVG.viewBox.baseVal.x -= (event.clientX - EventHandler.lastX) * EventHandler.scaleX;
                    SVG.viewBox.baseVal.y -= (event.clientY - EventHandler.lastY) * EventHandler.scaleY;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                }
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false); // TODO: this should halt layouting and just pan, but it does not
                event.stopPropagation();
            },
            completePanning: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whilePanning") {
                    EventHandler.setInteraction("completePanning");
                    EventHandler.clearInteraction();
                    SVG.removeEventListener('mousemove', EventHandler.whilePanning, false);
                    SVG.removeEventListener('mouseup', EventHandler.completePanning, false);
                    DrawingEngine.setCursor('default');
                }
                event.stopPropagation();
            },
            scaling: 0.03,
            zoom: function(event) {
                event.preventDefault();
                var zoom = 1 + ((event.deltaY > 0) ? 1 : -1) * EventHandler.scaling;
                var width = SVG.viewBox.baseVal.width || SVG.width.baseVal.value;
                var height = SVG.viewBox.baseVal.height || SVG.height.baseVal.value;
                var x = SVG.viewBox.baseVal.x;
                var y = SVG.viewBox.baseVal.y;
                var svgPoint = EventHandler.screenToSVG(event.clientX, event.clientY);
                SVG.viewBox.baseVal.width = width * zoom;
                SVG.viewBox.baseVal.height = height * zoom;
                SVG.viewBox.baseVal.x = x + (1 - zoom) * (svgPoint.x - x);
                SVG.viewBox.baseVal.y = y + (1 - zoom) * (svgPoint.y - y);
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            resize: function(event) {
                var northwest = EventHandler.screenToSVG(0, 0);
                var southeast = EventHandler.screenToSVG(window.innerWidth, window.innerHeight);
                SVG.viewBox.baseVal.x = northwest.x;
                SVG.viewBox.baseVal.y = northwest.y;
                SVG.viewBox.baseVal.width = southeast.x - northwest.x;
                SVG.viewBox.baseVal.height = southeast.y - northwest.y;
            },
            screenToSVG: function(x, y) {
                var screenPoint = SVG.createSVGPoint();
                screenPoint.x = x;
                screenPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return screenPoint.matrixTransform( matrix.inverse() );
            },
            svgToScreen: function(x, y) {
                var svgPoint = SVG.createSVGPoint();
                svgPoint.x = x;
                svgPoint.y = y;
                var matrix = SVG.getScreenCTM();
                return svgPoint.matrixTransform( matrix );
            },
            screenToMiniature: function(x, y) {
                var screenPoint = NAV.createSVGPoint();
                screenPoint.x = x;
                screenPoint.y = y;
                var matrix = NAV.getScreenCTM();
                return screenPoint.matrixTransform( matrix.inverse() );
            },
            miniatureToScreen: function(x, y) {
                var svgPoint = NAV.createSVGPoint();
                svgPoint.x = x;
                svgPoint.y = y;
                var matrix = NAV.getScreenCTM();
                return svgPoint.matrixTransform( matrix );
            },
            prepareNavigation: function(event) {
                event.preventDefault();
                if(!EventHandler.hasOngoingInteractions()) {
                    EventHandler.setInteraction("prepareNavigation");
                    var miniature = document.getElementById("miniature");
                    var miniatureWidth = miniature.offsetWidth;
                    var miniatureHeight = miniature.offsetHeight;
                    var viewBoxWidth = NAV.viewBox.baseVal.width || miniatureWidth;
                    var viewBoxHeight = NAV.viewBox.baseVal.height || miniatureHeight;
                    EventHandler.scaleX = viewBoxWidth / miniatureWidth;
                    EventHandler.scaleY = viewBoxHeight / miniatureHeight;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                    // move to the clicked point
                    var svgPoint = EventHandler.screenToMiniature(event.clientX, event.clientY);
                    Actions.centerModelAt(svgPoint.x, svgPoint.y);
                    NAV.addEventListener('mousemove', EventHandler.whileNavigating, false);
                    NAV.addEventListener('mouseup', EventHandler.completeNavigation, false);
                    SVG.addEventListener('mouseover', EventHandler.completeNavigation, false);
                    DrawingEngine.setCursor('move');
                }
                event.stopPropagation();
            },
            whileNavigating: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileNavigating" ||
                        EventHandler.getInteraction() === "prepareNavigation") {
                    EventHandler.setInteraction("whileNavigating");
                    SVG.viewBox.baseVal.x += (event.clientX - EventHandler.lastX) * EventHandler.scaleX;
                    SVG.viewBox.baseVal.y += (event.clientY - EventHandler.lastY) * EventHandler.scaleY;
                    EventHandler.lastX = event.clientX;
                    EventHandler.lastY = event.clientY;
                }
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
                event.stopPropagation();
            },
            completeNavigation: function(event) {
                event.preventDefault();
                if(EventHandler.getInteraction() === "whileNavigating" ||
                        EventHandler.getInteraction() === "prepareNavigation") {
                    EventHandler.setInteraction("completeNavigation");
                    EventHandler.clearInteraction();
                    NAV.removeEventListener('mousemove', EventHandler.whileNavigating, false);
                    NAV.removeEventListener('mouseup', EventHandler.completeNavigation, false);
                    SVG.removeEventListener('mouseover', EventHandler.completeNavigation, false);
                    DrawingEngine.setCursor('default');
                }
                event.stopPropagation();
            },
            reduce: function(array, fromArray) {
                var i = array.length, reduced = [];
                while(i--) {
                    if(fromArray.indexOf(array[i]) < 0) {
                        reduced.push(array[i]);
                    }
                }
                return reduced;
            },
            keypress: function(event) {
                event.preventDefault();
                var allComponents = EventHandler.selectedComponents.concat(
                        EventHandler.reduce(
                                EventHandler.interactedComponents,
                                EventHandler.selectedComponents
                        ));
                var component = EventHandler.interactedComponents.pop();
                var selectedRoute = EventHandler.selectedRoute;
                switch(String.fromCharCode(event.charCode || event.which)) {
                    case "e":
                        component.showContextMenu(component, allComponents, selectedRoute);
                        component.contextMenu.toggle();
                        break;
                    case "E":
                        new TabularEditor(component.descriptor);
                        break;
                    case "a":
                        if(Operations.isSupported("addAttribute", allComponents))
                            Model.addAttribute(allComponents);
                        else if(Operations.isSupported("addAnchor", allComponents))
                            Model.addAnchor(allComponents);
                        break;
                    case "t":
                        if(Operations.isSupported("addTie", allComponents) && allComponents.length > 1)
                            Model.addTie(allComponents);
                        else if(Operations.isSupported("addTieAndAnchor", allComponents))
                            Model.addTieAndAnchor(allComponents);
                        break;
                    case "c":
                        if(Operations.isSupported("connect", allComponents)) {
                            var i, operation, validator;
                            for(i = 0; operation = Operations.list[i]; i++)
                                if(operation[0] == "connect")
                                    validator = operation[3];
                            if(validator(allComponents))
                                Model.connect(allComponents);
                        }
                        break;
                    case "h":
                        if(Operations.isSupported("toggleHistorized", allComponents))
                            Model.toggleHistorized(allComponents);
                        break;
                    case "k":
                        if(Operations.isSupported("toggleKnotted", allComponents))
                            Model.toggleKnotted(allComponents);
                        else if(Operations.isSupported("addKnot", allComponents))
                            Model.addKnot(allComponents);
                        break;
                    case "i":
                        if(Operations.isSupported("toggleIdentifier", allComponents))
                            Model.toggleIdentifier(allComponents);
                        break;
                    case "f":
                        if(Operations.isSupported("makeFirstRole", allComponents))
                            Model.makeFirstRole(allComponents);
                        break;
                    case "x":
                        if(Operations.isSupported("explode", allComponents))
                            Model.explode(allComponents);
                        break;
                    case "d":
                        if(Operations.isSupported("erase", allComponents))
                            Model.erase(allComponents);
                        break;
                    case "p":
                        component.setFixed(!component.fixed);
                        DrawingEngine.start(false);
                        break;
                }
                EventHandler.interactedComponents.push(component);
                event.stopPropagation();
            }
        };

        function Symbol(component) {
            this.component = component;
        }
        Symbol.prototype = {
            component: null,
            interactive: null,
            graphicsElement: null,
            useElement: null,
            boundingBox: null,
            xOffset: null,
            yOffset: null,
            control: null,
            nameElement: null,
            nameText: null,
            nameControl: null,
            highlightElement: null,
            selectionElement: null,
            fixationElement: null,
            pathElement: null,
            pathControl: null,
            forceElement: null,
            makeInteractive: function() {
                this.highlightElement = document.createElementNS(SVGNS, 'use');
                this.highlightElement.setAttributeNS(XLINKNS, 'xlink:href', '#highlight');
                this.highlightElement.component = this.component;
                this.selectionElement = document.createElementNS(SVGNS, 'use');
                this.selectionElement.setAttributeNS(XLINKNS, 'xlink:href', '#selection');
                this.selectionElement.component = this.component;
                this.fixationElement = document.createElementNS(SVGNS, 'use');
                this.fixationElement.setAttributeNS(XLINKNS, 'xlink:href', '#fixation');
            },
            hideDebug: function(imageLayer) {
                if(this.forceElement && imageLayer.contains(this.forceElement))
                    imageLayer.removeChild(this.forceElement);
            },
            showDebug: function(imageLayer) {
                this.forceElement = document.createElementNS(SVGNS, 'line');
                this.forceElement.setAttributeNS(null, 'marker-end', 'url(#arrowhead)');
                if(!imageLayer.contains(this.forceElement))
                    imageLayer.appendChild(this.forceElement);
            },
            hideGraphics: function(imageLayer) {
                if(this.graphicsElement && imageLayer.contains(this.graphicsElement))
                    imageLayer.removeChild(this.graphicsElement);
            },
            showGraphics: function(imageLayer) {
                if(this.graphicsElement && !imageLayer.contains(this.graphicsElement))
                    imageLayer.appendChild(this.graphicsElement);
            },
            hidePath: function(imageLayer) {
                if(this.pathElement && imageLayer.contains(this.pathElement))
                    imageLayer.removeChild(this.pathElement);
            },
            showPath: function(imageLayer) {
                if(this.pathElement && !imageLayer.contains(this.pathElement))
                    imageLayer.appendChild(this.pathElement);
            },
            hideName: function(imageLayer) {
                if(this.nameElement && imageLayer.contains(this.nameElement))
                    imageLayer.removeChild(this.nameElement);
            },
            showName: function(imageLayer) {
                if(this.nameElement && !imageLayer.contains(this.nameElement))
                    imageLayer.appendChild(this.nameElement);
            }
        };

        // "Abstract" type that other components subclass
        function Component(node) {
            this.node = node;
            this.editables = [];
            this.operations = ['erase', 'connect'];
            this.svg = new Symbol(this);
            this.svg.makeInteractive();
            this.nav = new Symbol(this);
            this.postfixes = [];
        }
        Component.prototype = {
            node: null,
            description: '',
            editables: null,
            operations: null,
            id: null,
            incomplete: true,
            svg: null,
            nav: null,
            nameable: false,
            highlighted: false,
            selected: false,
            lastName: null,
            imploded: false,
            visible: false,
            postfixes: null,
            // can be overridden by subclasses
            hide: function() {
                this.visible = false;
                // stop any ongoing interactions
                EventHandler.endInteraction();
                // do not display in layers
                this.svg.hideGraphics(SVGLayer.nodes);
                this.nav.hideGraphics(NAVLayer.nodes);
                this.svg.hidePath(SVGLayer.edges);
                this.nav.hidePath(NAVLayer.edges);
                this.svg.hideName(SVGLayer.names);
                this.svg.hideDebug(SVGLayer.debug);
            },
            show: function() {
                this.svg.showGraphics(SVGLayer.nodes);
                this.nav.showGraphics(NAVLayer.nodes);
                this.svg.showPath(SVGLayer.edges);
                this.nav.showPath(NAVLayer.edges);
                this.svg.showName(SVGLayer.names);
                this.svg.showDebug(SVGLayer.debug);
                this.visible = true;
            },
            postCreationInitialization: function() {
                this.editables.push(Editables.descriptionEdit);
                this.show();
            },
            setId: function(id)  {
                if(id) {
                    UniqueIdentity.takeId(id);
                    this.id = id;
                }
            },
            getId: function() {
                if (!this.id)
                    this.id = UniqueIdentity.nextId();
                return this.id;
            },
            setNameable: function(nameable) {
                if(nameable && !this.svg.nameElement) {
                    this.svg.nameElement = document.createElementNS(SVGNS, 'text');
                    this.svg.nameElement.setAttributeNS(null, 'x', '0');
                    this.svg.nameElement.setAttributeNS(null, 'y', '0');
                    this.svg.nameText = document.createTextNode('');
                    this.svg.nameElement.appendChild(this.svg.nameText);
                    SVGLayer.names.appendChild(this.svg.nameElement);
                    this.svg.nameControl = {
                        x: this.svg.nameElement.x.baseVal.getItem(0),
                        y: this.svg.nameElement.y.baseVal.getItem(0)
                    };
                }
                this.nameable = nameable;
            },
            updateName: function() {
                if(this.nameable) {
                    var name = this.contextualName();
                    if(!name || this.isEmpty(name)) {
                        this.svg.hideName(SVGLayer.names);
                        this.lastName = null;
                    }
                    else if(name !== this.lastName) {
                        if(!this.lastName) this.svg.showName(SVGLayer.names);
                        this.lastName = name;
                        this.svg.nameText.nodeValue = name;
                    }
                }
            },
            tabularEdit: function(element, component) {
                if(element && component) {
                    element.editable.setMember(element, component);
                    element.checkValidity();
                }
            },            
            tabular: function (container) {
                var self = this;
                var j, i = 0, editable;
                var table = document.createElement('table');
                while(editable = this.editables[i++]) {
                    var element = document.createElement(editable.type);
                    element.className = 'tabularEditable';
                    if(editable.pattern) {
                        element.setAttribute('pattern', editable.pattern);
                    }
                    if(editable.attributes) {
                        for(j = 0; j < editable.attributes.length;) {
                            var attribute = editable.attributes[j++];
                            var value = editable.attributes[j++];
                            element.setAttribute(attribute, value);
                        }
                    }
                    if(editable.elements) {
                        for(j = 0; j < editable.elements.length;) {
                            var subElement = editable.elements[j++];
                            element.appendChild(subElement.cloneNode(true));
                        }
                    }
                    editable.setElement(element, self);
                    element.setAttribute('valign', 'top');
                    element.setAttribute('title', editable.description);                
                    element.editable = editable;
                    // edit function should move into the component?
                    element.addEventListener(editable.event, function() { 
                        self.tabularEdit(this, self); 
                        container.label.nodeValue = self.toString();
                    }, false);
                    element.addEventListener('change', function() { 
                        self.editsHaveBeenMade = true; 
                    }, false);
                    var row = document.createElement('tr');
                    var label = document.createTextNode(editable.name + ":");
                    var labelCell = document.createElement('td');
                    labelCell.appendChild(label);
                    row.appendChild(labelCell);
                    var elementCell = document.createElement('td');
                    elementCell.appendChild(element);
                    row.appendChild(elementCell);                    
                    table.appendChild(row);
                }
                container.appendChild(table);
                return true;
            },
            // override to change behavior
            isInteractive: function() {
                return false;
            },
            isDraggable: function() {
                return false;
            },
            // this should always return the name according to the naming conventions
            toString: function() {
                return null;
            },
            // this should return the name depending on the visual context
            contextualName: function() {
                return this.toString();
            },
            isEmpty: function(value) {
                return typeof value === "undefined" || value == null ||
                        value.toString().replace(/^[^\S]+/,'').replace(/[^\S]+$/,'') === '';
            },
            updateIncompleteness: function() {
                this.incomplete = false;
                var editable;
                for(var i = 0; editable = this.editables[i]; i++) {
                    // only those that are supposed to contain text (i.e. not checkboxes, select lists, ...)
                    // and is not switched off from editing
                    if(editable.pattern && editable.editable) {
                        if(this.isEmpty(editable.getMember(this)))
                            this.incomplete =  true;
                        if(!editable.getMember(this).toString().match(new RegExp('^' + editable.pattern + '$')))
                            this.incomplete =  true;
                    }
                }
            },
            // override in order to check conditions under which the node breaks the model
            isConforming: function() {
                return true;
            },
            // subclasses that should appear in the XML need to override this
            toXML: function() {
                return null;
            },
            toSVG: function() {
                return null;
            },
            fromXML: function() {
                return;
            },
            addDescriptionXML: function(element, schema, description) {
                if(!this.isEmpty(description)) {
                    var descriptionElement = schema.createElement("description");
                    descriptionElement.innerHTML = description;
                    element.appendChild(descriptionElement);
                }
            },
            addLayoutXML: function(element, schema) {
                var node = this.node;
                var layout = schema.createElement("layout");
                layout.setAttribute("x", node.xPosition.toFixed(2));
                layout.setAttribute("y", node.yPosition.toFixed(2));
                layout.setAttribute("fixed", node.fixed);
                if(this.imploded)
                    layout.setAttribute("imploded", this.imploded.toString());
                element.appendChild(layout);
            },
            bad: false,
            end: false,
            drawName: function(x, y) {
                var svg = this.svg;
                if(this.visible && svg.nameElement) {
                    var node = this.node;
                    this.updateName();
                    var i, xAverage = 0, closestEdge = node.edges[0] || node;
                    i = node.edges.length;
                    while(i--) {
                        xAverage += node.edges[i].xPosition;
                        if(LayoutEngine.manhattanDistance(node, node.edges[i]) <
                                LayoutEngine.manhattanDistance(node, closestEdge)) {
                            closestEdge = node.edges[i];
                        }
                    }
                    xAverage /= node.edges.length;
                    var quarter = svg.yOffset + svg.boundingBox.height / 4;
                    var nameYOffset = svg.yPosition < closestEdge.yPosition ? -quarter : quarter;
                    var nameXOffset = svg.xOffset + svg.boundingBox.width / 2;
                    if(node.xPosition < xAverage) {
                        if(!this.end) {
                            svg.nameElement.classList.add('end');
                        }
                        nameXOffset = -nameXOffset;
                        this.end = true;
                    }
                    else {
                        if(this.end) {
                            svg.nameElement.classList.remove('end');
                        }
                        this.end = false;
                    }
                    if(this.incomplete) {
                        if(!this.bad) {
                            svg.nameElement.classList.add('bad');
                        }
                        this.bad = true;
                    }
                    else {
                        if(this.bad) {
                            svg.nameElement.classList.remove('bad');
                        }
                        this.bad = false;
                    }
                    svg.nameControl.x.value = x + nameXOffset;
                    svg.nameControl.y.value = y + nameYOffset;
                }
            },
            // this is how a node draws itself on the visible context, should be overridden by subclasses
            draw: function(image) {
                return;
            },
            drawForce: function(image) {
                var node = this.node;
                var element = image.forceElement;
                // draw forces
                element.x1.baseVal.value = node.xPosition;
                element.y1.baseVal.value = node.yPosition;
                // exaggerate the velocity so that forces become visible
                var e = 10*Math.log(1 + 10/(1 + node.velocity));
                element.x2.baseVal.value = node.xPosition + node.xVelocity *e;
                element.y2.baseVal.value = node.yPosition + node.yVelocity *e;
            },
            setFixed: function(fixed) {
                this.node.fixed = fixed;
                if(fixed && !this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.appendChild(this.svg.fixationElement);
                }
                else if (!fixed && this.svg.graphicsElement.contains(this.svg.fixationElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.fixationElement);
                }
            },
            getFixed: function() {
                return this.node.fixed;
            },
            setSelection: function(select) {
                this.selected = select;
                if(select && this.visible && !this.svg.graphicsElement.contains(this.svg.selectionElement)) {
                    this.svg.selectionElement.addEventListener('click', EventHandler.clickSelection, false);
                    this.svg.graphicsElement.insertBefore(
                            this.svg.selectionElement,
                            this.svg.graphicsElement.firstChild
                    );
                }
                else if (!select && this.visible && this.svg.graphicsElement.contains(this.svg.selectionElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.selectionElement);
                    this.svg.selectionElement.removeEventListener('click', EventHandler.clickSelection, false);
                }
            },
            setHighlight: function(highlight) {
                this.highlighted = highlight;
                if(highlight && this.visible && !this.svg.graphicsElement.contains(this.svg.highlightElement)) {
                    this.svg.highlightElement.addEventListener('click', EventHandler.clickHighlight, false);
                    this.svg.graphicsElement.insertBefore(
                            this.svg.highlightElement,
                            this.svg.graphicsElement.firstChild
                    );
                    if(!SVGLayer.isShowing('names')) {
                        this.svg.hideName(SVGLayer.names);
                        this.drawName(0, 0);
                        this.svg.showName(this.svg.graphicsElement);
                    }
                }
                else if (!highlight && this.visible && this.svg.graphicsElement.contains(this.svg.highlightElement)) {
                    this.svg.graphicsElement.removeChild(this.svg.highlightElement);
                    this.svg.highlightElement.removeEventListener('click', EventHandler.clickHighlight, false);
                    this.svg.hideName(this.svg.graphicsElement);
                    this.drawName(this.node.xPosition, this.node.yPosition);
                    this.svg.showName(SVGLayer.names);
                }
            },
            contextMenu: null,
            showContextMenu: function(hoveredComponent, selectedComponents, selectedRoute) {
                if(!this.contextMenu)
                    this.contextMenu = new ContextMenu(hoveredComponent, selectedComponents, selectedRoute);
            },
            hideContextMenu: function() {
                if(this.contextMenu) {
                    this.contextMenu.close();
                    this.contextMenu = null;
                }
            }
        };

        function Attribute(x, y, historized) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.ATTRIBUTE));
            // set members
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.keys = [];
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.positIdentityEdit);
            this.editables.push(Editables.positGeneratorEdit);
            this.editables.push(Editables.assertivenessEdit);
            this.editables.push(Editables.checksumEdit);
            this.editables.push(Editables.deletabilityEdit);
            this.editables.push(Editables.idempotencyEdit);
            this.editables.push(Editables.encryptionGroupEdit);
            this.editables.push(Editables.equivalenceEdit);
            this.editables.push(Editables.privacyEdit);
            this.knotted = false;
            this.historized = historized;
            this.deletable = Defaults.deletability === 'true';
            this.restatable = Defaults.restatability === 'true';
            this.idempotent = Defaults.idempotency === 'true';
            this.assertive = Defaults.assertiveness === 'true';
            this.equivalent = Defaults.equivalence === 'true';
            this.checksum = Defaults.checksum === 'true';
            this.encryptionGroup = Defaults.encryptionGroup;
            this.encapsulation = Defaults.encapsulation;
            this.privacy = Defaults.privacy;
            this.positIdentity = Defaults.positIdentity;
            this.positGenerator = Defaults.positGenerator === 'true';
            this.operations.push('toggleKnotted','toggleHistorized', 'addToKey', 'removeFromKey', 'createKey');
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            // expando property as a reference back to the underlying component for use in event handlers
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#attribute_historized' : '#attribute';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.svg.control.setTranslate(x, y);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 5;
            this.svg.yOffset = 2;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.appendItem(
                this.nav.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.nav.control.setTranslate(x, y);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Attribute.prototype = {
            mnemonic: '',
            descriptor: '',
            dataRange: '',
            changingRange: '',
            positIdentity: '',
            positGenerator: true,
            historized: false,
            deletable: false,
            restatable: true,
            idempotent: false,
            assertive: true,
            equivalent: false,
            checksum: false,
            encryptionGroup: Defaults.encryptionGroup,
            knotted: false,
            encapsulation: Defaults.encapsulation,
            privacy: Defaults.privacy,
            keys: null,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            isConforming: function() {
                var i, edge, anchor, otherNode, otherComponent;
                // first find the anchor
                for(i = 0; edge = this.node.edges[i]; i++) {
                    otherNode = (edge.node === this.node ? edge.otherNode : edge.node);
                    if(otherNode.type === NodeType.ANCHOR) {
                        anchor = Model.nodeToComponent(otherNode);
                        break;
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; edge = anchor.node.edges[i]; i++) {
                    otherNode = (edge.node === anchor.node ? edge.otherNode : edge.node);
                    otherComponent = Model.nodeToComponent(otherNode);
                    if(otherNode.type === NodeType.ATTRIBUTE && otherNode !== this.node && otherComponent.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other attributes on the '" + anchor +
                                "' anchor. Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) 
                    this.editables.push(Editables.restatabilityEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                if(this.changingRange === '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#attribute_historized' : '#attribute';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                var index = this.editables.indexOf(Editables.dataRangeEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.dataRangeEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.checksumEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.checksumEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.encryptionGroupEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.encryptionGroupEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);                
                index = this.editables.indexOf(Editables.equivalenceEdit);
                if(!knotted && index < 0)
                    this.editables.push(Editables.equivalenceEdit);
                else if (knotted && index >= 0)
                    this.editables.splice(index, 1);
                if(this.encryptionGroup > 0 && knotted)
                    this.encryptionGroup = ''; // knotted cannot be encrypted
                if(this.checksum && knotted)
                    this.checksum = false; // knotted cannot be checksummed
                if(this.equivalent && knotted)
                    this.equivalent = false; // knotted cannot be equivalent
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata;
                var privacy = Defaults.privacy;
                var capsule = Defaults.encapsulation;
                var encryptionGroup = Defaults.encryptionGroup;
                var deletable = Defaults.deletability === 'true';
                var restatable = Defaults.restatability === 'true';
                var idempotent = Defaults.idempotency === 'true';
                var assertive = Defaults.assertiveness === 'true';
                var equivalent = Defaults.equivalence === 'true';
                var checksum = Defaults.checksum === 'true';
                var generator = Defaults.positGenerator === 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    privacy = metadata.getAttribute("privacy") || privacy;
                    capsule = metadata.getAttribute("capsule") || capsule;
                    encryptionGroup = metadata.getAttribute("encryptionGroup") || encryptionGroup;
                    var _deletable = metadata.getAttribute("deletable");
                    deletable = _deletable ? _deletable === 'true' : deletable;
                    var _restatable = metadata.getAttribute("restatable") || metadata.getAttribute("restatements");
                    restatable = _restatable ? _restatable === 'true' : restatable;
                    var _idempotent = metadata.getAttribute("idempotent");
                    idempotent = _idempotent ? _idempotent === 'true' : idempotent;
                    var _checksum = metadata.getAttribute("checksum");
                    checksum = _checksum ? _checksum === 'true' : checksum;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _assertive = metadata.getAttribute("assertive");
                    assertive = _assertive ? _assertive === 'true' : assertive;
                    var _equivalent = metadata.getAttribute("equivalent");
                    equivalent = _equivalent ? _equivalent === 'true' : equivalent;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || '???';
                var descriptor = element.getAttribute("descriptor") || '!Unnamed!';
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var knotRange = element.getAttribute("knotRange") || '';
                var knotted = knotRange ? true : false;
                var dataRange = element.getAttribute("dataRange") || '';
                var parent = element.parentNode;
                var identity = element.getAttribute("identity") || Defaults.positIdentity;
                var attribute = new Attribute(x, y, historized);
                // WIP: keys
                for(i = 0; i < element.childNodes.length; i++) {
                    if(element.childNodes.item(i).nodeName === 'key') {
                        var key = element.childNodes.item(i);
                        attribute.keys.push({
                            stop: key.getAttribute("stop") || '1',
                            route: key.getAttribute("route"),
                            of: key.getAttribute("of"),
                            branch: key.getAttribute("branch") || '1'
                        });
                    }
                }
                attribute.setFixed(fixed);
                attribute.setKnotted(knotted);
                attribute.setHistorized(historized);
                attribute.changingRange = changingRange;
                attribute.dataRange = dataRange;
                attribute.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                attribute.mnemonic = mnemonic;
                attribute.descriptor = descriptor;
                attribute.privacy = privacy;
                attribute.encapsulation = capsule;
                attribute.deletable = deletable;
                attribute.restatable = restatable;
                attribute.idempotent = idempotent;
                attribute.assertive = assertive;
                attribute.equivalent = equivalent;
                attribute.checksum = checksum;
                attribute.encryptionGroup = encryptionGroup;
                attribute.positIdentity = identity;
                attribute.positGenerator = generator;
                var anchorLookup = Model.getAnchorLookup();
                var knotLookup = Model.getKnotLookup();
                var anchor = anchorLookup[parent.getAttribute("mnemonic")];
                Model.addComponent(new Role(attribute, anchor, true));
                if(knotted) {
                    var grandparent = parent.parentNode;
                    var knots = grandparent.getElementsByTagName("knot");
                    for(i = 0; i < knots.length; i++) {
                        if(knots[i].getAttribute("mnemonic") === knotRange) {
                            var knot = knotLookup[knots[i].getAttribute("mnemonic")];
                            Model.addComponent(new Role(attribute, knot, false));
                            break; // only one should match
                        }
                    }
                }
                attribute.updateName();
                return attribute;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var attribute = schema.createElement("attribute");
                // set attributes on the element
                attribute.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                attribute.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi')
                    attribute.setAttribute("identity", this.isEmpty(this.positIdentity) ? '' : this.positIdentity);
                if(this.historized)
                    attribute.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);
                if(this.knotted) {
                    var knot, edge;
                    for(var i = 0; edge = this.node.edges[i]; i++)
                        if(edge.otherNode.type === NodeType.KNOT)
                            knot = Model.nodeToComponent(edge.otherNode);
                    attribute.setAttribute("knotRange", this.isEmpty(knot.mnemonic) ? '' : knot.mnemonic);
                }
                else {
                    attribute.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);
                }
                var metadata = schema.createElement("metadata");
                metadata.setAttribute("privacy", this.isEmpty(this.privacy) ?
                        Defaults.privacy : this.privacy);
                if(!this.isEmpty(this.encryptionGroup)) {
                    metadata.setAttribute("encryptionGroup", this.encryptionGroup);
                }
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                if(Defaults.equivalence === 'true') {
                    metadata.setAttribute("equivalent", this.isEmpty(this.equivalent) ? '' : this.equivalent);
                }
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi') {
                    metadata.setAttribute("generator", this.isEmpty(this.positGenerator) ? '' : this.positGenerator);
                    metadata.setAttribute("assertive", this.isEmpty(this.assertive) ? '' : this.assertive);
                }
                if(this.checksum) {
                    metadata.setAttribute("checksum", this.isEmpty(this.checksum) ?
                            false : this.checksum);
                }
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability === 'true' : this.restatable);
                }
                metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                        Defaults.idempotency === 'true' : this.idempotent);                
                metadata.setAttribute("deletable", this.isEmpty(this.deletable) ?
                        Defaults.deletability === 'true' : this.deletable);                
                attribute.appendChild(metadata);
                // WIP: keys
                if(this.keys && this.keys.length > 0) {
                    for(var i = 0; i < this.keys.length; i++) {
                        var key = schema.createElement("key");
                        key.setAttribute("stop", this.keys[i].stop);
                        key.setAttribute("route", this.keys[i].route);
                        key.setAttribute("of", this.keys[i].of);
                        key.setAttribute("branch", this.keys[i].branch);
                        attribute.appendChild(key);
                    }
                }
                this.addLayoutXML(attribute, schema);
                this.addDescriptionXML(attribute, schema, this.description);
                element.appendChild(attribute);
            },
            contextualName: function() {
                var name = '';
                if(Settings.showMnemonics)
                    name += this.toString();
                else
                    name += this.descriptor;
                if(this.historized && (this.restatable || this.idempotent)) {
                    name += ' (';
                    if(this.restatable)
                        name += 'r';
                    if(this.idempotent)
                        name += 'i';
                    if(this.deletable)
                        name += 'd';
                    if((Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi') && this.assertive)
                        name += 'a';
                    name += ')';
                }
                if(this.postfixes.length > 0) 
                    name += ' [' + this.postfixes.join(', ') + ']'; 
                return name;
            },
            toString: function() {
                var anchor, edge;
                for(var i = 0; edge = this.node.edges[i]; i++)
                    if(edge.otherNode.type === NodeType.ANCHOR)
                        anchor = Model.nodeToComponent(edge.otherNode);
                return anchor.mnemonic + "_" + this.mnemonic + "_" + anchor.descriptor + "_" + this.descriptor;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
            }
        };

        // inheritance
        extend(Attribute, Component);

        function Identifier(x, y, anchor, route) {
            this.anchor = anchor;
            this.route = Model.routes[anchor.mnemonic + '|' + route];
            if (!this.route) {
                console.error("There is no route named: " + route + " on the anchor: " + anchor.descriptor);
                return; // error here
            }
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.IDENTIFIER));
            // set members
            this.editables.push(Editables.keySelectEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.positIdentityEdit);
            this.editables.push(Editables.positGeneratorEdit);
            this.editables.push(Editables.assertivenessEdit);
            this.editables.push(Editables.checksumEdit);
            this.editables.push(Editables.privacyEdit);
            this.historized = false;
            for(var stop in this.route.stops) {
                var component = this.route.stops[stop].component;
                if (component.node.type == NodeType.ATTRIBUTE && component.historized == true) {
                    this.historized = true;
                    this.changingRange = component.changingRange;
                    break;
                }
                // do we want to historized if is passes through a historized tie?
                /*
                if (component.node.type == NodeType.EDGE && component.component.historized == true) {
                    this.historized = true;
                    this.changingRange = component.component.changingRange;
                    break;
                }
                */
            }
            this.assertive = Defaults.assertiveness === 'true';
            this.checksum = Defaults.checksum === 'true';
            this.encapsulation = Defaults.encapsulation;
            this.privacy = Defaults.privacy;
            this.positIdentity = Defaults.positIdentity;
            this.positGenerator = Defaults.positGenerator === 'true';
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            // expando property as a reference back to the underlying component for use in event handlers
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = this.historized ? '#identifier_historized' : '#identifier';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.svg.control.setTranslate(x, y);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 5;
            this.svg.yOffset = 2;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.appendItem(
                this.nav.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.nav.control.setTranslate(x, y);
            this.setHistorized(this.historized);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Identifier.prototype = {
            changingRange: '',
            positIdentity: '',
            positGenerator: true,
            historized: false,
            assertive: true,
            checksum: false,
            encapsulation: Defaults.encapsulation,
            privacy: Defaults.privacy,
            route: null,
            anchor: null,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            isConforming: function() {
                var i, edge, anchor, otherNode, otherComponent;
                // first find the anchor
                for(i = 0; edge = this.node.edges[i]; i++) {
                    otherNode = (edge.node === this.node ? edge.otherNode : edge.node);
                    if(otherNode.type === NodeType.ANCHOR) {
                        anchor = Model.nodeToComponent(otherNode);
                        break;
                    }
                }
                // probably check that key exists
                return true;
            },
            prepareEditing: function(editable) {
                editable.elements.length = 0;
                for (var r in Model.routes) {
                    if (r.slice(0, 2) == this.anchor.mnemonic) {
                        editable.elements.push(createOption(r, Model.routes[r].name));
                    }
                }
            },
            setRoute: function(qualifiedRoute) {
                this.route = Model.routes[qualifiedRoute];
            },
            getRoute: function() {
                return this.anchor.mnemonic + '|' + this.route.name;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) 
                    this.editables.push(Editables.restatabilityEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                if(this.changingRange === '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#identifier_historized' : '#identifier';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata;
                var privacy = Defaults.privacy;
                var capsule = Defaults.encapsulation;
                var encryptionGroup = Defaults.encryptionGroup;
                var assertive = Defaults.assertiveness === 'true';
                var checksum = Defaults.checksum === 'true';
                var generator = Defaults.positGenerator === 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    privacy = metadata.getAttribute("privacy") || privacy;
                    capsule = metadata.getAttribute("capsule") || capsule;
                    encryptionGroup = metadata.getAttribute("encryptionGroup") || encryptionGroup;
                    var _checksum = metadata.getAttribute("checksum");
                    checksum = _checksum ? _checksum === 'true' : checksum;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _assertive = metadata.getAttribute("assertive");
                    assertive = _assertive ? _assertive === 'true' : assertive;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var route = element.getAttribute("route");
                var changingRange = element.getAttribute("timeRange");
                var parent = element.parentNode;
                var anchorLookup = Model.getAnchorLookup();
                var anchor = anchorLookup[parent.getAttribute("mnemonic")];
                var identity = element.getAttribute("identity") || Defaults.positIdentity;
                var identifier = new Identifier(x, y, anchor, route);
                identifier.setFixed(fixed);
                identifier.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                identifier.privacy = privacy;
                identifier.encapsulation = capsule;
                identifier.assertive = assertive;
                identifier.checksum = checksum;
                identifier.encryptionGroup = encryptionGroup;
                identifier.positIdentity = identity;
                identifier.positGenerator = generator;
                if(changingRange) identifier.changingRange = changingRange;
                Model.addComponent(new Role(identifier, anchor, true));
                identifier.updateName();
                return identifier;
            },
            addXML: function(element, schema) {
                // create an attribute element
                var identifer = schema.createElement("identifer");
                identifer.setAttribute("route", this.route.name);
                if(this.historized)
                    identifer.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);                
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi')
                    identifer.setAttribute("identity", this.isEmpty(this.positIdentity) ? '' : this.positIdentity);
                var metadata = schema.createElement("metadata");
                metadata.setAttribute("privacy", this.isEmpty(this.privacy) ?
                        Defaults.privacy : this.privacy);
                if(!this.isEmpty(this.encryptionGroup)) {
                    metadata.setAttribute("encryptionGroup", this.encryptionGroup);
                }
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi') {
                    metadata.setAttribute("generator", this.isEmpty(this.positGenerator) ? '' : this.positGenerator);
                    metadata.setAttribute("assertive", this.isEmpty(this.assertive) ? '' : this.assertive);
                }
                if(this.checksum) {
                    metadata.setAttribute("checksum", this.isEmpty(this.checksum) ?
                            false : this.checksum);
                }
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability === 'true' : this.restatable);
                }
                identifer.appendChild(metadata);
                this.addLayoutXML(identifer, schema);
                this.addDescriptionXML(identifer, schema, this.description);
                element.appendChild(identifer);
            },
            contextualName: function() {
                var name = '';
                if(Settings.showMnemonics)
                    name += this.toString();
                else
                    name += this.route.name;
                if(this.postfixes.length > 0) 
                    name += ' [' + this.postfixes.join(', ') + ']'; 
                return name;
            },
            toString: function() {
                var anchor, edge;
                for(var i = 0; edge = this.node.edges[i]; i++)
                    if(edge.otherNode.type === NodeType.ANCHOR)
                        anchor = Model.nodeToComponent(edge.otherNode);
                return anchor.mnemonic + "_" + anchor.descriptor + "_" + this.route.name;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
            }
        };

        // inheritance
        extend(Identifier, Component);



        function Anchor(x, y) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.ANCHOR));
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.twoMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.encapsulation = Defaults.encapsulation;
            this.identity = Defaults.identity;
            this.operations.push('addAttribute','addTie','addTieAndAnchor','explode', 'addToKey', 'createKey');
            // set up SVG graphics
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.svg.control.setTranslate(x, y);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // set up NAV graphics
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#nav_anchor');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.appendItem(
                this.nav.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.nav.control.setTranslate(x, y);
            this.setNameable(true);
            this.svg.nameElement.setAttributeNS(null, 'class', 'anchor');
            this.postCreationInitialization();
        }
        Anchor.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: Defaults.identity,
            generator: true,
            encapsulation: Defaults.encapsulation,
            setImploded: function(imploded) {
                this.imploded = imploded;
                if(imploded) {
                    if(this.operations.indexOf('addAttribute') >= 0)
                        this.operations.splice(this.operations.indexOf('addAttribute'), 1);
                    this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor_imploded');
                }
                else {
                    this.operations.push('addAttribute');
                    this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#anchor');
                }
            },
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                if(this.imploded)
                    name = "(" + name + ")";
                if(this.postfixes.length > 0) 
                    name += ' [' + this.postfixes.join(', ') + ']'; 
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, component, anchor, anchors = [];
                // first find the anchors
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.ANCHOR) {
                        anchors.push(component);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; anchor = anchors[i]; i++) {
                    if(anchor !== this && anchor.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other anchors in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout, imploded;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                    imploded = layout.getAttribute("imploded");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                imploded = imploded ? imploded === 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = true;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    generator = metadata.getAttribute("generator") ?
                            metadata.getAttribute("generator") === 'true' : generator;
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") ?
                            idElement.getAttribute("generator") === 'true' : generator;
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "??";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var anchor = new Anchor(x, y);
                anchor.setFixed(fixed);
                anchor.setImploded(imploded);
                anchor.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                anchor.mnemonic = mnemonic;
                anchor.descriptor = descriptor;
                anchor.identity = identity;
                anchor.generator = generator;
                anchor.encapsulation = capsule;
                anchor.updateName();
                return anchor;
            },
            toXML: function(schema) {
                // create an anchor element
                var anchor = schema.createElement("anchor");
                // set attributes on the element
                anchor.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "??" : this.mnemonic);
                anchor.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                anchor.setAttribute("identity", this.isEmpty(this.identity) ? "" : this.identity);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                anchor.appendChild(metadata);

                var edge;
                for(var i = 0; edge = this.node.edges[i]; i++) {
                    if (edge.node.type === NodeType.ATTRIBUTE || edge.node.type === NodeType.IDENTIFIER) {
                        var role = Model.nodeToComponent(edge.node);
                        role.addXML(anchor, schema);
                    }
                }
                this.addLayoutXML(anchor, schema);
                this.addDescriptionXML(anchor, schema, this.description);
                return anchor;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
            }
        };

        // inheritance
        extend(Anchor, Component);

        function Knot(x, y) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.KNOT));
            this.mnemonic = '?' + this.getId();
            this.descriptor = '!Unnamed!';
            this.keys = [];
            this.editables.push(Editables.descriptorEdit);
            this.editables.push(Editables.threeMnemonicEdit);
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.dataRangeEdit);
            this.editables.push(Editables.identityEdit);
            this.editables.push(Editables.generatorEdit);
            this.editables.push(Editables.checksumEdit);
            this.editables.push(Editables.equivalenceEdit);
            this.encapsulation = Defaults.encapsulation;
            this.checksum = false;
            this.equivalent = Defaults.equivalence === 'true';
            this.operations.push('addToKey', 'removeFromKey', 'createKey');
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#knot');
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.svg.control.setTranslate(x, y);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 6;
            this.svg.yOffset = 0;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', '#nav_knot');
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.appendItem(
                this.nav.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.nav.control.setTranslate(x, y);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Knot.prototype = {
            mnemonic: '',
            descriptor: '',
            identity: '',
            dataRange: '',
            generator: false,
            checksum: false,
            equivalent: false,
            encapsulation: Defaults.encapsulation,
            keys: null,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics)
                    name = this.toString();
                else
                    name = this.descriptor;
                if(this.postfixes.length > 0) 
                    name += ' [' + this.postfixes.join(', ') + ']'; 
                return name;
            },
            toString: function() {
                return this.mnemonic + "_" + this.descriptor;
            },
            isConforming: function() {
                var i, component, knot, knots = [];
                // first find the knots
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.KNOT) {
                        knots.push(component);
                    }
                }
                // then check mnemonic uniqueness
                for(i = 0; knot = knots[i]; i++) {
                    if(knot !== this && knot.mnemonic === this.mnemonic) {
                        return !confirm("The mnemonic '" + this.mnemonic +
                                "' is not unique among other knots in the model. " +
                                "Please change to a different mnemonic in order to continue.");
                    }
                }
                return true;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata, capsule = Defaults.encapsulation, generator = false;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                var checksum = false;
                var equivalent = Defaults.equivalence === 'true';
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _checksum = metadata.getAttribute("checksum");
                    checksum = _checksum ? _checksum === 'true' : checksum;
                    var _equivalent = metadata.getAttribute("equivalent");
                    equivalent = _equivalent ? _equivalent === 'true' : equivalent;
                }
                // Begin - handling obsolete XML spec
                var idElement;
                if(idElement = element.getElementsByTagName('identity').item(0))
                    generator = idElement.getAttribute("generator") ?
                            idElement.getAttribute("generator") === 'true' : generator;
                // End - handling obsolete XML spec
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var mnemonic = element.getAttribute("mnemonic") || "???";
                var descriptor = element.getAttribute("descriptor") || "!Unnamed!";
                var identity = element.getAttribute("identity") || '';
                var dataRange = element.getAttribute("dataRange") || '';
                var knot = new Knot(x, y);
                // WIP: keys
                for(i = 0; i < element.childNodes.length; i++) {
                    if(element.childNodes.item(i).nodeName === 'key') {
                        var key = element.childNodes.item(i);
                        knot.keys.push({
                            stop: key.getAttribute("stop") || '1',
                            route: key.getAttribute("route"),
                            of: key.getAttribute("of"),
                            branch: key.getAttribute("branch") || '1'
                        });
                    }
                }
                knot.setFixed(fixed);
                knot.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                knot.mnemonic = mnemonic;
                knot.descriptor = descriptor;
                knot.identity = identity;
                knot.dataRange = dataRange;
                knot.generator = generator;
                knot.equivalent = equivalent;
                knot.encapsulation = capsule;
                knot.checksum = checksum;
                knot.updateName();
                return knot;
            },
            toXML: function(schema) {
                // create an anchor element
                var knot = schema.createElement("knot");
                // set attributes on the element
                knot.setAttribute("mnemonic", this.isEmpty(this.mnemonic) ? "???" : this.mnemonic);
                knot.setAttribute("descriptor", this.isEmpty(this.descriptor) ? "!Unnamed!" : this.descriptor);
                knot.setAttribute("identity", this.isEmpty(this.identity) ? '' : this.identity);
                knot.setAttribute("dataRange", this.isEmpty(this.dataRange) ? '' : this.dataRange);

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.isEmpty(this.encapsulation) ?
                        Defaults.encapsulation : this.encapsulation);
                metadata.setAttribute("generator", this.isEmpty(this.generator) ? false : this.generator);
                if(this.checksum) {
                    metadata.setAttribute("checksum", this.isEmpty(this.checksum) ?
                            false : this.checksum);
                }
                if(Defaults.equivalence === 'true') {
                    metadata.setAttribute("equivalent", this.isEmpty(this.equivalent) ? '' : this.equivalent);
                }
                knot.appendChild(metadata);
                // WIP: keys
                if(this.keys && this.keys.length > 0) {
                    for(var i = 0; i < this.keys.length; i++) {
                        var key = schema.createElement("key");
                        key.setAttribute("stop", this.keys[i].stop);
                        key.setAttribute("route", this.keys[i].route);
                        key.setAttribute("of", this.keys[i].of);
                        key.setAttribute("branch", this.keys[i].branch);
                        knot.appendChild(key);
                    }
                }
                this.addLayoutXML(knot, schema);
                this.addDescriptionXML(knot, schema, this.description);
                return knot;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
            }
        };

        // inheritance
        extend(Knot, Component);

        function Tie(x, y, historized) {
            this.id = UniqueIdentity.nextId();
            // call the parent constructor
            Component.call(this, new Node(this.id, x, y, NodeType.TIE));
            this.historized = historized;
            this.deletable = Defaults.deletability === 'true';
            this.restatable = Defaults.restatability === 'true';
            this.idempotent = Defaults.idempotency === 'true';
            this.assertive = Defaults.assertiveness === 'true';
            this.editables.push(Editables.encapsulationEdit);
            this.editables.push(Editables.positIdentityEdit);
            this.editables.push(Editables.positGeneratorEdit);
            this.editables.push(Editables.assertivenessEdit);
            this.editables.push(Editables.deletabilityEdit);
            this.editables.push(Editables.idempotencyEdit);
            this.positIdentity = Defaults.positIdentity;
            this.positGenerator = Defaults.positGenerator === 'true';
            this.operations.push('toggleHistorized','addKnot','addAnchor');
            this.encapsulation = Defaults.encapsulation;
            // SVG
            this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.svg.graphicsElement.component = this;
            this.svg.useElement = document.createElementNS(SVGNS, 'use');
            var ref = historized ? '#tie_historized' : '#tie';
            this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
            this.svg.graphicsElement.appendChild(this.svg.useElement);
            this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
            SVGLayer.nodes.appendChild(this.svg.graphicsElement);
            this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.svg.control.setTranslate(x, y);
            this.svg.boundingBox = this.svg.graphicsElement.getBBox();
            this.svg.xOffset = 2;
            this.svg.yOffset = 2;
            // NAV
            this.nav.graphicsElement = document.createElementNS(SVGNS, 'g');
            this.nav.graphicsElement.component = this;
            this.nav.useElement = document.createElementNS(SVGNS, 'use');
            this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
            this.nav.graphicsElement.appendChild(this.nav.useElement);
            NAVLayer.nodes.appendChild(this.nav.graphicsElement);
            this.nav.control = this.nav.graphicsElement.transform.baseVal.appendItem(
                this.nav.graphicsElement.ownerSVGElement.createSVGTransform()
            );
            this.nav.control.setTranslate(x, y);
            this.setNameable(true);
            this.postCreationInitialization();
        }
        Tie.prototype = {
            changingRange: Defaults.changingRange,
            historized: false,
            deletable: false,
            restatable: true,
            idempotent: false,
            assertive: true,
            positIdentity: '',
            positGenerator: true,
            encapsulation: Defaults.encapsulation,
            isInteractive: function() {
                return true;
            },
            isDraggable: function() {
                return true;
            },
            setFirstRole: function(role) {
                this.node.edges.splice(this.node.edges.indexOf(role.node), 1);
                this.node.edges.splice(0, 0, role.node);
            },
            checkIdentifiers: function() {
                if(this.historized) {
                    var outside = 0, inside = 0;
                    for(var i = 0; i < this.node.edges.length; i++) {
                        outside += Model.nodeToComponent(this.node.edges[i]).identifier ? 0 : 1;
                        inside += Model.nodeToComponent(this.node.edges[i]).identifier ? 1 : 0;
                    }
                    if(outside > 1)
                        alert("The tie " + this + " has " + outside +
                                " roles outside the identifier, which is not recommended for a historized tie. " +
                                "In order to determine what changes over time leaving exactly one role outside the " +
                                "identifier is recommended.");
                    else if (outside === 0 && inside > 0)
                        alert("The tie " + this +
                                " has no role outside the identifier, which is not recommended for a historized tie. " +
                                "If you want a many-to-many relationship then gaps in the timeline needs to be " +
                                "modeled explicitly using a knotted tie.");
                }
            },
            isConforming: function() {
                var edge, otherEdge, role, otherRole, component, otherComponent;
                var i, j, identical, relation, related;
                var relations = Object.create(null);
                // check that no roles are identical in the tie
                for(i = 0; edge = this.node.edges[i]; i++) {
                    for(j = 0; otherEdge = this.node.edges[j]; j++) {
                        role = Model.nodeToComponent(edge);
                        otherRole = Model.nodeToComponent(otherEdge);
                        if(i !== j && role.role === otherRole.role) {
                            component = Model.nodeToComponent(
                                            edge.node === this.node ? edge.otherNode : edge.node
                            );
                            otherComponent = Model.nodeToComponent(
                                            otherEdge.node === this.node ? otherEdge.otherNode : otherEdge.node)
                            ;
                            if(component.mnemonic === otherComponent.mnemonic)
                                return !confirm("The roles named '" + role.role + "' for '" +
                                        component + "' cannot be identical in this tie. " +
                                        "Please give the roles different and distinguishing names.");
                        }
                    }
                }
                // build the relations lookup
                for(i = 0; edge = this.node.edges[i]; i++) {
                    related = Model.nodeToComponent(edge.node === this.node ? edge.otherNode : edge.node);
                    role = Model.nodeToComponent(edge);
                    relation = role.role + "_" + related.mnemonic;
                    relations[relation] = true;
                }
                // then find all other ties of the same cardinality
                for(i = 0; component = Model.components[i]; i++) {
                    if(component.node.type === NodeType.TIE && component !== this &&
                            component.node.edges.length === this.node.edges.length) {
                        identical = true;
                        for(j = 0; edge = component.node.edges[j]; j++) {
                            related = Model.nodeToComponent(edge.node === component.node ? edge.otherNode : edge.node);
                            role = Model.nodeToComponent(edge);
                            relation = role.role + "_" + related.mnemonic;
                            identical &= relations[relation];
                            if(relations[relation]) delete relations[relation]; // so that it cannot be matched twice
                        }
                        if(identical) {
                            return !confirm("This tie will become identical to the already existing tie named " +
                                    component + ". Please rename the role.");
                        }
                    }
                }
                return true;
            },
            setHistorized: function(historized) {
                var index = this.editables.indexOf(Editables.changingRangeEdit);
                if(historized && index < 0)
                    this.editables.push(Editables.changingRangeEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                index = this.editables.indexOf(Editables.restatabilityEdit);
                if(historized && index < 0) 
                    this.editables.push(Editables.restatabilityEdit);
                else if (!historized && index >= 0)
                    this.editables.splice(index, 1);
                if(this.changingRange === '')
                    this.changingRange = Defaults.changingRange;
                var ref = historized ? '#tie_historized' : '#tie';
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref);
                this.nav.useElement.setAttributeNS(XLINKNS, 'xlink:href', ref.replace(/#/,'#nav_'));
                DrawingEngine.invalidateMiniature();
                this.historized = historized;
            },
            getHistorized: function() {
                return this.historized;
            },
            setKnotted: function(knotted) {
                this.knotted = knotted;
            },
            getKnotted: function() {
                return this.knotted;
            },
            fromXML: function(element) {
                var x, y, fixed, i, layout;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'layout')
                        layout = element.childNodes.item(i);
                if(layout) {
                    x = layout.getAttribute("x");
                    y = layout.getAttribute("y");
                    fixed = layout.getAttribute("fixed");
                }
                x = x ? Number(x) : Math.random() * window.innerWidth;
                y = y ? Number(y) : Math.random() * window.innerHeight;
                fixed = fixed ? fixed === 'true' : false;
                var metadata;
                var capsule = Defaults.encapsulation;
                var deletable = Defaults.deletability === 'true';
                var restatable = Defaults.restatability === 'true';
                var idempotent = Defaults.idempotency === 'true';
                var assertive = Defaults.assertiveness === 'true';
                var generator = Defaults.positGenerator === 'true';
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'metadata')
                        metadata = element.childNodes.item(i);
                if(metadata) {
                    capsule = metadata.getAttribute("capsule") || capsule;
                    var _deletable = metadata.getAttribute("deletable");
                    deletable = _deletable ? _deletable === 'true' : deletable;
                    var _restatable = metadata.getAttribute("restatable") || metadata.getAttribute("restatements");
                    restatable = _restatable ? _restatable === 'true' : restatable;
                    var _idempotent = metadata.getAttribute("idempotent");
                    idempotent = _idempotent ? _idempotent === 'true' : idempotent;
                    var _generator = metadata.getAttribute("generator");
                    generator = _generator ? _generator === 'true' : generator;
                    var _assertive = metadata.getAttribute("assertive");
                    assertive = _assertive ? _assertive === 'true' : assertive;
                }
                var description;
                for(i = 0; i < element.childNodes.length; i++)
                    if(element.childNodes.item(i).nodeName === 'description')
                        description = element.childNodes.item(i);
                var changingRange = element.getAttribute("timeRange") || '';
                var historized = changingRange ? true : false;
                var identity = element.getAttribute("identity") || Defaults.positIdentity;
                var tie = new Tie(x, y, historized);
                tie.setFixed(fixed);
                tie.setHistorized(historized);
                tie.changingRange = changingRange;
                tie.encapsulation = capsule;
                tie.deletable = deletable;
                tie.restatable = restatable;
                tie.idempotent = idempotent;
                tie.assertive = assertive;
                tie.positIdentity = identity;
                tie.positGenerator = generator;
                tie.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                var grandparent = element.parentNode.parentNode;
                var anchorRoles = element.getElementsByTagName("anchorRole");
                if(anchorRoles && anchorRoles.length > 0) 
                    this.parseRoles(
                            tie,
                            anchorRoles, 
                            Model.getAnchorLookup(), 
                            grandparent.getElementsByTagName("anchor")
                    );
                var knotRoles = element.getElementsByTagName("knotRole");
                if(knotRoles && knotRoles.length > 0)
                    this.parseRoles(
                            tie,
                            knotRoles, 
                            Model.getKnotLookup(), 
                            grandparent.getElementsByTagName("knot")
                    );
                tie.updateName();
                return tie;
            },
            parseRoles: function(tie, roles, lookup, refs) {
                var i, j, d, type, role, roleName, identifier, description, coloring, referred, key;
                for(i = 0; i < roles.length; i++) {
                    type = roles[i].getAttribute("type") || "??";
                    roleName = roles[i].getAttribute("role");
                    if(!roleName || roleName.match(/![^role].*!/)) roleName = "!role" + UniqueIdentity.nextId() + "!";
                    identifier = roles[i].getAttribute("identifier") || false;
                    coloring = roles[i].getAttribute("coloring") || "#000000";
                    for(j = 0; j < refs.length; j++) {
                        if(refs[j].getAttribute("mnemonic") === type) {
                            referred = lookup[refs[j].getAttribute("mnemonic")];
                            role = new Role(tie, referred, (identifier === "true"));
                            role.role = roleName;
                            role.setColoring(coloring);
                            Model.addComponent(role);
                            role.updateName();
                            break; // only one should match
                        }
                    }
                    for(d = 0; d < roles[i].childNodes.length; d++) {
                        if(roles[i].childNodes.item(d).nodeName === 'description')
                            description = roles[i].childNodes.item(d);
                        // WIP: keys
                        if(roles[i].childNodes.item(d).nodeName === 'key') {
                            key = roles[i].childNodes.item(d);
                            role.keys.push({
                                stop: key.getAttribute("stop") || '1',
                                route: key.getAttribute("route"),
                                of: key.getAttribute("of"), 
                                branch: key.getAttribute("branch") || '1'
                            });
                        }
                    }
                    role.description = (description && description.firstChild) ? description.firstChild.nodeValue : '';
                }
            },
            toXML: function(schema) {
                var tie = schema.createElement("tie");
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi')
                    tie.setAttribute("identity", this.isEmpty(this.positIdentity) ? '' : this.positIdentity);
                if(this.historized)
                    tie.setAttribute("timeRange", this.isEmpty(this.changingRange) ? '' : this.changingRange);
                var edges = this.node.edges;
                for(var i = 0; i < edges.length; i++) {
                    var roleElement;
                    var node = edges[i].otherNode;
                    var role = Model.nodeToComponent(edges[i]);
                    var component = Model.nodeToComponent(node);
                    if(node.type === NodeType.ANCHOR)
                        roleElement = schema.createElement("anchorRole");
                    else if(node.type === NodeType.KNOT)
                        roleElement = schema.createElement("knotRole");
                    roleElement.setAttribute("role", this.isEmpty(role.role) ? "!role" + UniqueIdentity.nextId() + "!" : role.role);
                    roleElement.setAttribute("type", this.isEmpty(component.mnemonic) ? "???" : component.mnemonic);
                    if(role.coloring !== '#000000')
                        roleElement.setAttribute("coloring", role.coloring);
                    roleElement.setAttribute("identifier",
                            this.isEmpty(role.identifier) ? false : role.identifier);
                    this.addDescriptionXML(roleElement, schema, role.description || component.description);
                    // WIP: keys
                    if(role.keys && role.keys.length > 0) {
                        for(var k = 0; k < role.keys.length; k++) {
                            var key = schema.createElement("key");
                            key.setAttribute("stop", role.keys[k].stop);
                            key.setAttribute("route", role.keys[k].route);
                            key.setAttribute("of", role.keys[k].of);
                            key.setAttribute("branch", role.keys[k].branch);
                            roleElement.appendChild(key);
                        }
                    }
                    tie.appendChild(roleElement);
                }

                var metadata = schema.createElement("metadata");
                metadata.setAttribute("capsule", this.encapsulation);
                if(Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi') {
                    metadata.setAttribute("generator", this.isEmpty(this.positGenerator) ? '' : this.positGenerator);
                    metadata.setAttribute("assertive", this.isEmpty(this.assertive) ? '' : this.assertive);
                }
                if(this.historized) {
                    metadata.setAttribute("restatable", this.isEmpty(this.restatable) ?
                            Defaults.restatability === 'true' : this.restatable);
                }
                metadata.setAttribute("deletable", this.isEmpty(this.deletable) ?
                        Defaults.deletability === 'true' : this.deletable);
                metadata.setAttribute("idempotent", this.isEmpty(this.idempotent) ?
                        Defaults.idempotency === 'true' : this.idempotent);
                tie.appendChild(metadata);
                this.addLayoutXML(tie, schema);
                this.addDescriptionXML(tie, schema, this.description);
                return tie;
            },
            contextualName: function() {
                var name;
                if(Settings.showMnemonics) {
                    name = this.toString();
                    if(this.historized && (this.restatable || this.idempotent)) {
                        name += ' (';
                        if(this.restatable)
                            name += 'r';
                        if(this.idempotent)
                            name += 'i';
                        if(this.deletable)
                            name += 'd';
                        if((Defaults.temporalization === 'crt' || Defaults.temporalization === 'bi') && this.assertive)
                            name += 'a';
                        name += ')';
                    }
                    if(this.postfixes.length > 0) 
                        name += ' [' + this.postfixes.join(', ') + ']'; 
                }
                else
                    name = '';
                return name;
            },
            toString: function() {
                var i, edge, component, role, name="";
                for(i = 0; edge = this.node.edges[i]; i++) {
                    if(i > 0)
                        name += "_";
                    component = Model.nodeToComponent(edge.otherNode);
                    role = Model.nodeToComponent(edge);
                    name += component.mnemonic + "_" + role.role;
                }
                return name;
            },
            draw: function(image) {
                image.control.setTranslate(this.node.xPosition, this.node.yPosition);
            }
        };

        // inheritance
        extend(Tie, Component);

        function Role(component, otherComponent, identifier) {
            this.id = UniqueIdentity.nextId();
            var node = component.node;
            var otherNode = otherComponent.node;
            // call the parent constructor
            Component.call(this, new Edge(this.id, node, otherNode));
            var controlPoint = this.node.controlPoint;
            this.role = '?' + this.id;
            this.component = component;
            this.otherComponent = otherComponent;
            this.identifier = identifier;
            this.keys = [];
            this.editables.push(Editables.roleEdit, Editables.coloringEdit);
            this.operations.push('toggleIdentifier', 'makeFirstRole', 'addToKey', 'removeFromKey', 'createKey');
            this.tied = node.type === NodeType.TIE || otherNode.type === NodeType.TIE;
            // SVG
            this.svg.pathElement = document.createElementNS(SVGNS, 'path');
            this.svg.pathElement.setAttributeNS(null, 'class', 'edge');
            this.setColoring(this.coloring);
            this.svg.pathElement.setAttributeNS(null, 'd', 'M' + node.xPosition.toFixed(2) + ',' + node.yPosition.toFixed(2) +
                    ' Q' + controlPoint.xPosition.toFixed(2) + ',' + controlPoint.yPosition.toFixed(2) +
                    ' ' + otherNode.xPosition.toFixed(2) + ',' + otherNode.yPosition.toFixed(2));
            this.svg.pathControl = {
                m: this.svg.pathElement.pathSegList.getItem(0),
                q: this.svg.pathElement.pathSegList.getItem(1)
            };
            SVGLayer.edges.appendChild(this.svg.pathElement);
            if(this.tied) {
                this.svg.graphicsElement = document.createElementNS(SVGNS, 'g');
                this.svg.graphicsElement.component = this;
                var bubble = document.createElementNS(SVGNS, 'use');
                bubble.setAttributeNS(XLINKNS, 'xlink:href', '#bubble');
                this.svg.graphicsElement.appendChild(bubble);
                this.svg.useElement = document.createElementNS(SVGNS, 'use');
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', this.identifier ? '#many' : '#one');
                this.svg.graphicsElement.appendChild(this.svg.useElement);
                this.svg.graphicsElement.addEventListener('mouseover', EventHandler.beginInteraction, false);
                SVGLayer.edges.appendChild(this.svg.graphicsElement);
                this.svg.control = this.svg.graphicsElement.transform.baseVal.appendItem(
                    this.svg.graphicsElement.ownerSVGElement.createSVGTransform()
                );
                this.svg.control.setTranslate(controlPoint.xPosition, controlPoint.yPosition);
                this.svg.boundingBox = this.svg.graphicsElement.getBBox();
                this.svg.xOffset = 2;
                this.svg.yOffset = 2;
                this.setNameable(true);
                this.svg.nameElement.setAttributeNS(null, 'class', 'role');
            }
            // NAV
            this.nav.pathElement = document.createElementNS(SVGNS, 'path');
            this.nav.pathElement.setAttributeNS(null, 'd', 'M' + node.xPosition.toFixed(2) + ',' + node.yPosition.toFixed(2) +
                    ' Q' + controlPoint.xPosition.toFixed(2) + ',' + controlPoint.yPosition.toFixed(2) +
                    ' ' + otherNode.xPosition.toFixed(2) + ',' + otherNode.yPosition.toFixed(2));
            this.nav.pathControl = {
                m: this.nav.pathElement.pathSegList.getItem(0),
                q: this.nav.pathElement.pathSegList.getItem(1)
            };
            NAVLayer.edges.appendChild(this.nav.pathElement);
            this.postCreationInitialization();
        }
        Role.prototype = {
            role: '',
            component: null,
            otherComponent: null,
            controlPoint: null,
            identifier: true,
            coloring: '#000000',
            tied: false,
            keys: null,
            setIdentifier: function(identifier) {
                this.identifier = identifier;
                this.svg.useElement.setAttributeNS(XLINKNS, 'xlink:href', this.identifier ? '#many' : '#one');
            },
            setColoring: function(coloring) {
                this.coloring = coloring;
                if(coloring === '#000' || coloring === '#000000') {
                    this.svg.pathElement.style.stroke = null;
                    this.svg.pathElement.style.strokeWidth = null;
                }
                else {
                    this.svg.pathElement.style.stroke = this.coloring;
                    this.svg.pathElement.style.strokeWidth = '10px';
                }
            },
            isInteractive: function() {
                return this.tied;
            },
            isDraggable: function() {
                return false;
            },
            // edges never fixate
            setFixed: function(fixed) {
                this.fixed = false;
            },
            contextualName: function() {
                var name = this.toString();
                if(this.postfixes.length > 0) 
                    name += ' [' + this.postfixes.join(', ') + ']'; 
                return name;
            },
            toString: function() {
                return this.role;
            },
            draw: function(image) {
                var node = this.node.node;
                var otherNode = this.node.otherNode;
                var controlPoint = this.node.controlPoint;
                var role = this.node;
                image.pathControl.m.x = node.xPosition;
                image.pathControl.m.y = node.yPosition;
                image.pathControl.q.x1 = controlPoint.xPosition;
                image.pathControl.q.y1 = controlPoint.yPosition;
                image.pathControl.q.x = otherNode.xPosition;
                image.pathControl.q.y = otherNode.yPosition;
                if(this.tied && image.control) {
                    image.control.setTranslate(role.xPosition, role.yPosition);
                }
            }
        };

        // inheritance
        extend(Role, Component);

        function ModalBackground(message) {
            var modalBackground = document.createElement('div');
            modalBackground.setAttribute("id", "modalBackground");
            modalBackground.style.width = window.innerWidth + 'px';
            modalBackground.style.height = window.innerHeight + 'px';
            this.modalBackground = modalBackground;
            if(message) {
                var text = document.createTextNode(message);
                modalBackground.appendChild(text);
            }
            document.body.appendChild(modalBackground);
            return this;
        }
        ModalBackground.prototype = {
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.modalBackground);
            }
        };

        function URLPopover(url) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "urlPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('iframe');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.src = url;

            popover.appendChild(content);
            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        URLPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CodePopover(documentFragment, preformatted) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "codePopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.setAttribute("contenteditable", "true");
            content.setAttribute("spellcheck", "false");
            if(preformatted)
                content.setAttribute("class", "preformatted");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';
            content.appendChild(documentFragment);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CodePopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        function CloudBrowserPopover(scope) {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudBrowserPopover");
            var wPadding = window.innerWidth * 0.1;
            var hPadding = window.innerHeight * 0.1;
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var filter = document.createElement('div');
            filter.setAttribute("id", "keywordFilter");
            filter.appendChild(document.createTextNode('Keyword: '));
            var keywords = document.createElement('input');
            keywords.setAttribute('type', 'text');
            keywords.addEventListener('change', function() { self.keywordFilter = this.value; }, false);
            filter.appendChild(keywords);
            var searchButton = document.createElement('input');
            searchButton.setAttribute('type', 'button');
            searchButton.value = 'Search';
            searchButton.addEventListener('click', function(e) {
                self.generateList();
            }, false);
            this.searchButton=searchButton;
            filter.appendChild(searchButton);

            var content = document.createElement('div');
            content.setAttribute("id", "content");
            content.style.width = (window.innerWidth - 2 * wPadding) + 'px';
            content.style.height = (window.innerHeight - 2 * hPadding) + 'px';

            this.listContainer=content;
            this.scope=scope;
            this.generateList();

            popover.appendChild(filter);
            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudBrowserPopover.prototype = {
            popover: null,
            modalBackground: null,
            listContainer:null,
            searchButton:null,
            scope:'',
            keywordFilter:'',
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            },
            generateList : function() {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var self = this;
                var xmlhttp = new window.XMLHttpRequest();
                this.searchButton.disabled=true;
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var modelList = new DOMParser().parseFromString(xmlhttp.responseText, 'text/xml');
                        self.fillFromList(modelList);
                    }
				};
                var params = {};
                params.action = 'list';
                params.maxItemsReturned = '100';
                params.scope = this.scope;
                if(self.keywordFilter!=='') {
                    params.filterBy='keywords';
                    params.filterValue=self.keywordFilter;
                }
                Actions.cloudWrapper(xmlhttp, params);
            },
            fillFromList : function(modelList) {
                var self = this;
                var models = modelList.getElementsByTagName('Model');
                var model, modelContainer;
                while (this.listContainer.hasChildNodes())
                    this.listContainer.removeChild(this.listContainer.firstChild);
                for(var i = 0; i < models.length; i++) {
                    model = models.item(i);
                    modelContainer = document.createElement('div');
                    modelContainer.setAttribute("class", "modelContainer");
                    modelContainer.modelId = model.getAttribute("modelId");
                    var modelName = model.getAttribute("modelName");
                    if(modelName.indexOf('data:') == 0)
                        modelName = b64_to_utf8(modelName.split(',')[1]);
                    modelContainer.modelName = modelName;
                    modelContainer.modelScope = model.getAttribute("scope") || "private";
                    modelContainer.modelKeywords = model.getAttribute("keywords");
                    var modelDescription = model.getAttribute("description");
                    if(modelDescription.indexOf('data:') == 0)
                        modelDescription = b64_to_utf8(modelDescription.split(',')[1]);
                    else
                        modelDescription = unescape(modelDescription);
                    modelContainer.modelDescription = modelDescription;
                    modelContainer.lastLoaded = model.getAttribute("lastLoaded");
                    modelContainer.loadedCount = model.getAttribute("loadedCount");
                    modelContainer.url = window.location.protocol + '//' +
                            window.location.hostname + window.location.pathname + "?id=" + modelContainer.modelId;
                    modelContainer.addEventListener('click', function(e) {
                        Actions.loadModelFromCloud(
                                this.modelId,
                                this.modelName,
                                this.modelScope,
                                this.modelKeywords,
                                this.modelDescription
                        );
                        self.close(e);
                    }, false);

                    //modelContainer.setAttribute("id","codePopover");
                    if(LOGGED_IN && (USER_ID === model.getAttribute("userId"))) {
                        var deleteButton = document.createElement('div');
                        deleteButton.className = 'modelDeleteButton';
                        deleteButton.setAttribute(
                                "style",
                                "border-style: hidden; display: block; margin: 0px 0px -28px; padding: 0;"
                        );
                        deleteButton.modelId = modelContainer.modelId;
                        deleteButton.modelName = modelContainer.modelName;
                        deleteButton.modelContainer = modelContainer;
                        deleteButton.addEventListener('click', function(event) {
                            //Disable click for modelcontainer
                            if (event.stopPropagation)
                                event.stopPropagation();
                            else if(window.event)
                               window.event.cancelBubble=true;
                            if(confirm("Are you sure you want to delete this model:?\n" + this.modelName)) {
                                Actions.deleteModelFromCloud(this.modelId);
                                self.listContainer.removeChild(this.modelContainer);
                            }
                        }, false);
                        modelContainer.appendChild(deleteButton);
                    }
                    var icon = document.createElement('img');
                    icon.setAttribute("src", model.getAttribute("icon"));
                    icon.setAttribute("class", "modelIcon");
                    var name = document.createElement("div");
                    name.appendChild(document.createTextNode(modelContainer.modelName + " "));
                    name.className = 'modelName';
                    var keywords = document.createElement("div");
                    keywords.className = 'modelKeywords';
                    keywords.appendChild(document.createTextNode(model.getAttribute("keywords")));
                    var description = document.createElement("div");
                    description.className = 'modelDescription';
                    description.appendChild(document.createTextNode(modelContainer.modelDescription));
                    modelContainer.appendChild(icon);
                    modelContainer.appendChild(name);
                    modelContainer.appendChild(keywords);
                    modelContainer.appendChild(description);
                    if(modelContainer.modelScope === 'public') {
                        var twitter = document.createElement('div');
                        var tweet = document.createElement("a");
                        var externalLink = document.createElement("img");
                        externalLink.setAttribute("src", "externalLink.png");
                        externalLink.setAttribute("class", "externalLink");
                        var params = [];
                        params.push("url=" + modelContainer.url);
                        params.push("via=anchormodeling");
                        params.push("text=" + modelContainer.modelName);
                        params.push("lang=en");
                        params.push("count=vertical");
                        tweet.setAttribute("href", "https://twitter.com/share?" + params.join('&'));
                        tweet.setAttribute("class", "tweet");
                        tweet.setAttribute("target", "_blank");
                        tweet.appendChild(document.createTextNode("tweet this model"));
                        twitter.setAttribute("class", "twitter");
                        twitter.appendChild(tweet);
                        twitter.appendChild(externalLink);
                        modelContainer.appendChild(twitter);
                    }
                    modelContainer.title = modelContainer.modelName +
                            ' - ' + modelContainer.loadedCount + ' views, last on ' + modelContainer.lastLoaded;
                    this.listContainer.appendChild(modelContainer);
                }
				self.searchButton.disabled=false;
            }
        };

        function CloudSaverPopover() {
            DrawingEngine.stop();
            var self = this;

            this.modalBackground = new ModalBackground();

            var popover = document.createElement('div');
            popover.setAttribute("id", "cloudSaverPopover");
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            popover.appendChild(close);

            var content = document.createElement('div');
            content.setAttribute("id", "content");

            var icon = document.createElement('img');
            icon.setAttribute('src', Actions.toSVGDataURL(NAV));
            content.appendChild(icon);

            var table = document.createElement('table');
            var tr = document.createElement('tr');
            var td = document.createElement('td');
            td.appendChild(document.createTextNode('Model name: '));
            tr.appendChild(td);
            td = document.createElement('td');
            var modelName = document.createElement('input');
            modelName.setAttribute('type', 'text');
            if(Model.name && Model.name !== null)
                modelName.value = Model.name;
            modelName.addEventListener('change', function() { Model.name = this.value; }, false);
            td.appendChild(modelName);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelScope = document.createElement('select');
            var privateOption = document.createElement('option');
            privateOption.setAttribute('value', 'private');
            privateOption.appendChild(document.createTextNode('Private'));
            modelScope.appendChild(privateOption);
            var publicOption = document.createElement('option');
            publicOption.setAttribute('value', 'public');
            publicOption.appendChild(document.createTextNode('Public'));
            modelScope.appendChild(publicOption);
            if(Model.scope && Model.scope !== null)
                modelScope.value = Model.scope;
            modelScope.addEventListener('change', function() { Model.scope = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Scope: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelScope);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelKeywords = document.createElement('input');
            modelKeywords.setAttribute('type', 'text');
            modelKeywords.setAttribute('placeholder', 'keywords separated with spaces');
            if(Model.keywords && Model.keywords !== null)
                modelKeywords.value = Model.keywords;
            modelKeywords.addEventListener('change', function() { Model.keywords = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Keywords: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelKeywords);
            tr.appendChild(td);
            table.appendChild(tr);

            var modelDesc = document.createElement('textarea');
            modelDesc.setAttribute('rows', '4');
            modelDesc.setAttribute('cols', '40');
            if(Model.description && Model.description !== null)
                modelDesc.value = Model.description;
            modelDesc.addEventListener('change', function() { Model.description = this.value; }, false);
            tr = document.createElement('tr');
            td = document.createElement('td');
            td.appendChild(document.createTextNode('Description: '));
            tr.appendChild(td);
            td = document.createElement('td');
            td.appendChild(modelDesc);
            tr.appendChild(td);
            table.appendChild(tr);

            content.appendChild(table);

            if(Model.id) {
                var overwriteButton = document.createElement('input');
                overwriteButton.setAttribute('type', 'button');
                overwriteButton.className = 'overwriteButton';
                overwriteButton.value = 'Overwrite';
                overwriteButton.addEventListener('click', function(e) {
                    Actions.saveModelInCloud(false);
                    self.close(e);
                }, false);
                content.appendChild(overwriteButton);
            }
            var saveButton = document.createElement('input');
            saveButton.setAttribute('type', 'button');
            saveButton.className = 'saveButton';
            saveButton.value = 'Save New';
            saveButton.addEventListener('click', function(e) {
                Model.id = null;
                Actions.saveModelInCloud(false);
                self.close(e);
            }, false);
            content.appendChild(saveButton);

            popover.appendChild(content);

            document.body.appendChild(popover);

            this.popover = popover;
            return this;
        }
        CloudSaverPopover.prototype = {
            popover: null,
            modalBackground: null,
            close: function(event) {
                document.body.removeChild(this.popover);
                this.modalBackground.close();
                DrawingEngine.start(false);
            }
        };

        var Operations = {
            // operations are defined as 'method', 'display name', 'description', 'optional rule'
            list: [
                // WIP: keys operations
                ['addToKey',
                    'Add selected to key',
                    'Adds the selected item(s) to the selected key route.',
                    function(allComponents) {
                        return EventHandler.selectedRoute;
                    }],
                ['removeFromKey',
                    'Remvove selected from key',
                    'Removes the selected item(s) from the selected key route.',
                    function(allComponents) {
                        return EventHandler.selectedRoute;
                    }],
                ['createKey',
                    'Create key from selected',
                    'Creates a key route from the selected item(s) in the model.',
                    function(allComponents) {
                        if(EventHandler.selectedRoute)
                            return false;
                        if(allComponents.length < 2)
                            return false;
                        var component, anchors = 0, ties = 0, knots = 0, attributes = 0, roles = 0;
                        for(var i = 0; component = allComponents[i]; i++) {
                            if(component.node.type === NodeType.ANCHOR)
                                anchors++;
                            else if(component.node.type === NodeType.TIE)
                                ties++;
                            else if(component.node.type === NodeType.KNOT)
                                knots++;
                            else if(component.node.type === NodeType.ATTRIBUTE) 
                                attributes++;
                            else if(component.node.type === NodeType.EDGE) 
                                roles++;
                        }
                        if(anchors != 1 || roles + knots + attributes == 0 || ties > 0)
                            return false;
                        return true;
                    }],
                ['erase',
                    '<u>D</u>elete selected...',
                    'Deletes the selected item(s) from the model.'],
                ['toggleKnotted',
                    'Toggle <u>k</u>notted',
                    'Adds or removes a knot from the selected attribute(s).'], // TODO: only remove knot if it is the last attribute
                ['toggleHistorized',
                    'Toggle <u>h</u>istorized',
                    'Historized items can store versions of values over changing time and are marked by a double outline in the model.'],
                ['addAttribute',
                    'Add <u>a</u>ttribute',
                    'Add an attribute to the selected anchor(s).'],
                ['addTie',
                    'Add <u>t</u>ie',
                    'Add a tie between the selected anchors.'],
                ['addAnchor',
                    'Add <u>a</u>nchor',
                    'Add an anchor to the selected tie(s).'],
                ['addKnot',
                    'Add <u>k</u>not',
                    'Add a knot to the selected tie(s).'],
                ['addTieAndAnchor',
                    'Add <u>t</u>ied anchor',
                    'Add a tie with a connected anchor to the selected anchor(s).'],
                ['toggleIdentifier',
                    'Toggle <u>i</u>dentifier',
                    'Toggles whether the selected role(s) should be a part of the primary key or not.'],
                ['makeFirstRole',
                    'Make <u>f</u>irst role',
                    'Make the selected role(s) the first role in the primary key and tie name.'],
                ['connect',
                    '<u>C</u>onnect',
                    'Connect the selected node(s).',
                    function(allComponents) {
                        if(allComponents.length !== 2)
                            return false;
                        var component, anchors = 0, ties = 0, knots = 0, knotted, attributes = 0;
                        for(var i = 0; component = allComponents[i]; i++) {
                            if(component.node.type === NodeType.ANCHOR)
                                anchors++;
                            else if(component.node.type === NodeType.TIE)
                                ties++;
                            else if(component.node.type === NodeType.KNOT)
                                knots++;
                            else if(component.node.type === NodeType.ATTRIBUTE) {
                                attributes++;
                                knotted = component.getKnotted();
                            }
                        }
                        return anchors && ties || knots && ties || attributes && knots && !knotted;
                    }],
                ['explode',
                    'E<u>x</u>plode/Implode',
                    'Change the level of detail for the selected item(s) in the model.']
            ],
            isSupported: function(operation, components) {
                for(var i = 0; i < components.length; i++)
                    if(components[i].operations.indexOf(operation) < 0)
                        return false;
                return true;
            }
        };

        function TabularEditor(filter) {
            var self = this;
            Actions.stopKeyboardEvents();
            var i = 0, component;
            this.modalBackground = new ModalBackground();
            this.tabularEditor = document.createElement('div');
            this.tabularEditor.setAttribute('id', 'tabularEditor');
            var close = document.createElement('div');
            close.className = 'closebutton';
            close.addEventListener('click', function(event) { return self.close(event); }, false);
            this.tabularEditor.appendChild(close);

            var components = Model.components.slice();
            // this needs to be smartly sorted such that an anchor and it's attributes follow after each other
            components.sort(function(a,b) { 
                var nameA = (a.node.type === NodeType.KNOT ? "0" : "1") + a.toString().substring(0,2);
                var nameB = (b.node.type === NodeType.KNOT ? "0" : "1") + b.toString().substring(0,2);
                return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
            });
            var constructs = {};
            constructs[NodeType.ANCHOR] = true;
            constructs[NodeType.KNOT] = true;
            constructs[NodeType.ATTRIBUTE] = true;
            // ties also need their roles listed and the name is needed as well
            // constructs[NodeType.TIE] = true;
            var somethingIsShowing = false;
            while (component = components[i++]) {
                if (component.node.type in constructs && component.toString().includes(filter)) {
                    var tabularComponent = document.createElement('fieldset');
                    tabularComponent.setAttribute('class', 'tabularComponent');
                    var legend = document.createElement('legend');
                    legend.setAttribute(
                        'title',
                        'All the editable fields of this ' + 
                        NodeType[component.node.type].toLowerCase() +
                        '.'
                    );
                    tabularComponent.label = document.createTextNode(component.toString());
                    legend.appendChild(tabularComponent.label);
                    tabularComponent.appendChild(legend);
                    component.tabular(tabularComponent); 
                    this.tabularEditor.appendChild(tabularComponent);
                    somethingIsShowing = true;
                }
            }
            if (somethingIsShowing) 
                document.body.appendChild(this.tabularEditor);
            else 
                this.close();
        }
        TabularEditor.prototype = {
            modalBackground: null,
            tabularEditor: null, 
            close: function() {
                this.modalBackground.close();
                if(document.body.contains(this.tabularEditor))
                    document.body.removeChild(this.tabularEditor);
                this.tabularEditor = null;
            }
        }


        function ContextMenu(hoveredComponent, selectedComponents, selectedRoute) {
            var self = this;

            this.hoveredComponent = hoveredComponent;
            this.selectedComponents = selectedComponents;
            var contextMenu = document.createElement('div');
            contextMenu.setAttribute('id', 'contextMenu');
            this.toggler = document.createElement('div');
            this.toggler.setAttribute('class', 'toggler collapsed');
            this.toggler.setAttribute('title', 'Click to open the context menu.');
            this.toggler.addEventListener('click', function(event) { self.toggle(); }, false);
            contextMenu.appendChild(this.toggler);
            this.contextMenu = contextMenu;

            this.topper = document.createElement('div');
            this.topper.setAttribute('class', 'topper unselectable');
            this.topper.addEventListener('mousedown', function(event) { self.mousedown(event); }, false);

            var editable;
            this.editsHaveBeenMade = false;
            this.editables = document.createElement('table');
            this.editables.setAttribute('class', 'items');
            this.showEditables = false;

            var i, j, tr;
            // WIP: keys edit
            if(selectedRoute) {
                this.topper.appendChild(document.createTextNode("Edit key of " + selectedRoute.start.mnemonic));
            }
            // if we are operating a single node, show its editable fields
            else if(selectedComponents.length === 0 || (selectedComponents.length === 1 && selectedComponents[0] === hoveredComponent)) {
                this.topper.appendChild(document.createTextNode("Edit " + NodeType[hoveredComponent.node.type]));
                for(i = 0; editable = hoveredComponent.editables[i]; i++) {
                    if(editable.editable) {
                        this.showEditables = true;
                        var element = document.createElement(editable.type);
                        element.className = 'editable';
                        if(editable.prepare) {
                            editable.prepare(hoveredComponent);
                        }
                        if(editable.pattern) {
                            element.setAttribute('pattern', editable.pattern);
                        }
                        if(editable.attributes) {
                            for(j = 0; j < editable.attributes.length;) {
                                var attribute = editable.attributes[j++];
                                var value = editable.attributes[j++];
                                element.setAttribute(attribute, value);
                            }
                        }
                        if(editable.elements) {
                            for(j = 0; j < editable.elements.length;) {
                                var subElement = editable.elements[j++];
                                element.appendChild(subElement);
                            }
                        }
                        editable.setElement(element, hoveredComponent);
                        element.editable = editable;
                        element.addEventListener(editable.event, function() { self.edit(this, hoveredComponent); }, false);
                        element.addEventListener('change', function() { self.editsHaveBeenMade = true; }, false);
                        this.keypress = this.keypress.bind(this);
                        element.addEventListener('keypress', this.keypress, false);
                        tr = document.createElement('tr');
                        tr.setAttribute('valign', 'top');
                        tr.setAttribute('title', editable.description);
                        var td1 = document.createElement('td');
                        td1.appendChild(document.createTextNode(editable.name + ":"));
                        tr.appendChild(td1);
                        var td2 = document.createElement('td');
                        td2.appendChild(element);
                        tr.appendChild(td2);
                        this.editables.appendChild(tr);
                    }
                }
            }
            else {
                this.topper.appendChild(document.createTextNode("Edit selection"));
            }

            var supportedOperations = [];

            var allComponents = selectedComponents.slice(0);
            if(allComponents.indexOf(hoveredComponent) < 0)
                allComponents.push(hoveredComponent);

            var validator;
            for(i = 0; i < Operations.list.length; i++) {
                if(Operations.isSupported(Operations.list[i][0], allComponents)) {
                    if(validator = Operations.list[i][3]) {
                        if(validator(allComponents))
                            supportedOperations.push(Operations.list[i]);
                    }
                    else
                        supportedOperations.push(Operations.list[i]);
                }
            }

            this.operators = document.createElement('fieldset');
            this.operators.setAttribute('class', 'operators');
            var operations = document.createElement('legend');
            operations.setAttribute(
                    'title',
                    'Context sensitive list of operations that can be performed ' +
                    'on the selected item(s). Shift+click in order to select ' +
                    'multiple items in the model graph.'
            );
            operations.appendChild(document.createTextNode('OPERATIONS'));
            this.operators.appendChild(operations);
            for(i = 0; i < supportedOperations.length; i++) {
                var operator = document.createElement('div');
                operator.setAttribute('class', 'operator');
                operator.setAttribute('title', supportedOperations[i][2]);
                operator.innerHTML = supportedOperations[i][1];
                operator.method = supportedOperations[i][0];
                operator.addEventListener('click', function() { self.operate(this, allComponents); }, false);
                this.operators.appendChild(operator);
            }

            this.updatePosition();
            document.body.appendChild(this.contextMenu);
            return this;
        }
        ContextMenu.prototype = {
            contextMenu: null,
            hoveredComponent: null,
            selectedComponents: null,
            showEditables: false,
            editables: null,
            operators: null,
            divider: null,
            topper: null,
            toggler: null,
            collapsed: true,
            modalBackground: null,
            editsHaveBeenMade: false,
            dragging: false,
            operate: function(button, components) {
                if(Model[button.method](components))
                    this.close();
            },
            edit: function(element, component) {
                if(element && component) {
                    element.editable.setMember(element, component);
                    element.checkValidity();
                }
            },
            mousedown: function(event) {
                this.mousemove = this.mousemove.bind(this);
                this.mouseup = this.mouseup.bind(this);
                window.addEventListener('mousemove', this.mousemove, false);
                window.addEventListener('mouseup', this.mouseup, false);
                this.dragging = true;
            },
            mousemove: function(event) {
                if(this.dragging) {
                    var xScreen, yScreen;
                    xScreen = event.clientX
                            - this.contextMenu.offsetWidth / 2;
                    yScreen = event.clientY
                            - this.topper.offsetHeight / 2;
                    this.updatePosition(xScreen, yScreen);
                }
            },
            mouseup: function(event) {
                this.dragging = false;
                window.removeEventListener('mousemove', this.mousemove, false);
                window.removeEventListener('mouseup', this.mouseup, false);
            },
            updatePosition: function(x, y) {
                var point = EventHandler.svgToScreen(
                        this.hoveredComponent.node.xPosition + 15, // inside the highlight ring with radius 30
                        this.hoveredComponent.node.yPosition + 15
                );
                x = x ? x : point.x;
                y = y ? y : point.y;
                this.contextMenu.style.left = x + 'px';
                this.contextMenu.style.top = y + 'px';
            },
            keypress: function(event) {
                if(event.keyCode === 13) {
                    event.srcElement.blur();
                    if(Model.isConforming())
                        this.close();
                }
            },
            toggle: function() {
                var self = this;
                if(this.collapsed) {
                    this.toggler.className = 'toggler expanded';
                    this.toggler.setAttribute('title', 'Click to close the context menu.');
                    this.collapsed = false;
                    this.modalBackground = new ModalBackground();
                    this.contextMenu.appendChild(this.topper);
                    if(this.showEditables) {
                        this.contextMenu.appendChild(this.editables);
                        var editables = this.editables.getElementsByClassName('editable');
                        if(editables.length > 0) {
                            editables[0].focus();
                            if(editables[0].setSelectionRange)
                                editables[0].setSelectionRange(0, editables[0].value.length);
                        }
                    }
                    window.removeEventListener('keypress', EventHandler.keypress, false);
                    this.contextMenu.appendChild(this.operators);
                }
                else {
                    if(this.editsHaveBeenMade && !Model.isConforming())
                        return;
                    this.toggler.className = 'toggler collapsed';
                    this.toggler.setAttribute('title', 'Click to open the context menu.');
                    this.collapsed = true;
                    this.contextMenu.removeChild(this.operators);
                    if(this.showEditables) {
                        this.contextMenu.removeChild(this.editables);
                    }
                    this.contextMenu.removeChild(this.topper);
                    this.unmodal();
                    window.addEventListener('keypress', EventHandler.keypress, false);
                    DrawingEngine.start(false);
                }
            },
            unmodal: function() {
                if(this.modalBackground) {
                    this.modalBackground.close();
                    this.modalBackground = null;
                }
            },
            close: function() {
                this.unmodal();
                if(this.editsHaveBeenMade)
                    Model.recordState();
                if(document.body.contains(this.contextMenu))
                    document.body.removeChild(this.contextMenu);
                window.addEventListener('keypress', EventHandler.keypress, false);
                DrawingEngine.start(false);
            }
        };

        var FileHandler = {
            reader: null,
            handleFiles: function(files) {
                this.reader = new FileReader();
                this.reader.onload = function(e) { FileHandler.fileLoaded(e); };
                this.reader.onerror = function(e) {
                    if(console && console.error)
                        console.error("File could not be read! Code " + event.target.error.code);
                };
                this.reader.readAsText(files[0]);
            },
            replaceInput: function(parent, input) {
                var newInput = document.createElement('input');
                newInput.className = 'fileSelect';
                newInput.setAttribute('type', 'file');
                newInput.addEventListener('change', function() {
                    FileHandler.handleFiles(this.files);
                    FileHandler.replaceInput(this.parentNode, this);
                }, false);
                parent.replaceChild(newInput, input);
            },
            fileLoaded: function(event) {
                var xml;
                try {
                    var parser = new DOMParser();
                    xml = parser.parseFromString(this.reader.result, "text/xml");
                }
                catch(exception) {
                    alert(exception);
                }
                Model.uncloud();
                Model.clearStates();
                Model.fromXML(xml);
                Actions.setModelStatus();
                Actions.resetZoom();
                Actions.centerModel();
                DrawingEngine.taint();
                DrawingEngine.start(false);
            }
        };

        var Actions = {
            startKeyboardEvents: function() {
                window.addEventListener('keypress', EventHandler.keypress, false);
            },
            stopKeyboardEvents: function() {
                window.removeEventListener('keypress', EventHandler.keypress, false);
            },
            populateSelector: function(selector, searchString) {
                this.startKeyboardEvents();
                var node, component;
                var selected = selector.value;
                while(selector.options.length > 0)
                    selector.options.remove(0);
                selector.options.add(new Option("None selected", "none"));
                var components = Model.components.slice();
                components.sort(
                    function(a, b) {
                        var nameA = a.encapsulation + '.' + a.toString();
                        var nameB = b.encapsulation + '.' + b.toString();
                        return nameA < nameB ? -1 : nameA > nameB ? 1 : 0;
                    }
                );
                for(var i = 0; component = components[i]; i++) {
                    node = component.node;
                    if(component.toString() && node.type !== NodeType.EDGE) {
                        var fullName = component.encapsulation + '.' + component.toString();
                        if(component.incomplete)
                            fullName = "* " + fullName;
                        var option = new Option(fullName, component.id);
                        if(searchString && searchString.trim() !== '') {
                            if(fullName.indexOf(searchString) >= 0)
                                selector.options.add(option);
                        }
                        else {
                            selector.options.add(option);
                        }
                    }
                }
                selector.value = selected;
            },
            toSVGDataURL: function(image) {
                var graph = image.cloneNode(true);
                var viewport = graph.getElementById('viewport');
                if(viewport) graph.removeChild(viewport);
                var svg = (new XMLSerializer()).serializeToString(graph);
                return "data:image/svg+xml;base64," + btoa(svg);
            },
            toPNGDataURL: function(image) {
                var can = document.createElement('canvas');
                var ctx = can.getContext('2d');
                var img = new Image();
                img.width = can.width = image.width.baseVal.value;
                img.height = can.height = image.height.baseVal.value;
                img.onload = function() {
                    // draw the image onto the canvas
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                }
                img.src = this.toSVGDataURL(image);
                return can.toDataURL('image/png');
            },
            screenshot: function(dataURL) {
                var newtab = window.open('about:blank'); 
                var img = newtab.document.createElement('img');
                img.src = dataURL;
                setTimeout(function(){
                    newtab.document.write(img.outerHTML);
                }, 0);
            },
            findNodeToExplode: function(node) {
                var edge, otherNode;
                for(var i = 0; edge = node.edges[i]; i++) {
                    otherNode = edge.node === node ? edge.otherNode : edge.node;
                    if((otherNode.type === NodeType.ANCHOR) && otherNode.imploded) {
                        Model.explode([Model.nodeToComponent(otherNode)]);
                        break;
                    }
                }
            },
            selectNode: function(id) {
                if(id !== 'none') {
                    var i, edge, otherNode;
                    var component = Model.idToComponent[id];
                    var node = component.node;
                    // find the closest imploded node and explode it
                    if(!node.visible) {
                        if(node.type === NodeType.ATTRIBUTE)
                            this.findNodeToExplode(node);
                        else if(node.type === NodeType.KNOT) {
                            this.findNodeToExplode(node);
                            if(!node.visible) {
                                for(i = 0; edge = node.edges[i]; i++) {
                                    otherNode = edge.node === node ? edge.otherNode : edge.node;
                                    if(otherNode.type === NodeType.ATTRIBUTE) {
                                        this.findNodeToExplode(otherNode);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    EventHandler.clearSelection();
                    EventHandler.addComponentToSelection(component);
                    Actions.centerModelOn(node);
                }
                else {
                    EventHandler.clearSelection();
                }
            },
            getDirectives: async function(scriptname) {
                var database = Defaults.databaseTarget;
                var temporalization = Defaults.temporalization;
                var filename = scriptname || database + '_' + temporalization + '.directive';

                var cacheDisabler = '';
                if(DEBUG) cacheDisabler = '?r=' + Math.random();

                // process and evaluate all sisulas in the directive
                var response = await fetch(filename + cacheDisabler);
                var responseText = await response.text();
                return responseText;
            },            
            transform: async function (xmlDocument, transformationURL, ownerDocument) {
                var result;
                // Added random parameter to prevent caching...
                var url = transformationURL + '?r=' + Math.random();
                var xml = await this.loadXML(url);
                var processor = new XSLTProcessor();
                processor.importStylesheet(xml.documentElement);
                result = processor.transformToFragment(xmlDocument, ownerDocument);
                return result;
            },
            createEmail: function(str) {
                ASKBEFOREUNLOAD = false; // prevent onbeforeunload behavior
                var save = document.createElement('a');
                var modelName = Model.name || 'Model';
                save.href = "mailto:?subject=" + modelName + "&body=" + str;
                save.target = '_self';
                var event = document.createEvent('Event');
                event.initEvent('click', true, true);
                save.dispatchEvent(event);
                (window.URL || window.webkitURL).revokeObjectURL(save.href);
            },
            saveToDisk: function (str, type) {
                var save = document.createElement('a');
                save.href = 'data:text/' + type + ',' + str;
                save.target = '_blank';
                save.download = (Model.name || 'Model') + '.' + type;
                var event = new MouseEvent('click', {
                                'view': window,
                                'bubbles': true,
                                'cancelable': false
                            });
                save.dispatchEvent(event);
                (window.URL || window.webkitURL).revokeObjectURL(save.href);
            },
            loadModelFromGist: async function(gist_id) {
                var url = "https://api.github.com/gists/" + gist_id;
                var response = await fetch(url);
                var responseText = await response.text();
                const gist = JSON.parse(responseText);
                // console.log(gist);
                var file, raw_url;
                for (file in gist.files) {
                    if(gist.files[file].language == 'XML') {
                        raw_url = gist.files[file].raw_url;
                        Model.id = gist_id;
                        Model.name = gist.description;
                        Model.scope = gist.public == 'true' ? 'public' : 'private';
                        Model.description = gist.owner.login;
                        break;
                    }
                }
                this.loadFromURL(raw_url, false);
            },
            loadXML: async function(url) {
                var response = await fetch(url);
                var responseText = await response.text();
                var xml = new DOMParser().parseFromString(responseText, 'text/xml');
                return xml;                
            },
            loadFromURL: function (url, layout) {
                layout = typeof layout !== 'undefined' ? layout : false;
                this.loadXML(url)
                .then(xml => {
                    EventHandler.clearSelection();
                    SVGLayer.clearAll();
                    NAVLayer.clearAll();
                    Model.uncloud();
                    Model.clearStates();
                    Model.fromXML(xml);
                    Actions.setModelStatus();
                    Actions.resetZoom();
                    Actions.centerModel();
                    DrawingEngine.taint();
                    DrawingEngine.start(layout);
                });
            },
            modelStatusText: null,
            setModelStatus: function() {
                var statusElement = document.getElementById("model");
                var status = "Local editing mode";
                if(Model.name && Model.id)
                    status = "Cloud mode, editing " + Model.scope + " model: " + Model.name;
                if(Actions.modelStatusText)
                    statusElement.removeChild(Actions.modelStatusText);
                Actions.modelStatusText = document.createTextNode(status);
                statusElement.appendChild(Actions.modelStatusText);
            },
            cloudStatusText: null,
            checkCloudConnectionStatus: function(redirect) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var statusElement = document.getElementById("cloud");
                        if(Actions.cloudStatusText)
                            statusElement.removeChild(Actions.cloudStatusText);
                        var lines, response = xmlhttp.responseText;
                        if(response.match(/^OK:/) && !redirect) {
                            lines = response.split(/[\r\n]/);
                            var login = lines[0].replace(/^OK:/, '').replace(/^[^\S]+/,'');
                            Actions.cloudStatusText = document.createTextNode(login);
                            statusElement.appendChild(Actions.cloudStatusText);
                            USER_ID = lines[2];
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^LOGIN:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging in...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            window.location = response.replace(/^LOGIN:/, '').replace(/^[^\S]+/,'');
                            LOGGED_IN = true;
                        }
                        else if(response.match(/^OK:/) && redirect) {
                            Actions.cloudStatusText = document.createTextNode("Logging out...");
                            statusElement.appendChild(Actions.cloudStatusText);
                            ASKBEFOREUNLOAD = false;
                            lines = response.split(/[\r\n]/);
                            window.location = lines[1];
                            LOGGED_IN = false;
                        }
                        else {
                            Actions.cloudStatusText = document.createTextNode("Not logged in (click here to log in)");
                            statusElement.appendChild(Actions.cloudStatusText);
                            LOGGED_IN = false;
                        }
                        Actions.setModelStatus();
                    }
                };

                var params = {};
                params.action = 'status';
                this.cloudWrapper(xmlhttp, params);
            },
            listModelsInCloud: function(scope) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";

                if(scope === 'private' && !LOGGED_IN) {
                    alert("You need to log in to reach your private models. Try again after logging in!");
                    this.checkCloudConnectionStatus(true);
                }

                new CloudBrowserPopover(scope);
            },
            loadModelFromCloud: function(modelId, modelName, modelScope, modelKeywords, modelDescription) {
                var modalBackground = new ModalBackground('Loading model, please wait...');
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be loaded from the cloud service!");
                            if(Model.isEmpty())
                                Model.setupMinimal(false);
                        }
                        else {
                            var model, modelString = xmlhttp.responseText;
                            if(modelString.indexOf('data:') == 0)
                                modelString = b64_to_utf8(modelString.replace(/\s/g,"").split(',')[1]);
                            if(DEBUG) console.log(modelString);
                            model = new DOMParser().parseFromString(modelString, 'text/xml');
                            EventHandler.clearSelection();
                            SVGLayer.clearAll();
                            NAVLayer.clearAll();
                            Model.uncloud();
                            Model.clearStates();
                            Model.fromXML(model);
                            Model.id = modelId;
                            Model.name = modelName;
                            Model.scope = modelScope;
                            Model.keywords = modelKeywords;
                            Model.description = modelDescription;
                            Actions.setModelStatus();
                            Actions.resetZoom();
                            Actions.centerModel();
                            DrawingEngine.taint();
                            DrawingEngine.start(false);
                        }
                        modalBackground.close();
                    }
                };

                var params = {};
                params.action = 'load';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp,params);
            },
            saveModelInCloud: function(popover) {
                if(popover) {
                    new CloudSaverPopover();
                }
                else {
                    var xmlhttp = new window.XMLHttpRequest();
                    xmlhttp.onreadystatechange = function() { //Call a function when the state changes.
                        if(xmlhttp.readyState === 4) {
                            var response = xmlhttp.responseText;
                            if(response.match(/^LOGIN:/)) {
                                alert("You need to log in before saving. Try to save again after logging in!");
                                ASKBEFOREUNLOAD = false;
                                window.location = response.replace(/^LOGIN:/, '');
                            }
                            else if(response.match(/^OK:/)) {
                                Model.id = response.replace(/^OK:/, '').replace(/^[^\S]+/,'').replace(/[^\S]+$/,'');
                                Actions.setModelStatus();
                                alert("Model saved in cloud as: " + Model.name);
                            }
                            else {
                                // this is probably an error msg from the server
                                alert(response);
                            }
                        }
                    };

                    var params = {};
                    params.action = 'save';
                    params.modelName = "data:text/plain;charset=UTF-8;base64," +
                            utf8_to_b64(Model.name);
                    params.modelXml = "data:text/xml;charset=UTF-8;base64," +
                            utf8_to_b64(new XMLSerializer().serializeToString(Model.toXML(false)));
                    params.icon = Actions.toSVGDataURL(NAV);
                    params.scope = Model.scope || "private";
                    params.keywords = Model.keywords;
                    params.description = "data:text/plain;charset=UTF-8;base64," +
                            utf8_to_b64(Model.description);
                    if(Model.id)
                        params.modelId = Model.id;
                    this.cloudWrapper(xmlhttp,params);
                }
            },
            deleteModelFromCloud : function(modelId) {
                window.status = "Contacting Cloud...";
                document.body.style.cursor = "wait";
                var xmlhttp = new window.XMLHttpRequest();
                xmlhttp.onreadystatechange = function() {//Call a function when the state changes.
                    if(xmlhttp.readyState === 4) {
                        window.status = "";
                        document.body.style.cursor = "default";
                        var response = xmlhttp.responseText;
                        if(!response || response.length <= 5 || response.match(/ERROR.*/)) {
                            alert("The selected model could not be deleted from the cloud service!\n" + response);
                        }
                        else {
                            alert("The model was deleted successfully.");
                        }
                    }
                };
                var params = {};
                params.action = 'delete';
                params.modelId = modelId;
                this.cloudWrapper(xmlhttp, params);
            },
            sendMultiPart: function(xmlhttp, params) {
                var BOUNDARY = "---------------------------1966284435497298061834782736";
                var rn = "\r\n";
                var req = "--" + BOUNDARY;
                for (var i in params) {
                    req += rn + "Content-Disposition: form-data; name=\"" + i + "\"";
                    req += rn + rn + params[i] + rn + "--" + BOUNDARY;
                }
                req += "--";
                xmlhttp.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + BOUNDARY);
                xmlhttp.sendAsBinary(req);
            },
            cloudWrapper : function(xmlhttp, params) {
                var url = "http://anchormodeler.appspot.com/anchormodeler";
                //var url = "http://localhost:8888/anchormodeler";
                xmlhttp.open("POST", url, true);
                xmlhttp.withCredentials = 'true';
                if(window.FormData) {
                    var formData = new FormData();
                    for (var i in params)
                        formData.append(i,params[i]);
                    xmlhttp.send(formData);
                }
                else if (XMLHttpRequest && XMLHttpRequest.prototype.sendAsBinary) {
                    this.sendMultiPart(xmlhttp, params);
                }
            },
            resetZoom: function() {
                SVG.viewBox.baseVal.width = window.innerWidth;
                SVG.viewBox.baseVal.height = window.innerHeight;
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
            },
            centerModel: function() {
                var boundingBox = SVGLayer.nodes.getBBox();
                var xCenter = boundingBox.x + boundingBox.width/2;
                var yCenter = boundingBox.y + boundingBox.height/2;
                this.centerModelAt(xCenter, yCenter);
            },
            centerModelOn: function(node) {
                this.centerModelAt(node.xPosition, node.yPosition);
            },
            centerModelAt: function(x, y) {
                SVG.viewBox.baseVal.x = x - SVG.viewBox.baseVal.width/2;
                SVG.viewBox.baseVal.y = y - SVG.viewBox.baseVal.height/2;
                DrawingEngine.invalidateMiniature();
                DrawingEngine.start(false);
            },
            randomizeLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    if(!Model.visibleNodes[i].fixed) {
                        Model.visibleNodes[i].xPosition = Math.random() * window.innerWidth;
                        Model.visibleNodes[i].yPosition = Math.random() * window.innerHeight;
                    }
                }
                DrawingEngine.start(true);
            },
            toggleFixation: function () {
                for(var i = 0; i < Model.components.length; i++)
                    Model.components[i].setFixed(!Model.components[i].getFixed());
                DrawingEngine.start(true);
            },
            releaseAll: function () {
                for(var i = 0; i < Model.components.length; i++)
                    Model.components[i].setFixed(false);
                DrawingEngine.start(true);
            },
            toggleNames: function () {
                DrawingEngine.showNames = !DrawingEngine.showNames;
                if(DrawingEngine.showNames)
                    SVGLayer.show('names');
                else
                    SVGLayer.hide('names');
                DrawingEngine.start(false);
            },
            toggleKeys: function() {
                EventHandler.clearSelection();
                DrawingEngine.showKeys = !DrawingEngine.showKeys;
                if(DrawingEngine.showKeys) 
                    SVGLayer.show('keys');
                else
                    SVGLayer.hide('keys');
                DrawingEngine.start(false);                
            },
            toggleMnemonics: function () {
                Settings.showMnemonics = !Settings.showMnemonics;
                DrawingEngine.start(false);
            },
            toggleColoring: function() {
                DrawingEngine.coloring = !DrawingEngine.coloring;
                DrawingEngine.start(false);
            },
            implodeAll: function() {
                var i, component, allComponents = [];
                for(i = 0; component = Model.components[i]; i++) {
                    if((component.node.type === NodeType.ANCHOR) && !component.imploded)
                        allComponents.push(component);
                }
                EventHandler.clearSelection();
                Model.explode(allComponents);
            },
            explodeAll: function() {
                var i, component, allComponents = [];
                for(i = 0; component = Model.components[i]; i++) {
                    if((component.node.type === NodeType.ANCHOR) && component.imploded)
                        allComponents.push(component);
                }
                Model.explode(allComponents);
            },
            generateURL: function() {
                if(Model.id) {
                    if(Model.scope !== 'public')
                        alert("This model not public. Please note that only you will be able to use the URL.");
                    var url = window.location.protocol + '//' + window.location.hostname + window.location.pathname;
                    url += "?id=" + Model.id;
                    prompt("Sharable and social media friendly URL:", url);
                }
                else {
                    alert("This model is not saved in the cloud. Please save the model before generating a URL.");
                }
            },
            generateSVG: function(graph) {
                new CodePopover(Actions.preformat((new XMLSerializer()).serializeToString(graph)), true);
            },
            generateSQL: function() {
                Sisulator.sisulate(Model.toXML(true), MAP, Actions.getDirectives)
                .then(sql => {
                    new CodePopover(Actions.preformat(sql), true)
                });
            },
            generateXML: function() {
                Actions.transform(Model.toXML(false), 'xml2html.xsl', document)
                .then(fragment => {
                    new CodePopover(fragment, false);
                });
            },
            generateHTML: function() {
                var html = window.open('', '_newtab').document;
                html.open();
                html.write(
                    '<!DOCTYPE HTML>'+
                    '<html><head>'+
                    '  <title>Anchor Model</title>' +
                    '  <link rel="stylesheet" type="text/css" href="documentation.css">'+
                    '</head><body>'+
                    '</body></html>'
                );
                html.close();
                this.transform(Model.toXML(false), 'xml2documentation.xsl', html)
                .then(fragment => {
                    html.body.appendChild(fragment);
                });
            },
            jsonify: function(xml) {
                var object = Sisulator.objectify(xml, MAP);
                // jsonify the object
                return JSON.stringify(object, null, 3);
            },
            // creates a preformatted document fragment from the given text
            preformat: function(text) {
                var fragment = document.createDocumentFragment();
                var pre = document.createElement('pre');
                pre.appendChild(document.createTextNode(text));
                fragment.appendChild(pre);
                return fragment;
            }
        };

        var Settings = {
            // default values for some 'global' settings
            calculations: 'simple',
            showMnemonics: false,
            showCardinalities: true,
            init: function() {
                document.getElementById('damping').value = ((1 - LayoutEngine.damping) * 100).toFixed(0);
                document.getElementById('longRangeEffect').value = (LayoutEngine.longRangeEffect * 100).toFixed(0);
                document.getElementById('fuzziness').value = (LayoutEngine.fuzziness * 100).toFixed(0);
                document.getElementById('normalDistance').value = LayoutEngine.normalDistance.toFixed(0);
                document.getElementById('stoppingVelocity').value = LayoutEngine.stoppingVelocity.toFixed(1);
                document.getElementById('minimumStartingVelocity').value = LayoutEngine.minimumStartingVelocity.toFixed(1);
                document.getElementById('maximumStartingVelocity').value = LayoutEngine.maximumStartingVelocity.toFixed(1);
                document.getElementById('partitionFactor').value = LayoutEngine.partitionFactor.toFixed(0);
                document.getElementById('stiffness').value = LayoutEngine.stiffness.toFixed(1);
                document.getElementById('temporalization').value = Defaults.temporalization;
                document.getElementById('database').value = Defaults.databaseTarget;
                document.getElementById('miniatureFramesBetweenRefresh').value = DrawingEngine.miniatureFramesBetweenRefresh;
                document.getElementById('calculations').value = this.calculations;
                document.getElementById('encapsulation').value = Defaults.encapsulation;
                document.getElementById('defaultIdentity').value = Defaults.identity;
                document.getElementById('defaultChronon').value = Defaults.chronon;
                document.getElementById('defaultNow').value = Defaults.now;
                document.getElementById('defaultChangingRange').value = Defaults.changingRange;
                document.getElementById('deletability').checked = Defaults.deletability === 'true';
                document.getElementById('restatability').checked = Defaults.restatability === 'true';
                document.getElementById('idempotency').checked = Defaults.idempotency === 'true';
                document.getElementById('metadataUsage').checked = Defaults.metadataUsage === 'true';
                document.getElementById('businessViews').checked = Defaults.businessViews === 'true';
                document.getElementById('triggers').checked = Defaults.triggers === 'true';
                document.getElementById('decisiveness').checked = Defaults.decisiveness === 'true';
                document.getElementById('entityIntegrity').checked = Defaults.entityIntegrity === 'true';
                document.getElementById('equivalence').checked = Defaults.equivalence === 'true';
                document.getElementById('partitioning').checked = Defaults.partitioning === 'true';
                document.getElementById('changingSuffix').value = Defaults.changingSuffix;
                document.getElementById('checksumSuffix').value = Defaults.checksumSuffix;
                document.getElementById('identitySuffix').value = Defaults.identitySuffix;
                document.getElementById('deletablePrefix').value = Defaults.deletablePrefix;
                document.getElementById('deletionSuffix').value = Defaults.deletionSuffix;
                document.getElementById('encryptionGroup').value = Defaults.encryptionGroup;
                document.getElementById('naming').value = Defaults.naming;
            },
            resetDefaults: function(warn) {
                var reset = false;
                if(warn)
                    reset = confirm(
                            "Are you sure you want to reset to default values? " +
                            "This will overwrite any changes you have made."
                    );
                else
                    reset = true;
                if(reset) {
                    this.setEncapsulation('dbo');
                    this.setPrivacy('Ignore');
                    this.setDefaultIdentity('int');
                    this.setDefaultChronon('datetime2(7)');
                    this.setDefaultNow('sysdatetime()');
                    this.setDefaultChangingRange('datetime');
                    this.setMetadataPrefix('Metadata');
                    this.setDeletablePrefix('Deletable');
                    this.setDeletionSuffix('Deleted');
                    this.setMetadataType('int');
                    this.setEquivalentSuffix('EQ');
                    this.setEquivalentRange('tinyint');
                    this.setDeletability('false');
                    this.setRestatability('true');
                    this.setIdempotency('false');
                    this.setAssertiveness('true');
                    this.setMetadataUsage('true');
                    this.setBusinessViews('false');
                    this.setKnotAliases('false');
                    this.setTriggers('true');
                    this.setDecisiveness('true');
                    this.setEquivalence('false');
                    this.setChangingSuffix('ChangedAt');
                    this.setIdentitySuffix('ID');
                    this.setPositIdentityRange('int');
                    this.setPositingRange('datetime');
                    this.setPositingSuffix('PositedAt');
                    this.setPositorRange('tinyint');
                    this.setPositorSuffix('Positor');
                    this.setReliabilityRange('decimal(5,2)');
                    this.setReliabilitySuffix('Reliability');
                    this.setDefaultReliability('1');
                    this.setDeleteReliability('0');
                    this.setAssertionSuffix('Assertion');
                    this.setPartitioning('false');
                    this.setEntityIntegrity('true');
                    this.setTemporalization('uni');
                    this.setDeletability('false');
                    this.setEncryptionGroup('');
                    this.setDatabase('SQLServer', false);
                    this.setNaming('improved');
                    this.init();
                }
            },
            resetSettings: function(warn) {
                var reset = false;
                if(warn)
                    reset = confirm(
                            "Are you sure you want to reset to default values? " +
                            "This will overwrite any changes you have made."
                    );
                else
                    reset = true;
                if(reset) {
                    this.setDamping(4);
                    this.setLongRangeEffect(25);
                    this.setFuzziness(10);
                    this.setNormalDistance(30);
                    this.setStoppingVelocity(0.1);
                    this.setMinimumStartingVelocity(1);
                    this.setMaximumStartingVelocity(5);
                    this.setPartitionFactor(15);
                    this.setStiffness(1);
                    this.setMiniRate(50);
                    this.setCalculations('simple');
                    NodeType.mass[NodeType.KNOT] = 5;
                    NodeType.charge[NodeType.KNOT] = 1;
                    NodeType.mass[NodeType.ANCHOR] = 2;
                    NodeType.charge[NodeType.ANCHOR] = 1;
                    NodeType.mass[NodeType.ATTRIBUTE] = 3;
                    NodeType.charge[NodeType.ATTRIBUTE] = 1;
                    NodeType.mass[NodeType.TIE] = 5;
                    NodeType.charge[NodeType.TIE] = 1;
                    NodeType.mass[NodeType.EDGE] = 2;
                    NodeType.charge[NodeType.EDGE] = 4;
                    this.init();
                }
            },
            storeSettings: function(storage) {
                storage.setItem("version", VERSION);
                storage.setItem("damping", (1 - LayoutEngine.damping) * 100);
                storage.setItem("longRangeEffect", LayoutEngine.longRangeEffect * 100);
                storage.setItem("fuzziness", LayoutEngine.fuzziness * 100);
                storage.setItem("normalDistance", LayoutEngine.normalDistance);
                storage.setItem("stoppingVelocity", LayoutEngine.stoppingVelocity);
                storage.setItem("minimumStartingVelocity", LayoutEngine.minimumStartingVelocity);
                storage.setItem("maximumStartingVelocity", LayoutEngine.maximumStartingVelocity);
                storage.setItem("partitionFactor", LayoutEngine.partitionFactor);
                storage.setItem("stiffness", LayoutEngine.stiffness);
                storage.setItem("temporalization", Defaults.temporalization);
                storage.setItem("database", Defaults.databaseTarget);
                storage.setItem("miniatureFramesBetweenRefresh", DrawingEngine.miniatureFramesBetweenRefresh);
                storage.setItem("calculations", this.calculations);
                storage.setItem("encapsulation", Defaults.encapsulation);
                storage.setItem("privacy", Defaults.privacy);
                storage.setItem("defaultIdentity", Defaults.identity);
                storage.setItem("defaultChronon", Defaults.chronon);
                storage.setItem("defaultNow", Defaults.now);
                storage.setItem("defaultChangingRange", Defaults.changingRange);
                storage.setItem("deletablePrefix", Defaults.deletablePrefix);
                storage.setItem("deletionSuffix", Defaults.deletionSuffix);
                storage.setItem("metadataPrefix", Defaults.metadataPrefix);
                storage.setItem("metadataType", Defaults.metadataType);
                storage.setItem("equivalentSuffix", Defaults.equivalentSuffix);
                storage.setItem("equivalentRange", Defaults.equivalentRange);
                storage.setItem("metadataUsage", Defaults.metadataUsage);
                storage.setItem("businessViews", Defaults.businessViews);
                storage.setItem("triggers", Defaults.triggers);
                storage.setItem("decisiveness", Defaults.decisiveness);
                storage.setItem("equivalence", Defaults.equivalence);
                storage.setItem("deletability", Defaults.deletability);
                storage.setItem("restatability", Defaults.restatability);
                storage.setItem("idempotency", Defaults.idempotency);
                storage.setItem("assertiveness", Defaults.assertiveness);
                storage.setItem("changingSuffix", Defaults.changingSuffix);
                storage.setItem("identitySuffix", Defaults.identitySuffix);
                storage.setItem("positIdentity", Defaults.positIdentity);
                storage.setItem("positingRange", Defaults.positingRange);
                storage.setItem("positingSuffix", Defaults.positingSuffix);
                storage.setItem("positorRange", Defaults.positorRange);
                storage.setItem("positorSuffix", Defaults.positorSuffix);
                storage.setItem("checksumSuffix", Defaults.checksumSuffix);
                storage.setItem("reliabilityRange", Defaults.reliabilityRange);
                storage.setItem("reliabilitySuffix", Defaults.reliabilitySuffix);
                storage.setItem("defaultReliability", Defaults.defaultReliability);
                storage.setItem("deleteReliability", Defaults.deleteReliability);
                storage.setItem("encryptionGroup", Defaults.encryptionGroup);
                storage.setItem("assertionSuffix", Defaults.assertionSuffix);
                storage.setItem("partitioning", Defaults.partitioning);
                storage.setItem("entityIntegrity", Defaults.entityIntegrity);
                storage.setItem("naming", Defaults.naming);
                storage.setItem("knotMass", NodeType.mass[NodeType.KNOT]);
                storage.setItem("knotCharge", NodeType.charge[NodeType.KNOT]);
                storage.setItem("anchorMass", NodeType.mass[NodeType.ANCHOR]);
                storage.setItem("anchorCharge", NodeType.charge[NodeType.ANCHOR]);
                storage.setItem("attributeMass", NodeType.mass[NodeType.ATTRIBUTE]);
                storage.setItem("attributeCharge", NodeType.charge[NodeType.ATTRIBUTE]);
                storage.setItem("tieMass", NodeType.mass[NodeType.TIE]);
                storage.setItem("tieCharge", NodeType.charge[NodeType.TIE]);
                storage.setItem("edgeMass", NodeType.mass[NodeType.EDGE]);
                storage.setItem("edgeCharge", NodeType.charge[NodeType.EDGE]);
            },
            loadSettings: function(storage) {
                if(storage.getItem("version") != VERSION) {
                    this.resetDefaults(false);
                    this.resetSettings(false);
                }
                else {
                    this.setDamping(storage.getItem('damping') || 4);
                    this.setLongRangeEffect(storage.getItem('longRangeEffect') || 25);
                    this.setFuzziness(storage.getItem('fuzziness') || 10);
                    this.setNormalDistance(storage.getItem('normalDistance') || 30);
                    this.setStoppingVelocity(storage.getItem('stoppingVelocity') || 0.1);
                    this.setMinimumStartingVelocity(storage.getItem('minimumStartingVelocity') || 1);
                    this.setMaximumStartingVelocity(storage.getItem('maximumStartingVelocity') || 5);
                    this.setPartitionFactor(storage.getItem('partitionFactor') || 15);
                    this.setStiffness(storage.getItem('stiffness') || 1);
                    this.setDatabase(storage.getItem('database') || 'SQLServer', false);
                    this.setMiniRate(storage.getItem('miniatureFramesBetweenRefresh') || 50);
                    this.setCalculations(storage.getItem('calculations') || 'simple');
                    this.setEncapsulation(storage.getItem('encapsulation') || Defaults.encapsulation);
                    this.setPrivacy(storage.getItem('privacy') || Defaults.privacy);
                    this.setDefaultIdentity(storage.getItem('defaultIdentity') || Defaults.identity);
                    this.setDefaultChronon(storage.getItem('defaultChronon') || Defaults.chronon);
                    this.setDefaultNow(storage.getItem('defaultNow') || Defaults.now);
                    this.setDefaultChangingRange(storage.getItem('defaultChangingRange') || Defaults.changingRange);
                    this.setDeletablePrefix(storage.getItem('deletablePrefix') || Defaults.deletablePrefix);
                    this.setDeletionSuffix(storage.getItem('deletionSuffix') || Defaults.deletionSuffix);
                    this.setMetadataPrefix(storage.getItem('metadataPrefix') || Defaults.metadataPrefix);
                    this.setMetadataType(storage.getItem('metadataType') || Defaults.metadataType);
                    this.setEquivalentRange(storage.getItem('equivalentRange') || Defaults.equivalentRange);
                    this.setEquivalentSuffix(storage.getItem('equivalentSuffix') || Defaults.equivalentSuffix);
                    this.setMetadataUsage(storage.getItem('metadataUsage') || Defaults.metadataUsage);
                    this.setBusinessViews(storage.getItem('businessViews') || Defaults.businessViews);
                    this.setKnotAliases(storage.getItem('knotAliases') || Defaults.knotAliases);
                    this.setTriggers(storage.getItem('triggers') || Defaults.triggers);
                    this.setDecisiveness(storage.getItem('decisiveness') || Defaults.decisiveness);
                    this.setEquivalence(storage.getItem('equivalence') || Defaults.equivalence);
                    this.setChangingSuffix(storage.getItem('changingSuffix') || Defaults.changingSuffix);
                    this.setIdentitySuffix(storage.getItem('identitySuffix') || Defaults.identitySuffix);
                    this.setPositIdentityRange(storage.getItem('positIdentity') || Defaults.positIdentity);
                    this.setPositingRange(storage.getItem('positingRange') || Defaults.positingRange);
                    this.setPositingSuffix(storage.getItem('positingSuffix') || Defaults.positingSuffix);
                    this.setPositorRange(storage.getItem('positorRange') || Defaults.positorRange);
                    this.setPositorSuffix(storage.getItem('positorSuffix') || Defaults.positorSuffix);
                    this.setChecksumSuffix(storage.getItem('checksumSuffix') || Defaults.checksumSuffix);
                    this.setReliabilityRange(storage.getItem('reliabilityRange') || Defaults.reliabilityRange);
                    this.setReliabilitySuffix(storage.getItem('reliabilitySuffix') || Defaults.reliabilitySuffix);
                    this.setDefaultReliability(storage.getItem('defaultReliability') || Defaults.defaultReliability);
                    this.setDeleteReliability(storage.getItem('deleteReliability') || Defaults.deleteReliability);
                    this.setAssertionSuffix(storage.getItem('assertionSuffix') || Defaults.assertionSuffix);
                    this.setPartitioning(storage.getItem('partitioning') || Defaults.partitioning);
                    this.setEntityIntegrity(storage.getItem('entityIntegrity') || Defaults.entityIntegrity);
                    this.setDeletability(storage.getItem('deletability') || Defaults.deletability);
                    this.setEncryptionGroup(storage.getItem('encryptionGroup') || Defaults.encryptionGroup);
                    this.setRestatability(storage.getItem('restatability') || Defaults.restatability);
                    this.setIdempotency(storage.getItem('idempotency') || Defaults.idempotency);
                    this.setAssertiveness(storage.getItem('assertiveness') || Defaults.assertiveness);
                    this.setNaming(storage.getItem('naming') || Defaults.naming);
                    NodeType.mass[NodeType.KNOT] = 1 * storage.getItem('knotMass') || 5;
                    NodeType.charge[NodeType.KNOT] = 1 * storage.getItem('knotCharge') || 1;
                    NodeType.mass[NodeType.ANCHOR] = 1 * storage.getItem('anchorMass') || 2;
                    NodeType.charge[NodeType.ANCHOR] = 1 * storage.getItem('anchorCharge') || 1;
                    NodeType.mass[NodeType.ATTRIBUTE] = 1 * storage.getItem('attributeMass') || 3;
                    NodeType.charge[NodeType.ATTRIBUTE] = 1 * storage.getItem('attributeCharge') || 1;
                    NodeType.mass[NodeType.TIE] = 1 * storage.getItem('tieMass') || 5;
                    NodeType.charge[NodeType.TIE] = 1 * storage.getItem('tieCharge') || 1;
                    NodeType.mass[NodeType.EDGE] = 1 * storage.getItem('edgeMass') || 2;
                    NodeType.charge[NodeType.EDGE] = 1 * storage.getItem('edgeCharge') || 4;
                    // must be done after Defaults have been populated with previously stored values
                    this.setTemporalization(storage.getItem('temporalization') || 'uni');
                }
                this.init();
            },
            setPositIdentityRange: function(value) {
                Defaults.positIdentity = value;
            },
            setPositingRange: function(value) {
                Defaults.positingRange = value;
            },
            setPositingSuffix: function(value) {
                Defaults.positingSuffix = value;
            },
            setPositorRange: function(value) {
                Defaults.positorRange = value;
            },
            setPositorSuffix: function(value) {
                Defaults.positorSuffix = value;
            },
            setChecksumSuffix: function(value) {
                Defaults.checksumSuffix = value;
            },
            setReliabilityRange: function(value) {
                Defaults.reliabilityRange = value;
            },
            setReliabilitySuffix: function(value) {
                Defaults.reliabilitySuffix = value;
            },
            setDefaultReliability: function(value) {
                Defaults.defaultReliability = value;
            },
            setDeleteReliability: function(value) {
                Defaults.deleteReliability = value;
            },
            setEncryptionGroup: function(value) {
                Defaults.encryptionGroup = value;
            },
            setAssertionSuffix: function(value) {
                Defaults.assertionSuffix = value;
            },
            setPartitioning: function(value) {
                Defaults.partitioning = value;
            },
            setEntityIntegrity: function(value) {
                Defaults.entityIntegrity = value;
            },
            setNaming: function(value) {
                Defaults.naming = value;
            },
            addTextItem: function(item, destination, before, label, title, listener) {
                if(!this[item]) {
                    this[item] = {
                        container: document.createElement('li'),
                        input: document.createElement('input')
                    };
                    this[item].input.setAttribute('type', 'text');
                    this[item].input.setAttribute('class', 'inputDefaults');
                    this[item].input.addEventListener('blur', listener, false);
                    this[item].input.value = Defaults[item];
                    this[item].container.setAttribute('title', title);
                    this[item].container.appendChild(this[item].input);
                    this[item].container.appendChild(document.createTextNode(label));
                    destination.insertBefore(this[item].container, before);
                }
                else // update values in case settings have changed
                    this[item].input.value = Defaults[item];
            },
            addBoolItem: function(item, destination, before, label, title, listener) {
                if(!this[item]) {
                    this[item] = {
                        container: document.createElement('li'),
                        input: document.createElement('input')
                    };
                    this[item].input.setAttribute('type', 'checkbox');
                    this[item].input.setAttribute('class', 'inputDefaults');
                    this[item].input.addEventListener('change', listener, false);
                    this[item].input.checked = Defaults[item] === 'true';
                    this[item].container.setAttribute('title', title);
                    this[item].container.appendChild(this[item].input);
                    this[item].container.appendChild(document.createTextNode(label));
                    destination.insertBefore(this[item].container, before);
                }
                else // update values in case settings have changed
                    this[item].input.checked = Defaults[item] === 'true';
            },
            removeItem: function(item, from) {
                if(this[item]) {
                    this[item].container.removeChild(this[item].input);
                    from.removeChild(this[item].container);
                    this[item] = null;
                }
            },
            setTemporalization: function(value) {
                Defaults.temporalization = value;
                var temporalizationSelect = document.getElementById('temporalization');
                temporalizationSelect.value = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('crtSettingsBeforeHere');
                if(value === 'crt' || value === 'bi') {
                    this.addTextItem(
                            'positIdentity', listOfDefaults, beforeItem, ' Posit identity',
                            "The 'data type' for identities of posits used throughout the implementation.",
                            function() { Settings.setPositIdentityRange(this.value); }
                    );
                    this.addTextItem(
                            'positingRange', listOfDefaults, beforeItem, ' Positing time range',
                            "The positing time (corrections) 'data type' used throughout the implementation.",
                            function() { Settings.setPositingRange(this.value); }
                    );
                    this.addTextItem(
                            'positingSuffix', listOfDefaults, beforeItem, ' Positing time suffix',
                            "The suffix used for the column storing the point in time a posit was made.",
                            function() { Settings.setPositingSuffix(this.value); }
                    );
                    if(value === 'crt') {
                        this.addTextItem(
                                'positorRange', listOfDefaults, beforeItem, ' Positor range',
                                "The positor (one able to correct) 'data type' used throughout the implementation.",
                                function() { Settings.setPositorRange(this.value); }
                        );
                        this.addTextItem(
                                'positorSuffix', listOfDefaults, beforeItem, ' Positor suffix',
                                "The suffix used for the column storing the who made a posit.",
                                function() { Settings.setPositorSuffix(this.value); }
                        );
                    }
                    this.addTextItem(
                            'reliabilityRange', listOfDefaults, beforeItem, ' Reliability range',
                            "A 'data type' that can hold the desired degrees of reliability.",
                            function() { Settings.setReliabilityRange(this.value); }
                    );
                    this.addTextItem(
                            'reliabilitySuffix', listOfDefaults, beforeItem, ' Reliability suffix',
                            "The suffix used for the column storing reliability.",
                            function() { Settings.setReliabilitySuffix(this.value); }
                    );
                    if(value === 'crt') {
                        this.addTextItem(
                                'defaultReliability', listOfDefaults, beforeItem, ' Default reliability',
                                "The default value of reliability to use when it is not specified in an insert.",
                                function() { Settings.setDefaultReliabilty(this.value); }
                        );
                        this.addTextItem(
                                'deleteReliability', listOfDefaults, beforeItem, ' Complete uncertainty',
                                "The default value of reliability to use when deleting information, " +
                                "which corresponds to being completely uncertain about a posit.",
                                function() { Settings.setDeleteReliabilty(this.value); }
                        );
                    }
                    this.addTextItem(
                            'assertionSuffix', listOfDefaults, beforeItem, ' Assertion suffix',
                            "The suffix used for the computed column storing a single character '+', '-', or '?'," +
                            "indicating whether an assertion is positive, negative, or completely uncertain.",
                            function() { Settings.setAssertionSuffix(this.value); }
                    );
                    this.addBoolItem(
                            'assertiveness', listOfDefaults, beforeItem, ' Assertiveness',
                            "Default for new items. Assertive items get new annex rows every time a posit " +
                            "is made with a different positing time. Non-assertive items must also have a " +
                            "different reliability.",
                            function() { Settings.setAssertiveness(this.checked ? 'true' : 'false'); }
                    );
                    Editables.setEditability(Editables.positIdentityEdit, true);
                    Editables.setEditability(Editables.positGeneratorEdit, true);
                    Editables.setEditability(Editables.assertivenessEdit, true);
                }
                else {
                    this.removeItem('positIdentity', listOfDefaults);
                    this.removeItem('positingRange', listOfDefaults);
                    this.removeItem('positingSuffix', listOfDefaults);
                    this.removeItem('positorRange', listOfDefaults);
                    this.removeItem('positorSuffix', listOfDefaults);
                    this.removeItem('reliabilityRange', listOfDefaults);
                    this.removeItem('reliabilitySuffix', listOfDefaults);
                    this.removeItem('defaultReliability', listOfDefaults);
                    this.removeItem('deleteReliability', listOfDefaults);
                    this.removeItem('assertionSuffix', listOfDefaults);
                    this.removeItem('assertiveness', listOfDefaults);
                    Editables.setEditability(Editables.positIdentityEdit, false);
                    Editables.setEditability(Editables.positGeneratorEdit, false);
                    Editables.setEditability(Editables.assertivenessEdit, false);
                }
            },
            setDeletablePrefix: function(value) {
                Defaults.deletablePrefix = value;
            },
            setDeletionSuffix: function(value) {
                Defaults.deletionSuffix = value;
            },
            setMetadataPrefix: function(value) {
                Defaults.metadataPrefix = value;
            },
            setMetadataType: function(value) {
                Defaults.metadataType = value;
            },
            setEquivalentSuffix: function(value) {
                Defaults.equivalentSuffix = value;
            },
            setEquivalentRange: function(value) {
                Defaults.equivalentRange = value;
            },
            setMetadataUsage: function(value) {
                Defaults.metadataUsage = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('metadataSettingsBeforeHere');
                if(value === 'true') {
                    this.addTextItem(
                            'metadataPrefix', listOfDefaults, beforeItem, ' Metadata prefix',
                            "The prefix used for the columns that store a metadata reference.",
                            function() { Settings.setMetadataPrefix(this.value); }
                    );
                    this.addTextItem(
                            'metadataType', listOfDefaults, beforeItem, ' Metadata type',
                            "The 'data type' of the metadata column.",
                            function() { Settings.setMetadataType(this.value); }
                    );
                }
                else {
                    this.removeItem('metadataPrefix', listOfDefaults);
                    this.removeItem('metadataType', listOfDefaults);
                }
            },
            setBusinessViews: function(value, userToggle) {
                Defaults.businessViews = value;
                if(userToggle && value === 'true')
                    alert(
                            "Please note that when business views are used " +
                            "descriptors must follow the same rules of uniqueness as mnemonics do, " +
                            "otherwise naming clashes may occur."
                    );
            },
            setKnotAliases: function(value, userToggle) {
                Defaults.knotAliases = value;
                if(userToggle && value === 'true')
                    alert(
                            "Please note that knot aliases will create aliases for knot values " +
                            "in the views that mimic the naming of regular attributes, " +
                            "making them semantically indistinguishable from non-knotted attributes."
                    );
            },
            setTriggers: function(value, userToggle) {
                Defaults.triggers = value;
                if(userToggle && value === 'false')
                    alert(
                            "Please note that turning off triggers will leave " +
                            "more implementation details to the ETL or API using the model, " +
                            "and the views will no longer accept inserts and updates."
                    );
            },
            setDecisiveness: function(value) {
                Defaults.decisiveness = value;
            },
            setEquivalence: function(value) {
                Defaults.equivalence = value;
                var listOfDefaults = document.getElementById('listOfDefaults');
                var beforeItem = document.getElementById('metadataSettingsBeforeHere');
                if(value === 'true') {
                    this.addTextItem(
                            'equivalentSuffix', listOfDefaults, beforeItem, ' Equivalents suffix',
                            "The suffix used for the columns that store equivalents.",
                            function() { Settings.setEquivalentSuffix(this.value); }
                    );
                    this.addTextItem(
                            'equivalentRange', listOfDefaults, beforeItem, ' Equivalents range',
                            "The 'data type' of the equivalents column.",
                            function() { Settings.setEquivalentRange(this.value); }
                    );
                    Editables.setEditability(Editables.equivalenceEdit, true);
                }
                else {
                    this.removeItem('equivalentSuffix', listOfDefaults);
                    this.removeItem('equivalentRange', listOfDefaults);
                    Editables.setEditability(Editables.equivalenceEdit, false);
                }
            },
            setDeletability: function(value) {
                Defaults.deletability = value;
            },
            setRestatability: function(value) {
                Defaults.restatability = value;
            },
            setIdempotency: function(value) {
                Defaults.idempotency = value;
            },
            setAssertiveness: function(value) {
                Defaults.assertiveness = value;
            },
            setChangingSuffix: function(value) {
                Defaults.changingSuffix = value;
            },
            setIdentitySuffix: function(value) {
                Defaults.identitySuffix = value;
            },
            setEncapsulation: function(value) {
                Defaults.encapsulation = value;
            },
            setPrivacy: function(value) {
                Defaults.privacy = value;
            },
            setDefaultIdentity: function(value) {
                Defaults.identity = value;
            },
            setDefaultChronon: function(value) {
                Defaults.chronon = value;
            },
            setDefaultNow: function(value) {
                Defaults.now = value;
            },
            setDefaultChangingRange: function(value) {
                Defaults.changingRange = value;
            },
            setDamping: function(value) {
                LayoutEngine.damping = (100 - value)/100;
                LayoutEngine.init();
            },
            setLongRangeEffect: function(value) {
                LayoutEngine.longRangeEffect = value/100;
                LayoutEngine.init();
            },
            setFuzziness: function(value) {
                LayoutEngine.fuzziness = value/100;
                LayoutEngine.init();
            },
            setNormalDistance: function(value) {
                LayoutEngine.normalDistance = 1 * value;
                LayoutEngine.init();
            },
            setStoppingVelocity: function(value) {
                LayoutEngine.stoppingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMinimumStartingVelocity: function(value) {
                LayoutEngine.minimumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setMaximumStartingVelocity: function(value) {
                LayoutEngine.maximumStartingVelocity = 1 * value;
                LayoutEngine.init();
            },
            setPartitionFactor: function(value) {
                LayoutEngine.partitionFactor = 1 * value;
                LayoutEngine.init();
            },
            setStiffness: function(value) {
                LayoutEngine.stiffness = 1 * value;
                LayoutEngine.init();
            },
            setDatabase: function(value, convert) {
                if(convert && confirm("Would you like to convert data types to " + value + "?")) {
                    var original = Defaults.databaseTarget;
                    Defaults.databaseTarget = value;
                    var xml = DataTypeConverter.convert(Model.toXML(false), original, value);
                    Model.fromXML(xml);
                }
                Defaults.databaseTarget = value;
            },
            setMiniRate: function(value) {
                DrawingEngine.miniatureFramesBetweenRefresh = 1 * value;
            },
            toggleDebug: function () {
                DEBUG = !DEBUG;
                if(DEBUG) {
                    SVGLayer.show('debugPartitions');
                    SVGLayer.show('debug');
                }
                else {
                    SVGLayer.hide('debug');
                    SVGLayer.hide('debugPartitions');
                }
                DrawingEngine.start(false);
            },
            knotMass: null,
            knotCharge: null,
            anchorMass: null,
            anchorCharge: null,
            attributeMass: null,
            attributeCharge: null,
            tieMass: null,
            tieCharge: null,
            edgeMass: null,
            edgeCharge: null,
            setCalculations: function(value) {
                var listOfSettings = document.getElementById('listOfSettings');
                var calcsItem = document.getElementById('calcsItem');
                if(value === 'simple') {
                    LayoutEngine.layout = LayoutEngine.simpleLayout;
                    if(this.knotMass) listOfSettings.removeChild(this.knotMass);
                    if(this.knotCharge) listOfSettings.removeChild(this.knotCharge);
                    if(this.anchorMass) listOfSettings.removeChild(this.anchorMass);
                    if(this.anchorCharge) listOfSettings.removeChild(this.anchorCharge);
                    if(this.attributeMass) listOfSettings.removeChild(this.attributeMass);
                    if(this.attributeCharge) listOfSettings.removeChild(this.attributeCharge);
                    if(this.tieMass) listOfSettings.removeChild(this.tieMass);
                    if(this.tieCharge) listOfSettings.removeChild(this.tieCharge);
                    if(this.edgeMass) listOfSettings.removeChild(this.edgeMass);
                    if(this.edgeCharge) listOfSettings.removeChild(this.edgeCharge);
                    this.knotMass = null;
                    this.knotCharge = null;
                    this.anchorMass = null;
                    this.anchorCharge = null;
                    this.attributeMass = null;
                    this.attributeCharge = null;
                    this.tieMass = null;
                    this.tieCharge = null;
                    this.edgeMass = null;
                    this.edgeCharge = null;
                }
                else if (value === 'complex') {
                    LayoutEngine.layout = LayoutEngine.complexLayout;
                    this.knotMass = document.createElement('li');
                    this.knotCharge = document.createElement('li');
                    this.anchorMass = document.createElement('li');
                    this.anchorCharge = document.createElement('li');
                    this.attributeMass = document.createElement('li');
                    this.attributeCharge = document.createElement('li');
                    this.tieMass = document.createElement('li');
                    this.tieCharge = document.createElement('li');
                    this.edgeMass = document.createElement('li');
                    this.edgeCharge = document.createElement('li');
                    var knotMassInput = document.createElement('input');
                    var knotChargeInput = document.createElement('input');
                    var anchorMassInput = document.createElement('input');
                    var anchorChargeInput = document.createElement('input');
                    var attributeMassInput = document.createElement('input');
                    var attributeChargeInput = document.createElement('input');
                    var tieMassInput = document.createElement('input');
                    var tieChargeInput = document.createElement('input');
                    var edgeMassInput = document.createElement('input');
                    var edgeChargeInput = document.createElement('input');
                    knotMassInput.setAttribute('type', 'number');
                    knotChargeInput.setAttribute('type', 'number');
                    anchorMassInput.setAttribute('type', 'number');
                    anchorChargeInput.setAttribute('type', 'number');
                    attributeMassInput.setAttribute('type', 'number');
                    attributeChargeInput.setAttribute('type', 'number');
                    tieMassInput.setAttribute('type', 'number');
                    tieChargeInput.setAttribute('type', 'number');
                    edgeMassInput.setAttribute('type', 'number');
                    edgeChargeInput.setAttribute('type', 'number');
                    knotMassInput.setAttribute('step', '0.1');
                    knotChargeInput.setAttribute('step', '0.1');
                    anchorMassInput.setAttribute('step', '0.1');
                    anchorChargeInput.setAttribute('step', '0.1');
                    attributeMassInput.setAttribute('step', '0.1');
                    attributeChargeInput.setAttribute('step', '0.1');
                    tieMassInput.setAttribute('step', '0.1');
                    tieChargeInput.setAttribute('step', '0.1');
                    edgeMassInput.setAttribute('step', '0.1');
                    edgeChargeInput.setAttribute('step', '0.1');
                    knotMassInput.value = NodeType.mass[NodeType.KNOT];
                    knotChargeInput.value = NodeType.charge[NodeType.KNOT];
                    anchorMassInput.value = NodeType.mass[NodeType.ANCHOR];
                    anchorChargeInput.value = NodeType.charge[NodeType.ANCHOR];
                    attributeMassInput.value = NodeType.mass[NodeType.ATTRIBUTE];
                    attributeChargeInput.value = NodeType.charge[NodeType.ATTRIBUTE];
                    tieMassInput.value = NodeType.mass[NodeType.TIE];
                    tieChargeInput.value = NodeType.charge[NodeType.TIE];
                    edgeMassInput.value = NodeType.mass[NodeType.EDGE];
                    edgeChargeInput.value = NodeType.charge[NodeType.EDGE];
                    knotMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.KNOT] = 1 * this.value; }, false);
                    knotChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.KNOT] = 1 * this.value; }, false);
                    anchorMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.ANCHOR] = 1 * this.value; }, false);
                    anchorChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.ANCHOR] = 1 * this.value; }, false);
                    attributeMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.ATTRIBUTE] = 1 * this.value; }, false);
                    attributeChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.ATTRIBUTE] = 1 * this.value; }, false);
                    tieMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.TIE] = 1 * this.value; }, false);
                    tieChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.TIE] = 1 * this.value; }, false);
                    edgeMassInput.addEventListener('blur', function() { NodeType.mass[NodeType.EDGE] = 1 * this.value; }, false);
                    edgeChargeInput.addEventListener('blur', function() { NodeType.charge[NodeType.EDGE] = 1 * this.value; }, false);
                    this.knotMass.appendChild(knotMassInput);
                    this.knotCharge.appendChild(knotChargeInput);
                    this.anchorMass.appendChild(anchorMassInput);
                    this.anchorCharge.appendChild(anchorChargeInput);
                    this.attributeMass.appendChild(attributeMassInput);
                    this.attributeCharge.appendChild(attributeChargeInput);
                    this.tieMass.appendChild(tieMassInput);
                    this.tieCharge.appendChild(tieChargeInput);
                    this.edgeMass.appendChild(edgeMassInput);
                    this.edgeCharge.appendChild(edgeChargeInput);
                    this.knotMass.appendChild(document.createTextNode(' Knot mass'));
                    this.knotCharge.appendChild(document.createTextNode(' Knot charge'));
                    this.anchorMass.appendChild(document.createTextNode(' Anchor mass'));
                    this.anchorCharge.appendChild(document.createTextNode(' Anchor charge'));
                    this.attributeMass.appendChild(document.createTextNode(' Attribute mass'));
                    this.attributeCharge.appendChild(document.createTextNode(' Attribute charge'));
                    this.tieMass.appendChild(document.createTextNode(' Tie mass'));
                    this.tieCharge.appendChild(document.createTextNode(' Tie charge'));
                    this.edgeMass.appendChild(document.createTextNode(' Edge mass'));
                    this.edgeCharge.appendChild(document.createTextNode(' Edge charge'));
                    listOfSettings.insertBefore(this.edgeCharge, calcsItem);
                    listOfSettings.insertBefore(this.edgeMass, calcsItem);
                    listOfSettings.insertBefore(this.tieCharge, calcsItem);
                    listOfSettings.insertBefore(this.tieMass, calcsItem);
                    listOfSettings.insertBefore(this.attributeCharge, calcsItem);
                    listOfSettings.insertBefore(this.attributeMass, calcsItem);
                    listOfSettings.insertBefore(this.anchorCharge, calcsItem);
                    listOfSettings.insertBefore(this.anchorMass, calcsItem);
                    listOfSettings.insertBefore(this.knotCharge, calcsItem);
                    listOfSettings.insertBefore(this.knotMass, calcsItem);
                }
            }
        };

        var ControlButtons = {
            playPauseButton: null,
            nudgeButton: null,
            undoButton: null,
            redoButton: null,
            zoomInButton: null,
            zoomOutButton: null,
            zoomFactor: 1.75,
            init: function() {
                this.playPauseButton = document.getElementById('playpause');
                this.undoButton = document.getElementById('undo');
                this.redoButton = document.getElementById('redo');
                this.zoomInButton = document.getElementById('zoomin');
                this.zoomOutButton = document.getElementById('zoomout');

                // rebinding
                this.togglePlayPause = this.togglePlayPause.bind(this);
                this.undo = this.undo.bind(this);
                this.redo = this.redo.bind(this);
                this.zoomIn = this.zoomIn.bind(this);
                this.zoomOut = this.zoomOut.bind(this);

                this.playPauseButton.addEventListener('click', this.togglePlayPause, false);
                this.undoButton.addEventListener('click', this.undo, false);
                this.redoButton.addEventListener('click', this.redo, false);
                this.zoomInButton.addEventListener('click', this.zoomIn, false);
                this.zoomOutButton.addEventListener('click', this.zoomOut, false);
                this.playing = false;
            },
            togglePlayPause: function (event) {
                if(DrawingEngine.running) {
                    DrawingEngine.stop();
                    this.setPlayState();
                }
                else {
                    if (LayoutEngine.equilibrium) {
                        this.invalidateLayout();
                    }
                    DrawingEngine.start(true);
                    this.setPauseState();
                }
            },
            setUndoLevels: function(numberOfLevels) {
                var undos = '';
                if(numberOfLevels)
                    undos = ' (' + numberOfLevels + ')';
                this.undoButton.firstChild.nodeValue = 'Undo' + undos;
            },
            setRedoLevels: function(numberOfLevels) {
                var redos = '';
                if(numberOfLevels)
                    redos = ' (' + numberOfLevels + ')';
                this.redoButton.firstChild.nodeValue = 'Redo' + redos;
            },
            undo: function() {
                Model.undoState();
                DrawingEngine.start(false);
            },
            redo: function() {
                Model.redoState();
                DrawingEngine.start(false);
            },
            setPlayState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Play';
                this.playPauseButton.className = 'pausing';
            },
            setPauseState: function() {
                this.playPauseButton.firstChild.nodeValue = 'Pause';
                this.playPauseButton.className = 'playing';
            },
            invalidateLayout: function () {
                for(var i = 0; i < Model.visibleNodes.length; i++) {
                    Model.visibleNodes[i].start();
                }
            },
            doZoom: function (zoom) {
                var w = SVG.viewBox.baseVal.width;
                var h = SVG.viewBox.baseVal.height;
                var dx = w * (1-zoom)/2;
                var dy = h * (1-zoom)/2;
                SVG.viewBox.baseVal.x += dx;
                SVG.viewBox.baseVal.y += dy;
                SVG.viewBox.baseVal.width = w * zoom;
                SVG.viewBox.baseVal.height = h * zoom;
                DrawingEngine.start(false);
            },
            zoomIn: function (event) {
                this.doZoom(1/this.zoomFactor);
            },
            zoomOut: function (event) {
                this.doZoom(this.zoomFactor);
            }
        };

        function Layer(graph) {
            this.graph = graph;
            this.layers = [];
        }
        Layer.prototype = {
            graph: null,
            layers: null,
            addLayer: function(name) {
                var layer = document.createElementNS(SVGNS, 'g');
                layer.setAttributeNS(null, 'id', name);
                this.graph.appendChild(layer);
                this.layers.push(name);
                this[name] = layer;
            },
            show: function(name) {
                var after;
                for(var i = this.layers.indexOf(name) + 1; i < this.layers.length; i++) {
                    after = this.layers[i];
                    if(this.isShowing(after))
                        break;
                }
                if(i < this.layers.length) {
                    this.graph.insertBefore(this[name], this[after]);
                }
                else {
                    this.graph.appendChild(this[name]);
                }
            },
            isShowing: function(name) {
                return this.graph.contains(this[name]);
            },
            hide: function(name) {
                if(this.isShowing(name))
                    this.graph.removeChild(this[name]);
            },
            clear: function(name) {
                var layer = this[name];
                while(layer.firstChild) {
                    layer.removeChild(layer.firstChild);
                }
            },
            clearAll: function() {
                var l = this.layers.length;
                while(l--) {
                    this.clear(this.layers[l]);
                }
            }
        };

        // make sure our init function is called when the page is loaded
        window.onload = function() {
            init(this);
        };

        // implementation of our init function
        function init(window) {
            // another disclaimer for the testing versions
            if(!RELEASE) {
                alert(
                    '----------- DISCLAIMER -----------\n' +
                    'Please note that this is a test version.\n' +
                    'It should not be used for production \n' +
                    'work. Report bugs found in our issue \n' +
                    'tracking system, to which a link can \n' +
                    'be found under the Help/About menu.\n' +
                    '----------- DISCLAIMER -----------'
                );
                document.getElementById("disclaimer").style.display = "block";
            }
            // set values in the settings and defaults input fields
            Settings.loadSettings(window.localStorage);

            // find any parameters passed in the url
            var gets = window.location.search.substring(1);
            var pair, pairs = gets.split('&');
            for(var i = 0; pair = pairs[i]; i++) {
              pair = pairs[i].split('=');
              PARAMETERS[pair[0]] = pair[1];
            }

            // assign event handlers to buttons
            ControlButtons.init();
            LayoutEngine.init();

            // set the global svg and graph variable
            SVG = document.getElementById("graph");
            SVG.viewBox.baseVal.x = 0;
            SVG.viewBox.baseVal.y = 0;
            SVG.viewBox.baseVal.width = window.innerWidth;
            SVG.viewBox.baseVal.height = window.innerHeight;

            // add layers to the SVG
            SVGLayer = new Layer(SVG);
            SVGLayer.addLayer('debugPartitions');
            SVGLayer.addLayer('debug');
            SVGLayer.addLayer('keys');
            SVGLayer.addLayer('edges');
            SVGLayer.addLayer('nodes');
            SVGLayer.addLayer('names');
            // SVGLayer.hide('names');
            SVGLayer.hide('debug');
            SVGLayer.hide('debugPartitions');

            // some inherited properties
            SVGLayer.edges.style.stroke = '#000';
            SVGLayer.edges.style.strokeWidth = '1px';
            SVGLayer.edges.style.fill = 'none';
            SVGLayer.debug.style.stroke = '#fcc';
            SVGLayer.debug.style.strokeWidth = '7px';
            SVGLayer.debug.style.strokeLinecap = 'round';
            SVGLayer.debugPartitions.style.fill = '#fff8f8';
            SVGLayer.debugPartitions.style.stroke = '#f4ebeb';
            SVGLayer.debugPartitions.style.strokeWidth = LayoutEngine.fuzz;
            SVGLayer.names.setAttributeNS(null, 'class', 'label');

            // set up "global" event handlers
            SVG.addEventListener('wheel', EventHandler.zoom, false);
            SVG.addEventListener('mousedown', EventHandler.preparePanning, false);

            // set up the miniature navigation
            NAV = document.getElementById("minigraph");
            NAV.addEventListener('mousedown', EventHandler.prepareNavigation, false);

            // add layers to the NAV
            NAVLayer = new Layer(NAV);
            NAVLayer.addLayer('edges');
            NAVLayer.addLayer('nodes');
            NAVLayer.addLayer('viewport');

            // some inherited properties
            NAVLayer.edges.style.stroke = '#000';
            NAVLayer.edges.style.strokeWidth = '1px';
            NAVLayer.edges.style.fill = 'none';

            DrawingEngine.init();
            // load previous scale and transform
            DrawingEngine.loadSettings(window.localStorage);

            // handle resizing
            window.addEventListener('resize', EventHandler.resize, false);
            // handle the escape button
            window.addEventListener('keypress', EventHandler.escape, false);

            // load url or previous model, if any
            var model;
            if(PARAMETERS.gist) {
                Actions.loadModelFromGist(PARAMETERS.gist);
            }
            /*
            if(PARAMETERS.id) {
                Actions.loadModelFromCloud(PARAMETERS.id, null, 'public', null, null);
            }
            */
            else if(model = window.localStorage.getItem("model")) {
                Model.fromXML(new DOMParser().parseFromString(model, 'text/xml'));
                Model.id = window.localStorage.getItem("modelId");
                Model.name = window.localStorage.getItem("modelName");
                Model.scope = window.localStorage.getItem("modelScope");
                Model.keywords = window.localStorage.getItem("modelKeywords");
                Model.description = window.localStorage.getItem("modelDescription");
            }
            else
                Actions.loadFromURL('example.xml');

            // all cloud stuff will have to be rewritten (no longer using Google Cloud)
            //Actions.checkCloudConnectionStatus(false);

            // start the engine and let's go
            DrawingEngine.start(true);
        }

        // make sure our exit function is called when the page is unloaded
        window.onbeforeunload = function() {
            if(ASKBEFOREUNLOAD)
                return "Are you absolutely sure you want to leave?\nAny unsaved changes will be lost!";
            else
                ASKBEFOREUNLOAD = true;
        };

        window.onunload = function() {
            save(this, false);
        };

        function save(window, popup) {
            window.localStorage.clear();
            var xml = new XMLSerializer().serializeToString(Model.toXML(false));
            if(xml)
                window.localStorage.setItem("model", xml);
            if(Model.id)
                window.localStorage.setItem("modelId", Model.id);
            if(Model.name)
                window.localStorage.setItem("modelName", Model.name);
            if(Model.scope)
                window.localStorage.setItem("modelScope", Model.scope);
            if(Model.keywords)
                window.localStorage.setItem("modelKeywords", Model.keywords);
            if(Model.description)
                window.localStorage.setItem("modelDescription", Model.description);
            Settings.storeSettings(window.localStorage);
            DrawingEngine.storeSettings(window.localStorage);
            if(popup)
                alert("The model and settings are now saved in the browser cache.");
        }

        // -->
    </script>
</head>
<body>
    <svg id="graph"
         class="unselectable"
         xmlns="http://www.w3.org/2000/svg"
         version="1.1"
         viewBox="0 0 1 1"
         xmlns:xlink="http://www.w3.org/1999/xlink">
        <defs id="graphics">
            <marker id="arrowhead"
                    viewBox="0 0 10 10" refX="0" refY="5"
                    markerUnits="strokeWidth"
                    markerWidth="4" markerHeight="3"
                    orient="auto" fill="#fcc">
                <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
            <style type="text/css">
                .label {
                    font-size:          8pt;
                    font-family:        "Open Sans", "Verdana", "Helvetica Neue", sans-serif;
                    font-weight:        normal;
                    text-anchor:        left;
                    dominant-baseline:  middle;
                    fill:               #000;
                    pointer-events:     none;
                }
                .edge {
                    pointer-events:     none;
                }
                .anchor {
                    font-style:         italic;
                    font-weight:        bold;
                    stroke:             none;
                    fill:               #c80514;
                    pointer-events:     none;
                }
                .role {
                    font-style:         italic;
                    stroke:             none;
                    fill:               #000;
                    pointer-events:     none;
                }
                .route {
                    fill:               none;
                    stroke:             rgba(42, 0, 0, 0.07);
                    stroke-width:       32;
                    stroke-linecap:     round;
                    stroke-linejoin:    round;
                }
                .routeSelected {
                    fill:               none;
                    stroke:             rgba(242, 101, 101, 0.2);
                    stroke-width:       42;
                    stroke-linecap:     round;
                    stroke-linejoin:    round;
                }
                .routeText {
                    font-family:        "Impact", "Haettenschweiler", "Franklin Gothic Bold", "Charcoal", "Helvetica Inserat", "Bitstream Vera Sans Bold", "Arial Black", sans-serif;
                    font-size:          20pt;
                    font-weight:        normal;
                    fill:               white;
                    dominant-baseline:  middle;
                    pointer-events:     none;
                }
                .bad {
                    fill:               #e00;
                }
                .end {
                    text-anchor:        end;
                }
            </style>
            <g id="knot" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <rect width="20" height="20" rx="5" ry="5" transform="translate(-10, -10)"/>
            </g>
            <g id="stream" style="fill:#b55;">
                <rect width="30" height="30" transform="translate(-15, -15)"/>
                <rect width="14" height="14" transform="rotate(45) translate(-7, -7)" style="fill:#fff;"/>
            </g>
            <g id="anchor" style="fill:#b55;">
                <rect width="20" height="20" transform="translate(-10, -10)"/>
            </g>
            <g id="anchor_imploded" style="fill:#633;">
                <path d="M 0 0 Q 12 4 24 0 Q 20 12 24 24 Q 12 20 0 24 Q 4 12 0 0" transform="translate(-12, -12)"/>
            </g>
            <g id="tie" style="fill:#a8a8a8;">
                <rect width="20" height="20" transform="rotate(45) translate(-10, -10)"/>
            </g>
            <g id="tie_historized">
                <rect width="22" height="22" transform="rotate(45) translate(-11, -11)" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;"/>
                <rect width="14" height="14" transform="rotate(45) translate(-7, -7)" style="fill:#a8a8a8;"/>
            </g>
            <g id="attribute" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <circle r="10"/>
            </g>
            <g id="attribute_historized" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                <circle r="12"/>
                <circle r="7"/>
            </g>
            <g id="identifier" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;">
                <circle r="13"/>
                <g style="fill:#a8a8a8; stroke-width:0px;">
                    <circle r="2.5" transform="translate(0, -3)"/>
                    <polygon points="0,-2 -2,5 2,5" style="stroke-width:1px; stroke-linejoin:round; stroke-linecap:round;"/>
                </g>
        </g>
            <g id="identifier_historized" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;">
                <circle r="16"/>
                <circle r="11"/>
                <g style="fill:#a8a8a8; stroke-width:0px;">
                    <circle r="2.5" transform="translate(0, -3)"/>
                    <polygon points="0,-2 -2,5 2,5" style="stroke-width:1px; stroke-linejoin:round; stroke-linecap:round;"/>
                </g>
        </g>
            <g id="highlight" style="stroke:#ede5e5; stroke-width:10px; fill:#fff;">
                <circle r="30"/>
            </g>
            <g id="selection" style="fill:#ede5e5;">
                <circle r="30"/>
                <circle r="30" style="stroke:#000; stroke-width:1px;"/>
            </g>
            <g id="fixation" style="fill:#000;">
                <circle r="1.5"/>
            </g>
            <g id="bubble" style="fill:#f9f8f7; stroke:none;">
                <circle r="8"/>
            </g>
            <g id="one" style="stroke:#544; stroke-width:1px;">
                <line x1="0" y1="-3" x2="0" y2="3"/>
            </g>
            <g id="many" style="stroke:#544; stroke-width:1px;">
                <line x1="-3" y1="-3" x2="3" y2="-3"/>
                <line x1="-3" y1="0" x2="3" y2="0"/>
                <line x1="-3" y1="3" x2="3" y2="3"/>
            </g>
        </defs>
        <!-- layers are appended here -->
    </svg>

    <div id="disclaimer" class="unselectable">
        TEST<br/>
        VERSION<br/>
        <script type="text/javascript">
            document.write(VERSION);
        </script>
    </div>

    <div id="header" class="unselectable">
        <div id="file" class="menu">File
            <ul class="submenu">
                <li title="Discards the current model and starts a new model with a minimal setup, a single anchor." onclick="Model.setupMinimal(true)">New model...</li>
                <!--
                <li title="Load a publicly stored model from the Google Cloud connection." onclick="Actions.listModelsInCloud('public')">Load public model from cloud...</li>
                <li title="Load a privately stored model from the Google Cloud connection. Requires that you log in to your Google account." onclick="Actions.listModelsInCloud('private')">Load private model from cloud...</li>
                <li title="Save the current model in the Google Cloud, either publicly or privately. If it already exists you will be given the option to overwrite the old model." onclick="Actions.saveModelInCloud(true)">Save model in cloud...</li>
                -->
                <li><i>Load model from local file:</i></li>
                <li title="Load a model from an XML file accessible from your local computer."><input type="file" class="fileSelect" onchange="FileHandler.handleFiles(this.files); FileHandler.replaceInput(this.parentNode, this);"/></li>
                <li title="Save model XML definition and settings in browser cache. This is also done automatically when leaving this page." onclick="save(window, true)">Save settings in browser cache...</li>
                <li title="Save model XML definition to disk." onclick="Actions.saveToDisk(new XMLSerializer().serializeToString(Model.toXML(false)), 'xml')">Save model to local file...</li>
                <li title="Save model Scalable Vector Graphics file to disk." onclick="Actions.saveToDisk(new XMLSerializer().serializeToString(SVG), 'svg')">Save SVG to local file...</li>
                <li title="Sends an email with the XML description of the model to a specified recipient." onclick="Actions.createEmail(new XMLSerializer().serializeToString(Model.toXML(false)))">Send model by email...</li>
                <li title="Loads an example model based on a business managing actors that perform programs on different stages." onclick="Actions.loadFromURL('example.xml', true)">Load example model</li>
            </ul>
        </div>

        <div id="actions" class="menu">Layout
            <ul class="submenu">
                <li title="Toggle whether names should be visible in the modeler or not." onclick="Actions.toggleNames()">Toggle names</li>
                <li title="Toggle whether full names including mnemonics or short names excluding mnemonics should be used." onclick="Actions.toggleMnemonics()">Toggle mnemonics</li>
                <li title="Toggle whether coloring of edges should be visible or not." onclick="Actions.toggleColoring()">Toggle coloring</li>
                <li title="Toggle whether key routes should be visible or not." onclick="Actions.toggleKeys()">Toggle keys</li>
                <li title="Release all fixed nodes and fixate all released nodes." onclick="Actions.toggleFixation()">Toggle fixation</li>
                <li title="Release all fixed nodes." onclick="Actions.releaseAll()">Release all fixed</li>
                <li title="Hide attributes from anchors, and knots from both anchors and ties, in order to get a better overview of larger models." onclick="Actions.implodeAll()">Implode all</li>
                <li title="Unhide all hidden attributes and knots." onclick="Actions.explodeAll()">Explode all</li>
                <li title="Lost in your model? Resetting the view will center your model on screen and set the zoom back to its default value." onclick="Actions.resetZoom();Actions.centerModel()">Reset view</li>
                <li title="Having trouble finding a good layout? This will randomize the locations of all items and let the algorithms do the work." onclick="Actions.randomizeLayout()">Randomize layout</li>
            </ul>
        </div>

        <div id="generate" class="menu">Generate
            <ul class="submenu">
                <li title="Selects the target database for the generated SQL code.">
                    <select id="database" onchange="Settings.setDatabase(this.value, true)">
                        <option value="SQLServer" selected="selected">Microsoft SQL Server</option>
                        <option value="Oracle">Oracle</option>
                        <option value="PostgreSQL">PostgreSQL</option>
                        <option value="Vertica">Vertica</option>
                        <option value="Snowflake">Snowflake</option>
                    </select> Target database
                </li>
                <li title="Selects the version of the naming convention to use for the generated code.">
                    <select id="naming" onchange="Settings.setNaming(this.value)">
                        <option value="original">Original</option>
                        <option value="improved" selected="selected">Improved</option>
                    </select> Naming convention
                </li>
                <li title="Selects if the generated code should be unitemporal (only changing time), bitemporal (both changing and positing time), or concurrent-reliance-temporal (one changing with several subjective positing times with uncertainty).">
                    <select id="temporalization" onchange="Settings.setTemporalization(this.value)">
                        <option value="uni" selected="selected">Unitemporal</option>
                        <option value="bi">Bitemporal</option>
                        <option value="crt">Concurrent-reliance-temporal</option>
                    </select> Temporalization
                </li>
                <li title="Selects if the generated code should contain a metadata reference or not."><input id="metadataUsage" class="inputDefaults" type="checkbox" onchange="Settings.setMetadataUsage(this.checked ? 'true' : 'false')"/> Use metadata</li>
                <li title="Selects if the generated code should contain business views or not."><input id="businessViews" class="inputDefaults" type="checkbox" onchange="Settings.setBusinessViews(this.checked ? 'true' : 'false', true)"/> Use business views</li>
                <li title="Selects if the views should contain aliases for knots that mimic the naming of regular attributes."><input id="knotAliases" class="inputDefaults" type="checkbox" onchange="Settings.setKnotAliases(this.checked ? 'true' : 'false', true)"/> Use knot aliases</li>
                <li title="Selects if the generated code should contain triggers or not."><input id="triggers" class="inputDefaults" type="checkbox" onchange="Settings.setTriggers(this.checked ? 'true' : 'false', true)"/> Use triggers</li>
                <li title="Selects if equivalence should be allowed. Multiple values can be marked as having the same meaning, which for example is useful for multilingualism or multitenancy."><input id="equivalence" class="inputDefaults" type="checkbox" onchange="Settings.setEquivalence(this.checked ? 'true' : 'false', true)"/> Use equivalence</li>
                <li title="With decisiveness a positor may only hold a single belief within each assertion class (positive, negative, uncertain). With indecisiveness the same positor may hold multiple beliefs at a single positing time. In order to then still be consistent, the total reliability or all beliefs at a given point in time needs an upper limit."><input id="decisiveness" class="inputDefaults" type="checkbox" onchange="Settings.setDecisiveness(this.checked ? 'true' : 'false')"/> Use decisiveness</li>
                <li title="Entity integrity adds constraints ensuring that no temporal duplicates can co-exist for the same entity and version, that no negative recording time intervals can be stored, and that there are no overlapping intervals with respect to recording time. This is highly recommended."><input id="entityIntegrity" class="inputDefaults" type="checkbox" onchange="Settings.setEntityIntegrity(this.checked ? 'true' : 'false')"/> Use entity integrity</li>
                <li title="Selects whether to use partitioning of data. Applies to equivalents in uni-temporal and positors in concurrent-reliance-temporal modeling."><input id="partitioning" class="inputDefaults" type="checkbox" onchange="Settings.setPartitioning(this.checked ? 'true' : 'false')"/> Use partitioning</li>
                <li title="Generate SQL code for implementation of a model in a relational database." onclick="Actions.generateSQL()"> SQL code</li>
                <li title="Generate a portable and compact XML representation of your model, including information about the graphical layout." onclick="Actions.generateXML()"> XML code</li>
                <li title="Generate a JSON string to implement the model in a program." onclick="new CodePopover(Actions.preformat(Actions.jsonify(Model.toXML(false))), true)"> JSON string</li>
                <!--
                <li title="Generate a URL for a public model that can be shared over social media or through email." onclick="Actions.generateURL()"> URL for sharing</li>
                -->
                <li title="Generate an HTML legend that describes the items in your model." onclick="Actions.generateHTML()"> HTML documentation</li>
                <!--
                <li title="Generate a bitmap image of the view currently shown on screen." onclick="Actions.screenshot(Actions.toPNGDataURL(SVG))">PNG screenshot</li>
                -->
                <li title="Generate a vector image of the entire model." onclick="Actions.screenshot(Actions.toSVGDataURL(SVG))">SVG screenshot</li>
                <li title="Generate an SVG representation of the model." onclick="Actions.generateSVG(SVG)">SVG code</li>
            </ul>
        </div>

        <div id="controls">
            <div id="playpause">Pause</div>
            <div id="zoomin">Zoom+</div>
            <div id="zoomout">Zoom-</div>
            <div id="redo">Redo</div>
            <div id="undo">Undo</div>
        </div>

        <div id="search">
            <input id="searchFilter" type="text" placeholder=" search filter " title="Search the model for the given (sub)string." onfocus="Actions.stopKeyboardEvents()" onblur="Actions.populateSelector(document.getElementById('nodeSelector'), this.value)"/>
            <select id="nodeSelector" title="Focus model on the selected node." onmouseover="Actions.populateSelector(this, document.getElementById('searchFilter').value)" onchange="Actions.selectNode(this.value)">
                <option value="none" selected="selected">None selected</option>
            </select>
        </div>

        <div id="about" class="menu">Help
            <ul class="submenu">
                <li title="Takes you to a page containing a number of video tutorials explaining how to use the modeling tool." onclick="new URLPopover('http://www.anchormodeling.com/?page_id=186')">Tutorials</li>
                <li title="Shows a page with information about who coded the modeling tool, where it can be found, and the available keyboard shortcuts." onclick="new URLPopover('about.html')">About</li>
            </ul>
        </div>

        <div id="defaults" class="menu">Defaults
            <ul id="listOfDefaults" class="submenu">
                <li title="The default changing time (versions) 'data type' for newly created and historized items."><input id="defaultChangingRange" class="inputDefaults" type="text" onblur="Settings.setDefaultChangingRange(this.value)"/> Changing time range</li>
                <li title="The suffix used for the columns that store changing time (versions)."><input id="changingSuffix" class="inputDefaults" type="text" onblur="Settings.setChangingSuffix(this.value)"/> Changing time suffix</li>
                <li title="The suffix used for the columns that store checksums."><input id="checksumSuffix" class="inputDefaults" type="text" onblur="Settings.setChecksumSuffix(this.value)"/> Checksum suffix</li>
                <li title="The default 'schema' to use for new items."><input id="encapsulation" class="inputDefaults" type="text" onblur="Settings.setEncapsulation(this.value)"/> Capsule</li>
                <li title="The default 'data type' to use for identity columns."><input id="defaultIdentity" class="inputDefaults" type="text" onblur="Settings.setDefaultIdentity(this.value)"/> Identity</li>
                <li title="The suffix used for the columns that store identities."><input id="identitySuffix" class="inputDefaults" type="text" onblur="Settings.setIdentitySuffix(this.value)"/> Identity suffix</li>
                <li title="The prefix used for the columns that enable deletion."><input id="deletablePrefix" class="inputDefaults" type="text" onblur="Settings.setDeletablePrefix(this.value)"/> Deletable prefix</li>
                <li title="The suffix used for tables that contain deleted rows."><input id="deletionSuffix" class="inputDefaults" type="text" onblur="Settings.setDeletionSuffix(this.value)"/> Deletion suffix</li>
                <li title="The smallest common time type of all those used in the model."><input id="defaultChronon" class="inputDefaults" type="text" onblur="Settings.setDefaultChronon(this.value)"/> Chronon</li>
                <li title="How to get current, UTC or desired timestamping time from the database."><input id="defaultNow" class="inputDefaults" type="text" onblur="Settings.setDefaultNow(this.value)"/> Now</li>
                <li id="metadataSettingsBeforeHere" title="Default for new items. Restatable items can store the exact same value for consecutive changing times. Unchecking this will introduce a constraint preventing restatements."><input id="restatability" class="inputDefaults" type="checkbox" onchange="Settings.setRestatability(this.checked ? 'true' : 'false')"/> Restatability</li>
                <li title="Default for new items. Idempotent items discard any attempt to insert or update a value that is identical to the latest one stored with respect to changing time."><input id="idempotency" class="inputDefaults" type="checkbox" onchange="Settings.setIdempotency(this.checked ? 'true' : 'false')"/> Idempotency</li>
                <li title="Default for new items. Deletable items get additional update trigger logic, such that an update to null with a later changing time then the existing latest value will move rows into a corresponding deletion table."><input id="deletability" class="inputDefaults" type="checkbox" onchange="Settings.setDeletability(this.checked ? 'true' : 'false')"/> Deletability</li>
                <li title="Default for new items. Data may be encrypted at rest and this sets the default encryption group name for new items. A blank value indicates that no encryption should be used."><input id="encryptionGroup" class="inputDefaults" type="text" onblur="Settings.setEncryptionGroup(this.value)"/> Encryption group</li>
                <li id="crtSettingsBeforeHere" title="Resets all settings in this menu to their default values." onclick="Settings.resetDefaults(true)">Reset defaults to their default values</li>
            </ul>
        </div>

        <!-- TODO: focus gets "stuck" on the input fields below sometimes, annoying! -->
        <div id="settings" title="Expert settings" class="menu">Settings
            <ul id="listOfSettings" class="submenu">
                <li title="Damping can be likened to friction and is needed in order to slow down the movement of the nodes."><input id="damping" type="number" min="0" max="99" step="1" onblur="Settings.setDamping(this.value)"/> % Damping</li>
                <li title="The normal distance is the distance in pixels two nodes would be separated by if they were the only nodes in the graph."><input id="normalDistance" type="number" min="10" max="90" step="5" onblur="Settings.setNormalDistance(this.value)"/> px Normal distance</li>
                <li title="Any node whose velocity is smaller than this number is assumed to have stopped."><input id="stoppingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setStoppingVelocity(this.value)"/> px/s Stopping velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a small graph."><input id="minimumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMinimumStartingVelocity(this.value)"/> px/s Minimum starting velocity</li>
                <li title="The velocity needed for a stopped node to start moving again in a large graph."><input id="maximumStartingVelocity" type="number" min="0" max="9" step="0.1" onblur="Settings.setMaximumStartingVelocity(this.value)"/> px/s Maximum starting velocity</li>
                <li title="The size of space partitions in number of normal distances."><input id="partitionFactor" type="number" min="0" max="100" step="1" onblur="Settings.setPartitionFactor(this.value)"/> Partition size</li>
                <li title="The 'fuzziness' within which the size of the partitions are altered."><input id="fuzziness" type="number" min="0" max="100" step="1" onblur="Settings.setFuzziness(this.value)"/> % Fuzziness</li>
                <li title="The effect of the force from other partitions on nodes in the current partition."><input id="longRangeEffect" type="number" min="0" max="100" step="1" onblur="Settings.setLongRangeEffect(this.value)"/> % Long range effect</li>
                <li title="The stiffness of the edges control whether they behave like rubber bands or steel wires."><input id="stiffness" type="number" min="0" max="10" step="0.1" onblur="Settings.setStiffness(this.value)"/> Edge stiffness factor</li>
                <li title="The number of frame redraws needed in the large SVG to trigger a redraw of the miniature."><input id="miniatureFramesBetweenRefresh" type="number" min="1" max="99" step="1" onblur="Settings.setMiniRate(this.value)"/> Miniature refresh interval</li>
                <li title="Switching on advanced calculations lets you set more properties of nodes and edges, but at the cost of some performance." id="calcsItem">
                    <select id="calculations" onchange="Settings.setCalculations(this.value)">
                        <option value="simple" selected="selected">Simplified</option>
                        <option value="complex">Adjustable</option>
                    </select> &nbsp;Calculations
                </li>
                <li title="Resets all settings in this menu to their default values." onclick="Settings.resetSettings(true)">Reset settings to their default values</li>
                <li title="In debug mode force vectors will be drawn in the graph." onclick="Settings.toggleDebug()">Toggle debug</li>
            </ul>
        </div>
    </div>

    <!-- shows a navigatable miniature of the model -->
    <div id="miniature">
        <svg id="minigraph"
             class="unselectable"
             xmlns="http://www.w3.org/2000/svg"
             version="1.1"
             xmlns:xlink="http://www.w3.org/1999/xlink"
             viewBox="0 0 1 1"
             preserveAspectRatio="xMinYMin slice"
             width="1"
             height="1">
            <defs id="nav_graphics">
                <g id="nav_knot" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <rect width="20" height="20" rx="5" ry="5" transform="translate(-10, -10)"/>
                </g>
                <g id="nav_anchor" style="fill:#b55;">
                    <rect width="20" height="20" transform="translate(-10, -10)"/>
                </g>
                <g id="nav_tie" style="fill:#a8a8a8;">
                    <rect width="20" height="20" transform="rotate(45) translate(-10, -10)"/>
                </g>
                <g id="nav_tie_historized">
                    <rect width="22" height="22" transform="rotate(45) translate(-11, -11)" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;"/>
                    <rect width="14" height="14" transform="rotate(45) translate(-7, -7)" style="fill:#a8a8a8;"/>
                </g>
                <g id="nav_attribute" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <circle r="10"/>
                </g>
                <g id="nav_attribute_historized" style="fill:#fff; stroke:#f88; stroke-width:2px;">
                    <circle r="12"/>
                    <circle r="7"/>
                </g>
                <g id="nav_identifier" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;">
                    <circle r="13"/>
                    <g style="fill:#a8a8a8; stroke-width:0px;">
                        <circle r="2.5" transform="translate(0, -3)"/>
                        <polygon points="0,-2 -2,5 2,5" style="stroke-width:1px; stroke-linejoin:round; stroke-linecap:round;"/>
                    </g>
                </g>
                <g id="nav_identifier_historized" style="fill:#fff; stroke:#a8a8a8; stroke-width:2px;">
                    <circle r="16"/>
                    <circle r="11"/>
                    <g style="fill:#a8a8a8; stroke-width:0px;">
                        <circle r="2.5" transform="translate(0, -3)"/>
                        <polygon points="0,-2 -2,5 2,5" style="stroke-width:1px; stroke-linejoin:round; stroke-linecap:round;"/>
                    </g>
                </g>
            </defs>
        </svg>
    </div>

    <div id="logotype" class="unselectable">
        <img width="100%" src="Anchor.svg" type="image/svg+xml"/>
    </div>
    <div id="cloud" class="unselectable" onclick="Actions.checkCloudConnectionStatus(true)">
        <!-- filled dynamically -->
    </div>
    <div id="model" class="unselectable">
        <!-- filled dynamically -->
    </div>
</body>
</html>
